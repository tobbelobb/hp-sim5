<!DOCTYPE html>
<html>
<head>
    <title>Stressfulness Pinball</title>

    <link rel="icon" type="image/svg+xml"
      href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIj48Y2lyY2xlIGN4PSIxNiIgY3k9IjE2IiByPSIxNiIgZmlsbD0iZ3JleSIvPjwvc3ZnPg==" />
    <!-- Prevent pinch / double‑tap zoom while keeping responsiveness -->
    <meta name="viewport"
          content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">

    <!-- Nice free Google font - optional -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap">

    <style>
/* =========  BASIC COLOUR THEME  ========= */
:root {
  --bg-1: #2d2d2d;        /* page background */
  --accent-1: #ff452a;    /* flipper + button gradient start */
  --accent-2: #ffb347;    /* flipper + button gradient end   */
  --text-main: #fafafa;
  --text-dim:  #c0c0c0;
  --radius: 4px;
}

/* =========  PAGE LAYOUT  ========= */
html, body {
  margin: 0;
  padding: 0;
  height: 100dvh;                 /* use dynamic vh so iOS toolbars don't break it */
  overflow: hidden;               /* **kills the vertical / horizontal scroll**   */
  background: var(--bg-1);
  color: var(--text-main);
  font-family: "Inter", ui-sans-serif, system-ui, sans-serif;
  -webkit-tap-highlight-color: transparent; /* removes grey flash on iOS */
  touch-action: none;     /* **stops double‑tap zoom in most browsers**   */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
}

/* =========  CONTAINER  ========= */
#gameContainer {
  width: min(90vw, 460px);
  max-height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* =========  CONTROL BAR  ========= */
#controls {
  width: 100%;
  text-align: center;
  margin-block: 12px 8px;
  font-size: 0.9rem;
  color: var(--text-dim);
}

#controls button {
  all: unset;                      /* wipe default button styles */
  cursor: pointer;
  display: inline-block;
  margin: 6px auto;
  border-radius: var(--radius);
  font-weight: 600;
  font-size: 0.95rem;
  color: #fff;
  background: var(--accent-1);
  box-shadow: 0 3px 8px rgba(0,0,0,.45);
  transition: transform .12s ease, box-shadow .12s ease;
}
#controls button:hover,
#controls button:focus-visible {
  transform: translateY(-2px);
  box-shadow: 0 5px 14px rgba(0,0,0,.55);
}
#controls button:active {
  transform: scale(.97);
}

/* =========  CANVAS  ========= */
canvas {
  width: 100%;
  aspect-ratio: 1 / 1.7;          /* keeps exact sim ratio */
  border-radius: var(--radius);
  touch-action: manipulation;    /* turn off browser panning/zoom so pointermove/up always fire */
}

/* =========  SMALL‑SCREEN TWEAKS  ========= */
#controls button {
  padding: 10px 16px;
  font-size: 0.85rem;
}
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="controls">
            <button id="pauseBtn" tabindex="-1">Pause</button>
            <button id="resetBtn" tabindex="-1">Reset</button>
            <button id="stepBtn">Step</button>
            <button id="dumpBtn" tabindex="-1">Dump State</button><br />
          Score: <span id="score">0</span>
        </div>
        <canvas id="myCanvas"></canvas>
    </div>
<script type="module">
    import Vector2 from './cable_joints/vector2.js';
    import { dumpWorldState } from './cable_joints/debugUtils.js';
    import {
      World,
      PauseStateComponent,
      SimulationErrorStateComponent,
      BorderComponent,
      RenderableComponent,
      BallTagComponent,
      PositionComponent,
      VelocityComponent,
      RadiusComponent,
      MassComponent,
      RestitutionComponent,
      GravityAffectedComponent,
      OrientationComponent,
      AngularVelocityComponent,
      MomentOfInertiaComponent,
      ObstacleTagComponent,
      FlipperTagComponent,
      FlipperStateComponent,
      PrevFinalPosComponent
    } from './cable_joints/ecs.js';

    import {
      CableLinkComponent,
      CableJointComponent,
      CablePathComponent,
      linecolor1,
      CableAttachmentUpdateSystemPathWise,
      PBDCableConstraintSolverPathWise
    } from './cable_joints/cable_joints_core.js';

    import {
      tangentFromPointToCircle,
      tangentFromCircleToPoint,
      tangentFromCircleToCircle,
      closestPointOnSegment,
      rightOfLine
    } from './cable_joints/geometry.js';

    import {
      PrevFinalPosSystem,
      InputReplaySystem,
      GravitySystem,
      MovementSystem,
      AngularMovementSystem,
      PBDBallBallCollisions
    } from './cable_joints/commonSystems.js';

    import {
      RenderSystem
    } from './cable_joints/renderSystem.js';

    class ScoreComponent { constructor(score = 0) { this.value = score; } }
    class ScoredTagComponent { }
    class ObstaclePushComponent { constructor(pushVel = 2.0) { this.pushVel = pushVel; } }

    // helper to remember which flipper this tip belongs to
    class FlipperTipComponent {
      constructor(flipperEntityId) {
        this.flipperEntityId = flipperEntityId;
      }
    }


    // Register FlipperTipLinkSystem BEFORE CableAttachmentUpdateSystem
    class FlipperTipLinkSystem {
      runInPause = false;
      update(world, dt) {
        // for each tip‐entity, compute its current position
        for (const tipId of world.query([FlipperTipComponent, PositionComponent, FlipperTipComponent])) {
          const tipComp   = world.getComponent(tipId, FlipperTipComponent);
          const flipId    = tipComp.flipperEntityId;
          const pivotPos  = world.getComponent(flipId, PositionComponent).pos;
          const state     = world.getComponent(flipId, FlipperStateComponent);
          // same math you use elsewhere to find the tip
          const angle = state.restAngle + state.sign * state.rotation;
          const dir   = new Vector2(Math.cos(angle), Math.sin(angle));
          const tipPos = pivotPos.clone().add(dir, state.length);
          // write it into the tip entity’s PositionComponent
          world.getComponent(tipId, PositionComponent).pos.set(tipPos);
        }
      }
    }


    // --- System: Input --- (Simplified Click Handling)
    class InputSystem {
         runInPause = true; // Input should work even when paused to unpause/interact

         constructor(canvas) {
             this.canvas = canvas;
             this.clicks = [];
             this.releases = [];
             this.eventLog = [];     // record inputs per frame
             this.frame = 0;         // frame counter
             this.grabSpring = null; // { ptrE, jointE, pathE, ballE }
             this.canvas.setAttribute('tabindex', '0');
             this.canvas.style.outline = 'none';
             this.canvas.focus();
             // listen globally so ups/downs outside the canvas still fire
             document.addEventListener('pointerdown', this.handlePointerDown.bind(this));
             document.addEventListener('pointerup', this.handlePointerUp.bind(this));
             this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
             this.canvas.addEventListener('keydown', this.handleKeydown.bind(this));
             this.canvas.addEventListener('keyup', this.handleKeyup.bind(this));
         }

        // on Space -> emit minimal debug dump
        dumpDebugScenario() {
            // Custom stringification to serialize Vector2 instances
            const resStr = JSON.stringify(world.resources);
            const logEntries = this.eventLog.map(frame => {
                const clicksStr = frame.clicks.map(p => `new Vector2(${p.x}, ${p.y})`).join(', ');
                const releasesStr = frame.releases.map(p => `new Vector2(${p.x}, ${p.y})`).join(', ');
                return `{ "frame": ${frame.frame}, "clicks": [${clicksStr}], "releases": [${releasesStr}] }`;
            }).join(', ');
            console.log('DEBUG_SCENARIO_DUMP', `{ "resources": ${resStr}, "inputLog": [${logEntries}] }`);
        }

         handleKeyup(event) {
             if (event.key == 'ArrowLeft' || event.key == 'ArrowRight') {
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 if (flipperEntities.length < 2) {
                   return;
                 }
                 var firstPos = world.getComponent(flipperEntities[0], PositionComponent).pos;
                 var secondPos = world.getComponent(flipperEntities[1], PositionComponent).pos;
                 if (firstPos.x < secondPos.x) {
                     if (event.key == 'ArrowLeft') {
                       this.releases.push(firstPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.releases.push(secondPos);
                     }
                 } else {
                     if (event.key == 'ArrowLeft') {
                       this.releases.push(secondPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.releases.push(firstPos);
                     }
                 }
             }
         }

         handleKeydown(event) {
             if (event.code === 'Space') {
                 this.dumpDebugScenario();
             }
             if (event.key == 'ArrowLeft' || event.key == 'ArrowRight') {
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 if (flipperEntities.length < 2) {
                   return;
                 }
                 var firstPos = world.getComponent(flipperEntities[0], PositionComponent).pos;
                 var secondPos = world.getComponent(flipperEntities[1], PositionComponent).pos;
                 if (firstPos.x < secondPos.x) {
                     if (event.key == 'ArrowLeft') {
                       this.clicks.push(firstPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.clicks.push(secondPos);
                     }
                 } else {
                     if (event.key == 'ArrowLeft') {
                       this.clicks.push(secondPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.clicks.push(firstPos);
                     }
                 }
             }
         }

         handlePointerDown(event) {
             event.preventDefault();
             const rect = this.canvas.getBoundingClientRect();
             const scale = this.canvas.height / world.getResource('simHeight'); // Need access to world/scale somehow
             const simX = (event.clientX - rect.left) / scale;
             const simY = (this.canvas.height - (event.clientY - rect.top)) / scale;

             const cmOnScreen = 0.5; // Desired clickable radius increase in physical cm
             const dpi = 96; // Approximate screen DPI; adjust or measure if needed
             const pixelsPerCm = dpi / 2.54;
             const extraPixels = cmOnScreen * pixelsPerCm;
             const extraClickableRadius = extraPixels / scale;

             // 1) see if we hit a ball
             const clickVec = new Vector2(simX, simY);

             let closestBall = null;
             let closestDistSq = Infinity;
             for (const b of world.query([BallTagComponent, PositionComponent, RadiusComponent])) {
               const pos = world.getComponent(b, PositionComponent).pos;
               const r = world.getComponent(b, RadiusComponent).radius + extraClickableRadius;
               const distSq = clickVec.clone().subtract(pos).lengthSq();
               if (distSq <= r * r && distSq < closestDistSq) {
                 closestBall = b;
                 closestDistSq = distSq;
               }
             }

             if (closestBall !== null) {
               // 1) create a pointer‐link entity at the mouse
               const ptrE = world.createEntity();
               world.addComponent(ptrE, new PositionComponent(simX, simY));
               world.addComponent(ptrE, new CableLinkComponent(simX, simY));

               // 2) create a joint between ball and pointer
               //    restLength = 0 so it's a pure spring
               const ballPos = world.getComponent(closestBall, PositionComponent).pos.clone();
               const ballMass = world.getComponent(closestBall, MassComponent).mass;
               const ptrPos  = new Vector2(simX, simY);
               const jointE = world.createEntity();
               world.addComponent(jointE,
                 new CableJointComponent(
                   closestBall,  // entityA
                   ptrE,         // entityB
                   0.05,          // restLength
                   ballPos,      // attachmentA_world
                   ptrPos        // attachmentB_world
                 )
               );
               world.addComponent(jointE, new RenderableComponent('line', '#888888'));

               // 3) wrap it in a CablePathComponent (spring_constant = 100)
               const pathE = world.createEntity();
               const pathComp = new CablePathComponent(
                 world,
                 [ jointE ],               // one joint
                 ['attachment', 'attachment'], // one linkType
                 [ true ],                 // cw flag (arbitrary)
                 100000.0*ballMass         // spring_constant
               );
               world.addComponent(pathE, pathComp);

               // 4) store for move/release
               this.grabSpring = { ptrE, jointE, pathE, ballE: closestBall };
               world.setResource('grabbedBall', closestBall);

               const pauseState = world.getResource('pauseState');
               pauseState.paused = false;
               pauseBtn.textContent = "Pause";

               return;
             }

             this.clicks.push(new Vector2(simX, simY));
         }

         handlePointerUp(event) {
             event.preventDefault();
             this.canvas.releasePointerCapture(event.pointerId);
             const rect = this.canvas.getBoundingClientRect();
             const scale = this.canvas.height / world.getResource('simHeight'); // Need access to world/scale somehow
             const simX = (event.clientX - rect.left) / scale;
             const simY = (this.canvas.height - (event.clientY - rect.top)) / scale;

             // if we were grabbing with a spring, tear it down
             if (this.grabSpring) {
               const { ptrE, jointE, pathE, ballE } = this.grabSpring;
               // On release, reset ball velocity to zero to avoid slingshot
               const velComp = world.getComponent(ballE, VelocityComponent);
               const posComp = world.getComponent(ballE, PositionComponent);
               const prevFinalPosComp = world.getComponent(ballE, PrevFinalPosComponent);

               const dt = world.getResource('dt');
               if (velComp) {
                 velComp.vel.set(posComp.pos.clone().subtract(prevFinalPosComp.pos).scale(1.0/dt));
               }
               world.destroyEntity(pathE);
               world.destroyEntity(jointE);
               world.destroyEntity(ptrE);
               this.grabSpring = null;
               world.setResource('grabbedBall', null);
               return;
             }
             this.releases.push(new Vector2(simX, simY));
         }

         update(world, dt) {
             // snapshot and clear inputs each frame
             const clicksFrame = this.clicks.slice();
             const releasesFrame = this.releases.slice();
             if (clicksFrame.length > 0 || releasesFrame.length > 0) {
                 this.eventLog.push({ frame: this.frame, clicks: clicksFrame, releases: releasesFrame });
             }
             this.frame++;

             if (clicksFrame.length > 0) {
                 const clickPos = this.clicks.shift(); // Process one click per frame for simplicity
               // --- find all flippers ---
               const flipperEntities = world.query([
                 FlipperTagComponent,
                 PositionComponent,
                 FlipperStateComponent
               ]);
               // get world bounds
               const simWidth  = world.getResource('simWidth');
               const simHeight = world.getResource('simHeight');

               // test if click is in‐canvas but outside the border polygon
               let outsideBorder = false;
               const borderEnts = world.query([BorderComponent]);
               const borderPoints = world.getComponent(borderEnts[0], BorderComponent).points;
               const rightClick =
                 rightOfLine(clickPos, borderPoints[0], borderPoints[1]) &&
                 rightOfLine(clickPos, borderPoints[1], borderPoints[2]);
               const leftClick =
                 rightOfLine(clickPos, borderPoints[5], borderPoints[6]) &&
                 rightOfLine(clickPos, borderPoints[6], borderPoints[7]);
               if (rightClick) {
                 const flippers = world.query([FlipperStateComponent, PositionComponent]);
                 const flipperPos0 = world.getComponent(flippers[0], PositionComponent).pos;
                 const flipperPos1 = world.getComponent(flippers[1], PositionComponent).pos;
                 if (flipperPos0.x > flipperPos1.x) {
                   world.getComponent(flippers[0], FlipperStateComponent).pressed = true;
                 } else {
                   world.getComponent(flippers[1], FlipperStateComponent).pressed = true;
                 }
               } else if (leftClick) {
                 const flippers = world.query([FlipperStateComponent, PositionComponent]);
                 const flipperPos0 = world.getComponent(flippers[0], PositionComponent).pos;
                 const flipperPos1 = world.getComponent(flippers[1], PositionComponent).pos;
                 if (flipperPos0.x < flipperPos1.x) {
                   world.getComponent(flippers[0], FlipperStateComponent).pressed = true;
                 } else {
                   world.getComponent(flippers[1], FlipperStateComponent).pressed = true;
                 }
               } else {
                 // click inside play‐area -> original pivot‐radius test
                 for (const id of flipperEntities) {
                   const pos   = world.getComponent(id, PositionComponent).pos;
                   const state = world.getComponent(id, FlipperStateComponent);
                   if (clickPos.clone().subtract(pos).lengthSq() < state.length ** 2) {
                     state.pressed = true;
                   }
                 }
               }
             }

             if (this.releases.length > 0) {
                 const releasePos = this.releases.shift();
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 let closestId = null;
                 let minDistSq = Infinity;
                 // only consider flippers that are currently pressed
                 for (const id of flipperEntities) {
                     const state = world.getComponent(id, FlipperStateComponent);
                     if (!state.pressed) continue;
                     const pos = world.getComponent(id, PositionComponent).pos;
                     const d2 = releasePos.clone().subtract(pos).lengthSq();
                     if (d2 < minDistSq) {
                         minDistSq = d2;
                         closestId = id;
                     }
                 }
                 if (closestId !== null) {
                     world.getComponent(closestId, FlipperStateComponent).pressed = false;
                 }
             }

             // Could add logic here to interact with pause button entity if it existed
         }

         handlePointerMove(event) {
           event.preventDefault();
           const rect = this.canvas.getBoundingClientRect();
           const scale = this.canvas.height / world.getResource('simHeight');
           const simX = (event.clientX - rect.left) / scale;
           const simY = (this.canvas.height - (event.clientY - rect.top)) / scale;
           if (this.grabSpring) {
             const { ptrE } = this.grabSpring;
             const pos = world.getComponent(ptrE, PositionComponent).pos;
             pos.set(new Vector2(simX, simY));
           }
         }
    }


    // --- System: Flipper Motion ---
    class FlipperMotionSystem {
        runInPause = true;
        update(world, dt) {
            const flipperEntities = world.query([FlipperStateComponent]);
            for (const entityId of flipperEntities) {
                const state = world.getComponent(entityId, FlipperStateComponent);

                const prevRotation = state.rotation;
                if (state.pressed) {
                    state.rotation = Math.min(state.rotation + dt * state.angularVelocity, state.maxRotation);
                } else {
                    state.rotation = Math.max(state.rotation - dt * state.angularVelocity, 0.0);
                }
                // Avoid division by zero if dt is tiny
                state.currentAngularVelocity = (dt > 1e-6) ? state.sign * (state.rotation - prevRotation) / dt : 0.0;
            }
        }
    }

    class ScoreSystem {
        runInPause = false;

        update(world, dt) {
            // One entity is holding the global score
            const scoreEntity = world.query([ScoreComponent])[0]; // Shold be only one scoreEntity
            const scoreComp = scoreEntity !== undefined ? world.getComponent(scoreEntity, ScoreComponent) : null;

            // Multiple entities might have scored since the previous update
            const scoredEntities = world.query([ScoredTagComponent]);
            for (const scoredId of scoredEntities) {
               world.removeComponent(scoredId, ScoredTagComponent);
               scoreComp.value++;
            }
        }
    }


    // --- System: Score Display ---
    class ScoreDisplaySystem {
        runInPause = true; // Score should update even if paused? Or maybe not? Your call.
        constructor(elementId) {
            this.scoreElement = document.getElementById(elementId);
        }
        update(world, dt) {
            const scoreEntity = world.query([ScoreComponent])[0]; // Shold be only one scoreEntity
            if (scoreEntity !== undefined && this.scoreElement) {
                const scoreComp = world.getComponent(scoreEntity, ScoreComponent);
                this.scoreElement.textContent = scoreComp.value.toString();
            }
        }
    }

    class PBDBallFlipperCollisions {
      _getFlipperTip(flipperPos, flipperState) {
        const angle = flipperState.restAngle + flipperState.sign * flipperState.rotation;
        const dir = new Vector2(Math.cos(angle), Math.sin(angle));
        return flipperPos.clone().add(dir, flipperState.length);
      }

      update(world, dt) {
        const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
        const flipperEntities = world.query([FlipperTagComponent, PositionComponent, RadiusComponent, FlipperStateComponent, RestitutionComponent]);
        for (const ballId of ballEntities) {
          const p1 = world.getComponent(ballId, PositionComponent).pos;
          const v1 = world.getComponent(ballId, VelocityComponent).vel;
          const r1 = world.getComponent(ballId, RadiusComponent).radius;
          // Ball restitution handled in border/ball-ball

          for (const flipId of flipperEntities) {
            const fp = world.getComponent(flipId, PositionComponent).pos;
            const fr = world.getComponent(flipId, RadiusComponent).radius; // Flipper thickness/radius
            const fs = world.getComponent(flipId, FlipperStateComponent);

            const tip = this._getFlipperTip(fp, fs);
            const closest = closestPointOnSegment(p1, fp, tip);

            const dir = new Vector2().subtractVectors(p1, closest);
            const dSq = dir.lengthSq();
            const rSum = r1 + fr;

            if (dSq == 0.0 || dSq > rSum * rSum) continue;

            const d = Math.sqrt(dSq);
            dir.scale(1.0 / d); // Normalize

            // Resolve penetration
            const corr = rSum - d;
            p1.add(dir, corr);

            // Resolve velocity - Calculate surface velocity at contact point
            const radiusVec = closest.clone().subtract(fp); // Vector from pivot to contact point
            // Add the penetration correction offset relative to the pivot
            const contactPointOnFlipperSurface = fp.clone().add(radiusVec).add(dir, -fr); // Approx point on flipper surface
            const radiusToSurface = contactPointOnFlipperSurface.subtract(fp);


            // Velocity of the flipper surface at the contact point = w x r (angular velocity cross radius vector)
            // In 2D, (0,0,w) x (rx, ry, 0) = (-w*ry, w*rx, 0)
            const surfaceVel = new Vector2(-fs.currentAngularVelocity * radiusToSurface.y, fs.currentAngularVelocity * radiusToSurface.x);

            // Project ball velocity and surface velocity onto the collision normal
            const v_dot = v1.dot(dir);
            const surfVel_dot = surfaceVel.dot(dir);

            // Simple model: Make the ball's normal velocity match the flipper's surface normal velocity
            // This effectively means v_new_dot = surfVel_dot
            // More physically plausible might involve restitution e = (v_new_dot - surfVel_dot) / (surfVel_dot - v_dot)
            // But sticking to original logic:
            v1.add(dir, surfVel_dot - v_dot);

          }
        }
      }
    }

    class PBDBallBorderCollisions {
      update(world, dt) {
        const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
        const borderEntities = world.query([BorderComponent]);
        if (borderEntities.length > 0) {
          const borderId = borderEntities[0]; // Assume only one border
          const borderComp = world.getComponent(borderId, BorderComponent);
          const borderPoints = borderComp.points;

          if (borderPoints.length >= 3) {
            for (const ballId of ballEntities) {
              const p1 = world.getComponent(ballId, PositionComponent).pos;
              const v1 = world.getComponent(ballId, VelocityComponent).vel;
              const r1 = world.getComponent(ballId, RadiusComponent).radius;
              const res1 = world.getComponent(ballId, RestitutionComponent).restitution;

              let minDistSq = Infinity;
              let closestSegPoint = new Vector2();
              let edgeNormal = new Vector2();
              let edgeStart = null;
              let edgeEnd = null;

              // Find closest point on the entire border polygon
              for (let i = 0; i < borderPoints.length; i++) {
                const a = borderPoints[i];
                const b = borderPoints[(i + 1) % borderPoints.length];
                const closestPtOnSeg = closestPointOnSegment(p1, a, b);
                const distSq = p1.clone().subtract(closestPtOnSeg).lengthSq();

                if (distSq < minDistSq) {
                  minDistSq = distSq;
                  closestSegPoint.set(closestPtOnSeg);
                  edgeStart = a;
                  edgeEnd = b;
                }
              }

              if (minDistSq > r1 * r1) continue; // Not colliding

              // Calculate normal (outward-pointing assuming clockwise vertices)
              const edgeVec = new Vector2().subtractVectors(edgeEnd, edgeStart);
              const normal = edgeVec.perp().normalize(); // Points outwards for CW polygon

              // Check if the ball center is outside the border (it should be!)
              // If the closest point is a vertex, the normal needs careful handling,
              // but for simple penetration resolution, using the segment normal is often okay.
              const ballToClosest = new Vector2().subtractVectors(p1, closestSegPoint);
              let collisionNormal = ballToClosest.clone();
              if (collisionNormal.lengthSq() < 1e-9) {
                // Ball center is exactly on the border segment, use edge normal
                collisionNormal.set(normal);
              } else {
                collisionNormal.normalize();
              }


              // Ensure normal points from border towards ball
              // Check if ball is roughly 'inside' the normal direction from the closest point
              if (ballToClosest.dot(normal) < 0) {
                // Ball might be inside corner, use segment normal but check distance
                collisionNormal.set(normal); // Use segment normal for resolution
              }


              const dist = Math.sqrt(minDistSq);

              // Resolve penetration
              const penetration = r1 - dist;
              if (penetration > 0) {
                p1.add(collisionNormal, penetration);
              }

              // Resolve velocity
              const v_dot = v1.dot(collisionNormal);
              if (v_dot < 0) { // Only apply restitution if moving towards the wall
                const v_new_dot = -v_dot * res1; // Reflect velocity component
                v1.add(collisionNormal, v_new_dot - v_dot);
              }
            }
          }
        }
      }
    }

    class PBDBallObstacleCollisions2 {
      update(world, dt) {
        const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
        const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent, ObstaclePushComponent]);
        for (const ballId of ballEntities) {
          const p1 = world.getComponent(ballId, PositionComponent).pos;
          const v1 = world.getComponent(ballId, VelocityComponent).vel;
          const r1 = world.getComponent(ballId, RadiusComponent).radius;

          for (const obsId of obstacleEntities) {
            const p2 = world.getComponent(obsId, PositionComponent).pos;
            const r2 = world.getComponent(obsId, RadiusComponent).radius;
            const pushVel = world.getComponent(obsId, ObstaclePushComponent).pushVel;

            const dir = new Vector2().subtractVectors(p1, p2);
            const dSq = dir.lengthSq();
            const rSum = r1 + r2;

            if (dSq == 0.0 || dSq > rSum * rSum) continue;

            const d = Math.sqrt(dSq);
            dir.scale(1.0 / d); // Normalize

            // Resolve penetration
            const corr = rSum - d;
            p1.add(dir, corr);

            // Resolve velocity (simple push)
            const v_dot = v1.dot(dir);
            v1.add(dir, pushVel - v_dot); // Impart obstacle's push velocity along normal

            // Add ScoredTagComponent to the ball that scored
            const grabbed = world.getResource('grabbedBall');
            if (ballId !== grabbed) {
              world.addComponent(ballId, new ScoredTagComponent());
            }
          }
        }
      }
    }

    // --- Global Setup ---
    const canvas = document.getElementById("myCanvas");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const stepBtn = document.getElementById("stepBtn");

    // --- Global World ---
    let world = new World();
    window.world = world; // Make available to jest test

    let getGameStateForTest = () => {
        if (!world || !world.query) { // Check if world and its methods are available
            console.error("World object not available for getGameStateForTest");
            return null;
        }

        const ballEntities = world.query([BallTagComponent, PositionComponent]);
        const balls = ballEntities.map(id => {
            const posComp = world.getComponent(id, PositionComponent);
            return { id, y: posComp ? posComp.pos.y : -Infinity }; // Handle missing component
        });

        const scoreEntity = world.query([ScoreComponent])[0];
        const scoreComp = scoreEntity !== undefined ? world.getComponent(scoreEntity, ScoreComponent) : null;
        const score = scoreComp ? scoreComp.value : -1; // Default to -1 if score component not found

        return {
            balls,
            score
        };
    };
    window.getGameStateForTest = getGameStateForTest;

    // --- Scene Setup ---
    function setupScene() {
        world.clear(); // Clear entities and components

        // --- Set Canvas Size from CSS ---
        // Match drawing buffer size to the CSS display size
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        // --- Calculate Simulation Dimensions & Scale ---
        const simHeight = 1.7; // Target simulation height remains fixed
        const cScale = canvas.height / simHeight; // Calculate scale based on actual height
        const simWidth = canvas.width / cScale; // Calculate sim width based on actual width and scale

        // console.log(`Canvas: ${canvas.width}x${canvas.height}, Sim: ${simWidth.toFixed(2)}x${simHeight.toFixed(2)}, Scale: ${cScale.toFixed(2)}`);


        // --- Resources ---
        world.setResource('gravity', new Vector2(0.0, -2.0));
        world.setResource('dt', 1.0 / 600.0);
        world.setResource('simWidth', simWidth);
        world.setResource('simHeight', simHeight); // Store the reference simHeight
        world.setResource('pauseState', new PauseStateComponent(true));
        world.setResource('debugRenderPoints', {}); // Initialize debug points resource
        world.setResource('errorState', new SimulationErrorStateComponent(false)); // Initialize error state
        // reset any grab
        world.setResource('grabbedBall', null);


        // --- Entities and Components ---

        const offset = 0.02;

        // Border Entity (Clockwise points for outward normal calc)
        const borderEntity = world.createEntity();
        const borderPoints = [
             new Vector2(0.74, 0.0),
             new Vector2(0.74, 0.25),
             new Vector2(1.0 - offset, 0.4),
             new Vector2(1.0 - offset, simHeight - offset),
             new Vector2(offset, simHeight - offset),
             new Vector2(offset, 0.4),
             new Vector2(0.26, 0.25),
             new Vector2(0.26, 0.0)
        ];
        world.addComponent(borderEntity, new BorderComponent(borderPoints));
        world.addComponent(borderEntity, new RenderableComponent('border', '#000000'));


        // Ball Entities
        const ballRadius = 0.03;
        const ballMass = Math.PI * ballRadius * ballRadius;
        const ballRestitution = 0.4; // Slightly higher for more bounce

        const ball1 = world.createEntity();
        world.addComponent(ball1, new BallTagComponent());
        world.addComponent(ball1, new PositionComponent(0.90, 0.95));
        world.addComponent(ball1, new VelocityComponent(0.0, 0.0));
        world.addComponent(ball1, new RadiusComponent(ballRadius));
        world.addComponent(ball1, new MassComponent(ballMass));
        world.addComponent(ball1, new RestitutionComponent(ballRestitution));
        world.addComponent(ball1, new GravityAffectedComponent());
        world.addComponent(ball1, new RenderableComponent('circle', '#a0a0a0'));
        world.addComponent(ball1, new OrientationComponent(0.0));
        world.addComponent(ball1, new AngularVelocityComponent(0.0));
        const ball1Inertia = 30.0 * 0.5 * ballMass * ballRadius * ballRadius;
        world.addComponent(ball1, new MomentOfInertiaComponent(ball1Inertia));

        const ball2 = world.createEntity();
        world.addComponent(ball2, new BallTagComponent());
        world.addComponent(ball2, new PositionComponent(0.08, 0.5));
        world.addComponent(ball2, new VelocityComponent(0.0, 0.0));
        world.addComponent(ball2, new RadiusComponent(ballRadius));
        world.addComponent(ball2, new MassComponent(ballMass));
        world.addComponent(ball2, new RestitutionComponent(ballRestitution));
        world.addComponent(ball2, new GravityAffectedComponent());
        world.addComponent(ball2, new RenderableComponent('circle', '#a0a0a0'));
        world.addComponent(ball2, new OrientationComponent(0.0));
        world.addComponent(ball2, new AngularVelocityComponent(0.0));
        const ball2Inertia = 30.0 * 0.5 * ballMass * ballRadius * ballRadius;
        world.addComponent(ball2, new MomentOfInertiaComponent(ball2Inertia));

        // Obstacle Entities
        const obsColor1 = "#FF8000";
        const obsColor2 = "#0F7090";
        const obsPush = 1.7;

        const obs1 = world.createEntity();
        world.addComponent(obs1, new ObstacleTagComponent());
        world.addComponent(obs1, new PositionComponent(0.25, 0.6));
        world.addComponent(obs1, new MassComponent(-1.0));
        world.addComponent(obs1, new RadiusComponent(0.1));
        world.addComponent(obs1, new ObstaclePushComponent(obsPush));
        world.addComponent(obs1, new RenderableComponent('circle', obsColor2));

        const obs2 = world.createEntity();
        world.addComponent(obs2, new ObstacleTagComponent());
        world.addComponent(obs2, new PositionComponent(0.75, 0.5));
        world.addComponent(obs2, new MassComponent(-1.0));
        world.addComponent(obs2, new RadiusComponent(0.1));
        world.addComponent(obs2, new ObstaclePushComponent(obsPush));
        world.addComponent(obs2, new RenderableComponent('circle', obsColor2));

        const obs3 = world.createEntity();
        world.addComponent(obs3, new ObstacleTagComponent());
        world.addComponent(obs3, new PositionComponent(0.7, 1.0));
        world.addComponent(obs3, new MassComponent(-1.0));
        world.addComponent(obs3, new RadiusComponent(0.12));
        world.addComponent(obs3, new ObstaclePushComponent(obsPush));
        world.addComponent(obs3, new RenderableComponent('circle', obsColor1));

        const obs4 = world.createEntity();
        world.addComponent(obs4, new ObstacleTagComponent());
        world.addComponent(obs4, new PositionComponent(0.2, 1.2));
        world.addComponent(obs4, new MassComponent(-1.0));
        world.addComponent(obs4, new RadiusComponent(0.1));
        world.addComponent(obs4, new ObstaclePushComponent(obsPush));
        world.addComponent(obs4, new RenderableComponent('circle', obsColor1));


        // Flipper Entities
        const flipRadius = 0.03; // Thickness
        const flipLength = 0.2;
        const flipMaxRotation = 1.0; // Radians
        const flipRestAngle = 0.5; // Radians from horizontal
        const flipAngularVelocity = 20.0; // Radians per second
        const flipColor = "#FF0000";
        const flipRestitution = 0.2;

        const flipper1 = world.createEntity();
        world.addComponent(flipper1, new FlipperTagComponent());
        world.addComponent(flipper1, new PositionComponent(0.26, 0.22));
        world.addComponent(flipper1, new RadiusComponent(flipRadius));
        world.addComponent(flipper1, new FlipperStateComponent(flipLength, -flipRestAngle, flipMaxRotation, flipAngularVelocity));
        world.addComponent(flipper1, new RestitutionComponent(flipRestitution));
        world.addComponent(flipper1, new RenderableComponent('flipper', flipColor));
        // make the pivot (and tip) act as a cable‐link
        world.addComponent(flipper1, new CableLinkComponent(0.26, 0.22));
        // Flipper 1 tip entity
        const flipper1Tip = world.createEntity();
        world.addComponent(flipper1Tip, new PositionComponent());
        world.addComponent(flipper1Tip, new RadiusComponent(flipRadius));
        world.addComponent(flipper1Tip, new FlipperTipComponent(flipper1));
        world.addComponent(flipper1Tip, new CableLinkComponent());

        const flipper2 = world.createEntity();
        world.addComponent(flipper2, new FlipperTagComponent());
        world.addComponent(flipper2, new PositionComponent(0.74, 0.22));
        world.addComponent(flipper2, new RadiusComponent(flipRadius));
        world.addComponent(flipper2, new FlipperStateComponent(flipLength, Math.PI + flipRestAngle, -flipMaxRotation, flipAngularVelocity));
        world.addComponent(flipper2, new RestitutionComponent(flipRestitution));
        world.addComponent(flipper2, new RenderableComponent('flipper', flipColor));
        // also make this flipper a cable link
        world.addComponent(flipper2, new CableLinkComponent());
        // Flipper 2 tip entity
        const flipper2Tip = world.createEntity();
        world.addComponent(flipper2Tip, new PositionComponent());
        world.addComponent(flipper2Tip, new RadiusComponent(flipRadius));
        world.addComponent(flipper2Tip, new CableLinkComponent());
        world.addComponent(flipper2Tip, new FlipperTipComponent(flipper2));

        // Score Entity
        const scoreEntity = world.createEntity();
        world.addComponent(scoreEntity, new ScoreComponent(0));


        // --- Cable Setup ---
        // Connect: ball2 -> obs4 -> obs3 -> ball1

        // --- Calculate Initial Cable State ---
        // Need to compute initial attachment points and rest lengths
        // Get relevant components
        const pos_ball1 = world.getComponent(ball1, PositionComponent).pos;
        const pos_ball2 = world.getComponent(ball2, PositionComponent).pos;
        const pos_obs3 = world.getComponent(obs3, PositionComponent).pos;
        const radius_obs3 = world.getComponent(obs3, RadiusComponent).radius;
        const pos_obs4 = world.getComponent(obs4, PositionComponent).pos;
        const radius_obs4 = world.getComponent(obs4, RadiusComponent).radius;

        // Add necessary components to obstacles (assuming they act as wheels)
        world.addComponent(obs4, new CableLinkComponent(pos_obs4.x, pos_obs4.y));
        world.addComponent(obs3, new CableLinkComponent(pos_obs3.x, pos_obs3.y));
        //world.addComponent(obs2, new CableLinkComponent());
        //world.addComponent(obs1, new CableLinkComponent());
        world.addComponent(ball1, new CableLinkComponent(pos_ball1.x, pos_ball1.y));
        world.addComponent(ball2, new CableLinkComponent(pos_ball2.x, pos_ball2.y));
        world.addComponent(ball1, new PrevFinalPosComponent(pos_ball1.x, pos_ball1.y));
        world.addComponent(ball2, new PrevFinalPosComponent(pos_ball2.x, pos_ball2.y));

        // Calculate initial points for joint1 (ball2 perimeter hybrid-attachment <-> obs4 rolling)
        const joint1 = world.createEntity();
        // Attach to obstacle at its tangent point
        const tangentObs4 = tangentFromPointToCircle(pos_ball2, pos_obs4, radius_obs4, true);
        const attachObs4 = tangentObs4.a_circle;
        // Attach to ball at closest perimeter point toward obstacle
        const dir1 = attachObs4.clone().subtract(pos_ball2).normalize();
        const attachBall2 = pos_ball2.clone().add(dir1.scale(ballRadius));
        const initialDist1 = attachBall2.clone().subtract(attachObs4).length();
        world.addComponent(joint1, new CableJointComponent(
          ball2, obs4, initialDist1, attachBall2, attachObs4)); // Order matters
        world.addComponent(joint1, new RenderableComponent('line', linecolor1));


        // Calculate initial points for joint2 and beads (obs4 -> obs3 split by two beads)
        const joint2 = world.createEntity();
        const initialPoints2 = tangentFromCircleToCircle(pos_obs4, radius_obs4, true, pos_obs3, radius_obs3, true);
        const dir2 = initialPoints2.b_circle.clone().subtract(initialPoints2.a_circle).normalize();
        const dist2 = initialPoints2.a_circle.clone().subtract(initialPoints2.b_circle).length();
        // Positions for beads
        const bead1Pos = initialPoints2.a_circle.clone().add(dir2, dist2/3.0);
        const bead2Pos = initialPoints2.a_circle.clone().add(dir2, (2*dist2)/3.0);

        // Create bead1
        const bead1 = world.createEntity();
        world.addComponent(bead1, new BallTagComponent());
        world.addComponent(bead1, new PositionComponent(bead1Pos.x, bead1Pos.y));
        world.addComponent(bead1, new CableLinkComponent(bead1Pos.x, bead1Pos.y));
        world.addComponent(bead1, new PrevFinalPosComponent(bead1Pos.x, bead1Pos.y));
        world.addComponent(bead1, new VelocityComponent(0.0, 0.0));
        world.addComponent(bead1, new RadiusComponent(ballRadius));
        world.addComponent(bead1, new MassComponent(ballMass/10.0));
        world.addComponent(bead1, new RestitutionComponent(ballRestitution));
        world.addComponent(bead1, new GravityAffectedComponent());
        world.addComponent(bead1, new RenderableComponent('circle', '#a0a0a0'));
        world.addComponent(bead1, new OrientationComponent(0.0));
        world.addComponent(bead1, new AngularVelocityComponent(0.0));
        world.addComponent(bead1, new MomentOfInertiaComponent(ball1Inertia));

        // Create bead2
        const bead2 = world.createEntity();
        world.addComponent(bead2, new BallTagComponent());
        world.addComponent(bead2, new PositionComponent(bead2Pos.x, bead2Pos.y));
        world.addComponent(bead2, new CableLinkComponent(bead2Pos.x, bead2Pos.y));
        world.addComponent(bead2, new PrevFinalPosComponent(bead2Pos.x, bead2Pos.y));
        world.addComponent(bead2, new VelocityComponent(0.0, 0.0));
        world.addComponent(bead2, new RadiusComponent(ballRadius));
        world.addComponent(bead2, new MassComponent(ballMass/10.0));
        world.addComponent(bead2, new RestitutionComponent(ballRestitution));
        world.addComponent(bead2, new GravityAffectedComponent());
        world.addComponent(bead2, new RenderableComponent('circle', '#a0a0a0'));
        world.addComponent(bead2, new OrientationComponent(0.0));
        world.addComponent(bead2, new AngularVelocityComponent(0.0));
        world.addComponent(bead2, new MomentOfInertiaComponent(ball1Inertia));

        // Create joints: obs4 -> bead1
        world.addComponent(joint2, new CableJointComponent(
          obs4, bead1, dist2/3.0, initialPoints2.a_circle, bead1Pos));
        world.addComponent(joint2, new RenderableComponent('line', linecolor1));

        // bead1 -> bead2
        const joint3 = world.createEntity();
        world.addComponent(joint3, new CableJointComponent(
          bead1, bead2, dist2/3.0, bead1Pos, bead2Pos));
        world.addComponent(joint3, new RenderableComponent('line', linecolor1));

        // bead2 -> obs3
        const joint4 = world.createEntity();
        world.addComponent(joint4, new CableJointComponent(
          bead2, obs3, dist2/3.0, bead2Pos, initialPoints2.b_circle));
        world.addComponent(joint4, new RenderableComponent('line', linecolor1));


        // Calculate initial points for joint4 (obs3 rolling <-> ball1 perimeter attachment)
        const joint5 = world.createEntity();
        // Attach to obstacle at its tangent point
        const tangentObs3 = tangentFromPointToCircle(pos_ball1, pos_obs3, radius_obs3, false);
        const attachObs3 = tangentObs3.a_circle;
        // Attach to ball at closest perimeter point toward obstacle
        const dir3 = attachObs3.clone().subtract(pos_ball1).normalize();
        const attachBall1 = pos_ball1.clone().add(dir3.scale(ballRadius));
        const initialDist3 = attachBall1.clone().subtract(attachObs3).length();
        world.addComponent(joint5, new CableJointComponent(
          obs3, ball1, initialDist3, attachObs3, attachBall1)); // Order matters
        world.addComponent(joint5, new RenderableComponent('line', linecolor1));

        // Create Cable Path Entity
        const cablePath = world.createEntity();
        // CablePathComponent constructor now calculates initial stored length and totalRestLength
        // Use hybrid links at ball attachments to attach at perimeter
        const pathComp = new CablePathComponent(
          world,
          [joint1, joint2, joint3, joint4, joint5],
          ['hybrid-attachment', 'rolling', 'pinhole', 'pinhole', 'rolling', 'hybrid-attachment'],
          [true, true, true, true, true, true],
          20000.0 // Spring constant (rough approximation) for Garda 1.1 mm line (unit N/m).
        );
        world.addComponent(cablePath, pathComp);


        // --- Systems Registration (Order Matters!) ---
        if (world.systems.length === 0) { // Only register systems once
             world.registerSystem(new PrevFinalPosSystem());
             const inputSystemInstance = new InputSystem(canvas);
             world.registerSystem(inputSystemInstance);
             world.registerSystem(new InputReplaySystem(
               [],
             inputSystemInstance));
             world.registerSystem(new FlipperMotionSystem()); // Handles flipper input -> state change
             world.registerSystem(new GravitySystem());      // Applies gravity acceleration
             world.registerSystem(new MovementSystem());     // Updates position based on velocity
             world.registerSystem(new AngularMovementSystem()); // Updates angle based on angular velocity
             world.registerSystem(new PBDBallBallCollisions());
             world.registerSystem(new PBDBallObstacleCollisions2());
             world.registerSystem(new PBDBallFlipperCollisions());
             world.registerSystem(new FlipperTipLinkSystem());
             world.registerSystem(new PBDBallBorderCollisions());
             world.registerSystem(new CableAttachmentUpdateSystemPathWise());
             world.registerSystem(new PBDCableConstraintSolverPathWise());
             world.registerSystem(new ScoreSystem());
             world.registerSystem(new ScoreDisplaySystem('score'));
             world.registerSystem(new RenderSystem(canvas, cScale, simHeight, 1.0, 0.5, 0.85, 1.00));
        } else {
          world.systems[InputSystem]
        }

        // Update button text based on initial pause state
         const pauseState = world.getResource('pauseState');
         pauseBtn.textContent = pauseState.paused ? "Start" : "Pause";
    }


    // --- Main Loop ---
    let lastTime = 0;           // in ms
    let accumulator = 0.0;      // in seconds
    let doStep = true; // Whether to do a single step when paused

    function gameLoop(currentTime) {
      const dt = world.getResource('dt');           // e.g. 1/150
      const pauseState = world.getResource('pauseState');

      // first frame init
      if (lastTime === 0) {
        lastTime = currentTime;
      }
      const speedScale = window._flipperSpeedScale ?? 0.6;
      let frameSec = speedScale*(currentTime - lastTime) / 1000;
      if (frameSec >= dt) {
        lastTime = currentTime;
        // optional clamp to avoid spiral‑of‑death if caller hitches
        const maxAccum = dt * 5;
        accumulator = Math.min(accumulator + frameSec, maxAccum);
        // consume as many fixed‐dt steps as we can
        while (accumulator >= dt) {
          if (!pauseState.paused || doStep) {
            if (doStep) pauseState.paused = false;
            world.update(dt);
            if (doStep) {
              pauseState.paused = true;
              doStep = false;
            }
          }
          accumulator -= dt;
        }
      }

      // schedule next frame
      requestAnimationFrame(gameLoop);
    }

    // kick it off
    requestAnimationFrame(gameLoop);

    // --- Event Listeners ---
    pauseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const pauseState = world.getResource('pauseState');
        if (pauseState) {
            pauseState.paused = !pauseState.paused;
            pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
        }
    });

    resetBtn.addEventListener('click', (e) => {
        e.preventDefault();
        setupScene(); // Re-initialize the world state
        // Ensure pause state resource is reset if needed
        const pauseState = world.getResource('pauseState');
        if (pauseState) pauseState.paused = true; // Start paused after reset
        pauseBtn.textContent = "Resume";
        doStep = true;
    });

    stepBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const pauseState = world.getResource('pauseState');
        if (pauseState && pauseState.paused) {
            doStep = true;
        }
    });
    const dumpBtn = document.getElementById('dumpBtn');
    dumpBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log(dumpWorldState(world));
    });

    // --- Start ---
    setupScene();
    requestAnimationFrame(gameLoop);

</script>

</body>
</html>
