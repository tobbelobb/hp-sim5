<!DOCTYPE html>
<html>
<head>
    <title>Cable Joints</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202020; font-family: sans-serif; }
        canvas { border: 1px solid black; display: block; margin: 10px auto; }
        #controls { text-align: center; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div id="controls">
        Score: <span id="score">0</span> |
        <button id="pauseBtn" tabindex="-1">Pause</button>
        <button id="resetBtn" tabindex="-1">Reset</button>
        <button id="stepBtn">Step</button>
    </div>
    <canvas id="myCanvas"></canvas>

<script>

  // --- Utility: Vector2 ---
  class Vector2 {
    constructor(x = 0.0, y = 0.0) { this.x = x; this.y = y; }
    set(v) { this.x = v.x; this.y = v.y; }
    clone() { return new Vector2(this.x, this.y); }
    add(v, s = 1.0) { this.x += v.x * s; this.y += v.y * s; return this; }
    addVectors(a, b) { this.x = a.x + b.x; this.y = a.y + b.y; return this; }
    subtract(v, s = 1.0) { this.x -= v.x * s; this.y -= v.y * s; return this; }
    subtractVectors(a, b) { this.x = a.x - b.x; this.y = a.y - b.y; return this; }
    distanceTo(b) { return Math.sqrt((this.x - b.x)*(this.x - b.x) + (this.y - b.y)*(this.y - b.y)); }
    length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    lengthSq() { return this.x * this.x + this.y * this.y; } // Optimization
    scale(s) { this.x *= s; this.y *= s; return this; }
    dot(v) { return this.x * v.x + this.y * v.y; }
    perp() { return new Vector2(-this.y, this.x); }
    normalize() { const l = this.length(); if (l > 0) this.scale(1.0 / l); return this; }
  }

  // --- Utility: Geometry ---
  function closestPointOnSegment(p, a, b) {
    const ab = new Vector2().subtractVectors(b, a);
    const ap = new Vector2().subtractVectors(p, a);
    let t = ap.dot(ab);
    if (t <= 0.0) return a.clone();
    const denom = ab.dot(ab);
    if (t >= denom) return b.clone();
    t = t / denom;
    return a.clone().add(ab, t);
  }

  // Helper: Calculate tangent points between a point and a circle (Algorithm 3 from Cable Joints paper)
  function _tangentPointCircle(p_attach, p_circle, r_circle, cw, pointIsFirst) {
    const dVec = new Vector2().subtractVectors(p_circle, p_attach);
    const dSq = dVec.lengthSq();

    if (dSq <= r_circle * r_circle + 1e-9) {
      console.warn("Cable tangent calculation: Attachment point inside or on rolling circle.");
      const dir = dVec.lengthSq() > 1e-9 ? dVec.clone().normalize() : new Vector2(1, 0);
      return {
        a_attach: p_attach.clone(),
        a_circle: p_circle.clone().add(dir, r_circle)
      };
    }

    const d = Math.sqrt(dSq);
    const alpha = Math.atan2(dVec.y, dVec.x);
    const phi = Math.asin(r_circle / d);

    let tangent_point_angle_on_circle;
    if ((cw && pointIsFirst) || (!cw && !pointIsFirst)) {
      tangent_point_angle_on_circle = alpha + phi + Math.PI/2;
    } else {
      tangent_point_angle_on_circle = alpha - phi - Math.PI/2;
    }

    const a_circle = new Vector2(
      p_circle.x + r_circle * Math.cos(tangent_point_angle_on_circle),
      p_circle.y + r_circle * Math.sin(tangent_point_angle_on_circle)
    );

    return {
      a_attach: p_attach.clone(), // Attachment point doesn't change
      a_circle: a_circle          // Calculated tangent point on the circle
    };
  }

  function tangentFromPointToCircle(p_attach, p_circle, r_circle, cw) {
    return _tangentPointCircle(p_attach, p_circle, r_circle, cw, true);
  }

  function tangentFromCircleToPoint(p_attach, p_circle, r_circle, cw) {
    return _tangentPointCircle(p_attach, p_circle, r_circle, cw, false);
  }


  function tangentFromCircleToCircle(posA, radiusA, cwA, posB, radiusB, cwB) {
    const dVec = new Vector2().subtractVectors(posB, posA);
    const dSq = dVec.lengthSq();
    const d = Math.sqrt(dSq);

    let r = (cwA === cwB) ? (radiusB - radiusA) : (radiusA + radiusB);
    if (d <= Math.abs(r)) {
      console.warn("Cable tangent calculation: Circles are overlapping or too close.");
      return null;
    }

    const alpha = Math.atan2(dVec.y, dVec.x);
    const phi = Math.asin(r / d);

    let angleA, angleB;
    if (!cwA === cwB) {
      if (!cwA) {
        angleA = alpha - Math.PI / 2 - phi;
        angleB = alpha - Math.PI / 2 - phi;
      } else {
        angleA = alpha + Math.PI / 2 + phi;
        angleB = alpha + Math.PI / 2 + phi;
      }
    } else {
      if (!cwA) {
        angleA = alpha - Math.PI / 2 + phi;
        angleB = alpha - Math.PI / 2 - phi;
      } else {
        angleA = alpha + Math.PI / 2 - phi;
        angleB = alpha + Math.PI / 2 + phi;
      }
    }

    const tangentA = new Vector2(
      posA.x + radiusA * Math.cos(angleA),
      posA.y + radiusA * Math.sin(angleA)
    );
    const tangentB = new Vector2(
      posB.x + radiusB * Math.cos(angleB),
      posB.y + radiusB * Math.sin(angleB)
    );

    return {
      a_circle: tangentA,
      b_circle: tangentB
    };
  }




  /**
   * Calculates signed arc length between two world-space points on the circumference of a wheel.
   *
   * @param {Vector2} prevPoint - Previous attachment point on the wheel (world-space)
   * @param {Vector2} currPoint - Current attachment point on the wheel (world-space)
   * @param {Vector2} center - Center of the wheel (world-space)
   * @param {number} radius - Radius of the wheel
   * @param {boolean} clockwisePreference - If true, positive arc length means CW, else CCW
   * @returns {number} Signed arc length (positive = preferred direction)
   */
  function signedArcLengthOnWheel(prevPoint, currPoint, center, radius, clockwisePreference) {
    const toPrev = new Vector2().subtractVectors(prevPoint, center);
    const toCurr = new Vector2().subtractVectors(currPoint, center);

    // Get angle between the two vectors (signed)
    let angle = Math.atan2(toCurr.y, toCurr.x) - Math.atan2(toPrev.y, toPrev.x);

    // Normalize angle to range [-π, π]
    if (angle > Math.PI) angle -= 2 * Math.PI;
    if (angle < -Math.PI) angle += 2 * Math.PI;

    // If wheel is clockwise, positive angle should represent CW → flip sign
    if (clockwisePreference) {
      angle *= -1;
    }

    // Arc length = radius * angle (signed)
    return radius * angle;
  }

  /**
   * Checks if a line segment intersects a circle.
   * @param {Vector2} p1 - Start point of the segment
   * @param {Vector2} p2 - End point of the segment
   * @param {Vector2} center - Center of the circle
   * @param {number} radius - Radius of the circle
   * @returns {boolean} True if the segment intersects the circle, false otherwise.
   */
  function lineSegmentCircleIntersection(p1, p2, center, radius) {
    // 1. Check if either endpoint is inside the circle
    if (p1.distanceTo(center) <= radius || p2.distanceTo(center) <= radius) {
      return true;
    }

    // 2. Check if the projection of the center onto the line lies within the segment
    const d = new Vector2().subtractVectors(p2, p1);
    const lc = new Vector2().subtractVectors(center, p1);
    const dLengthSq = d.lengthSq();

    // Project center onto the line containing the segment
    let t = lc.dot(d);
    if (dLengthSq > 1e-9) { // Avoid division by zero for zero-length segment
        t /= dLengthSq;
    }

    if (t < 0.0) {
      return false; // Closest point is p1
    } else if (t > 1.0) {
      return false; // Closest point is p2
    }

    const closestPointOnLine = p1.clone().add(d, t);

    // 3. Check if the closest point on the segment is within the circle's radius
    return closestPointOnLine.distanceTo(center) <= radius;
  }


  // --- ECS Core ---
  class World {
    constructor() {
      this.entities = new Map(); // entityId -> Set<ComponentClass>
      this.components = new Map(); // ComponentClass -> Map<entityId, ComponentInstance>
      this.nextEntityId = 0;
      this.systems = [];
      this.resources = {}; // Global data like gravity, dt
    }

    createEntity() {
      const id = this.nextEntityId++;
      this.entities.set(id, new Set());
      return id;
    }

    addComponent(entityId, component) {
      const componentClass = component.constructor;
      if (!this.components.has(componentClass)) {
        this.components.set(componentClass, new Map());
      }
      this.components.get(componentClass).set(entityId, component);
      if (this.entities.has(entityId)) {
        this.entities.get(entityId).add(componentClass);
      } else {
        console.warn(`Entity ${entityId} does not exist when adding ${componentClass.name}`);
      }
    }

    getComponent(entityId, componentClass) {
      const componentMap = this.components.get(componentClass);
      return componentMap ? componentMap.get(entityId) : undefined;
    }

    hasComponent(entityId, componentClass) {
      const componentMap = this.components.get(componentClass);
      return componentMap ? componentMap.has(entityId) : false;
    }

    removeComponent(entityId, componentClass) {
      const componentMap = this.components.get(componentClass);
      if (componentMap) {
        componentMap.delete(entityId);
      }
      const entityComponents = this.entities.get(entityId);
      if (entityComponents) {
        entityComponents.delete(componentClass);
      }
    }

    destroyEntity(entityId) {
      if (!this.entities.has(entityId)) return;
      for (const componentClass of this.entities.get(entityId)) {
        this.removeComponent(entityId, componentClass);
      }
      this.entities.delete(entityId);
    }

    query(componentClasses) {
      const entities = [];
      if (componentClasses.length === 0) return [];

      // Start with entities having the first component
      const firstComponentMap = this.components.get(componentClasses[0]);
      if (!firstComponentMap) return [];

      for (const entityId of firstComponentMap.keys()) {
        let hasAll = true;
        for (let i = 1; i < componentClasses.length; i++) {
          if (!this.hasComponent(entityId, componentClasses[i])) {
            hasAll = false;
            break;
          }
        }
        if (hasAll) {
          entities.push(entityId);
        }
      }
      return entities;
    }

    registerSystem(system) {
      this.systems.push(system);
    }

    setResource(name, value) {
      this.resources[name] = value;
    }

    getResource(name) {
      return this.resources[name];
    }

    clear() {
      this.entities.clear();
      this.components.clear();
      this.nextEntityId = 0;
      // Keep systems and resources
    }

    update(dt) {
      const pauseState = this.getResource('pauseState');
      const isPaused = pauseState ? pauseState.paused : false;

      for (const system of this.systems) {
        if (system.update && (!system.runInPause && isPaused)) {
          continue; // Skip non-pause systems if paused
        }
        if (system.update) {
          system.update(this, dt);
        }
      }
      canvas.focus();
    }
  }

  // --- Components (Plain Data) ---

  class PositionComponent { constructor(x = 0, y = 0) { this.pos = new Vector2(x, y); } }
  class VelocityComponent { constructor(x = 0, y = 0) { this.vel = new Vector2(x, y); } }
  class RadiusComponent { constructor(radius = 0.1) { this.radius = radius; } }
  class MassComponent { constructor(mass = 1.0) { this.mass = mass; } }
  class RestitutionComponent { constructor(restitution = 0.5) { this.restitution = restitution; } }
  class GravityAffectedComponent { /* Tag component */ }
  class BallTagComponent { /* Tag component */ }
  class ObstacleTagComponent { /* Tag component */ }
  class PauseStateComponent { constructor(paused = true) { this.paused = paused; } }
  class CableLinkComponent { constructor(x = 0, y = 0) { this.prevPos = new Vector2(x, y); } }

  // Represents a single segment constraint between two entities
  class CableJointComponent {
    constructor(entityA, entityB, restLength, attachmentPointA_world, attachmentPointB_world) {
      this.entityA = entityA;
      this.entityB = entityB;
      this.restLength = restLength; // dn - the dynamic maximum length
      this.isActive = true; // For merge/split logic
      this.attachmentPointA_world = attachmentPointA_world.clone();
      this.attachmentPointB_world = attachmentPointB_world.clone();
    }
  }

  // Represents the entire cable path
  class CablePathComponent {
    constructor(jointEntities = [], linkTypes = [], cw = []) {
      this.totalRestLength = 0.0;
      this.jointEntities = jointEntities; // Ordered list of CableJoint entity IDs
      this.linkTypes = linkTypes; // Ordered. linkTypes.length === jointEntities.length + 1
      this.cw = cw // Ordered. cw.length === linkTypes.length
      this.stored = new Array(cw.length).fill(0.0); // Ordered. stored.length === cw.length
      for (const jointId of jointEntities) {
        const joint = world.getComponent(jointId, CableJointComponent);
        this.totalRestLength += joint.restLength;
      }
      for (let i = 0; i < jointEntities.length - 1; i++) { // Iterate over adjacent pairs
        const jointId_i = jointEntities[i];
        const jointId_i_plus_1 = jointEntities[i + 1];
        const joint_i = world.getComponent(jointId_i, CableJointComponent);
        const joint_i_plus_1 = world.getComponent(jointId_i_plus_1, CableJointComponent);
        const linkId = joint_i.entityB;
        const linkId2 = joint_i_plus_1.entityA;
        if (linkId !== linkId2) {
          console.warn("Links don't match up. There's something wrong with this cable path.");
          return;
        }
        const isRolling = linkTypes[i + 1] === 'rolling';
        // Assuming standard path structure A->B, A->B, check B_i == A_i+1
        if (isRolling) {
          const rolling_link = world.getComponent(linkId, CableLinkComponent);
          const center = world.getComponent(linkId, PositionComponent).pos;
          const radius = world.getComponent(linkId, RadiusComponent).radius;
          const isCw = cw[i + 1];

          const initialStoredLength = signedArcLengthOnWheel(
              joint_i.attachmentPointB_world,
              joint_i_plus_1.attachmentPointA_world,
              center,
              radius,
              isCw
          );
          this.stored[i + 1] = initialStoredLength;
          this.totalRestLength += initialStoredLength;
        }
      }
    }
  }


  // Render-specific component (could be more complex)
  class RenderableComponent {
    constructor(shape = 'circle', color = '#888888') {
      this.shape = shape; // 'circle', 'flipper', 'border'
      this.color = color;
    }
  }

  // --- Systems (Logic) ---

  // --- System: Gravity ---
  class GravitySystem {
    runInPause = false;
    update(world, dt) {
      const gravity = world.getResource('gravity');
      if (!gravity) return;

      const entities = world.query([VelocityComponent, GravityAffectedComponent]);
      for (const entityId of entities) {
        const velComp = world.getComponent(entityId, VelocityComponent);
        velComp.vel.add(gravity, dt);
      }
    }
  }

  // --- System: Movement ---
  class MovementSystem {
    runInPause = false;
    update(world, dt) {
      // Update linear position
      const linearEntities = world.query([PositionComponent, VelocityComponent]);
      for (const entityId of linearEntities) {
        const posComp = world.getComponent(entityId, PositionComponent);
        const velComp = world.getComponent(entityId, VelocityComponent);
        posComp.pos.add(velComp.vel, dt);
      }
    }
  }


  // --- System: Cable Attachment Update ---
  // Calculates tangent points and updates rest lengths (dn) BEFORE the main solver
  class CableAttachmentUpdateSystem {
    runInPause = false; // Physics system

    update(world, dt) {
      const debugPoints = world.getResource('debugRenderPoints');
      // Clear points from the previous frame
      for (const key in debugPoints) {
          delete debugPoints[key];
      }
      const pathEntities = world.query([CablePathComponent]);
      //// Merge joints
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path || path.jointEntities.length < 2) continue;
        const jointsInPath = path.jointEntities;
        for (let i = 0; i < path.jointEntities.length - 1; i++) { // Iterate over adjacent pairs
          const jointId_i = path.jointEntities[i];
          const jointId_i_plus_1 = path.jointEntities[i + 1];
          const joint_i = world.getComponent(jointId_i, CableJointComponent);
          const joint_i_plus_1 = world.getComponent(jointId_i_plus_1, CableJointComponent);
          const linkId = joint_i.entityB;
          const linkId2 = joint_i_plus_1.entityA;
          if (linkId !== linkId2) {
            log.warn("Merge loop saw disconnected cable path");
          }
          //console.log(`was stored: ${path.stored[i+1]}`);
          const isRolling = path.linkTypes[i + 1] === 'rolling';
          if (isRolling) {
            if (path.stored[i + 1] < 0.0) {
              console.log(`Merging joints ${jointId_i} and ${jointId_i_plus_1}.`);
              const posA = world.getComponent(joint_i.entityA, PositionComponent).pos;
              const radiusA = world.getComponent(joint_i.entityA, RadiusComponent)?.radius;
              const cwA = path.cw[i];
              const posB = world.getComponent(joint_i_plus_1.entityB, PositionComponent).pos;
              const radiusB = world.getComponent(joint_i_plus_1.entityB, RadiusComponent)?.radius;
              const cwB = path.cw[i+2];
              joint_i.restLength += joint_i_plus_1.restLength + path.stored[i + 1];
              joint_i.entityB = joint_i_plus_1.entityB;
              const isRollingA = path.linkTypes[i] === 'rolling';
              const isAttachmentA = path.linkTypes[i] === 'attachment';
              const isRollingB = path.linkTypes[i+2] === 'rolling';
              const isAttachmentB = path.linkTypes[i+2] === 'attachment';
              if (isRollingA && isRollingB) {
                const tangents = tangentFromCircleToCircle(posA, radiusA, cwA, posB, radiusB, cwB);
                const sA = signedArcLengthOnWheel(joint_i.attachmentPointA_world, tangents.a_circle, posA, radiusA, cwA);
                path.stored[i] += sA;
                joint.restLength -= sA;
                const sB = signedArcLengthOnWheel(joint_i_plus_1.attachmentPointB_world, tangents.b_circle, posB, radiusB, cwB);
                path.stored[i+2] -= sB;
                joint.restLength += sB;
                joint_i.attachmentPointA_world = tangents.a_circle;
                joint_i.attachmentPointB_world = tangents.b_circle;
              } else if (isRollingA && isAttachmentB) {
                const tangents = tangentFromCircleToPoint(posB, posA, radiusA, cwA);
                const sA = signedArcLengthOnWheel(joint_1.attachmentPointA_world, tangents.a_circle, posA, radiusA, cwA);
                path.stored[i] += sA;
                joint_i.restLength -= sA;
                joint_i.attachmentPointA_world = tangents.a_circle;
                joint_i.attachmentPointB_world = tangents.a_attach;
              } else if (isAttachmentA && isRollingB) {
                const tangents = tangentFromCircleToPoint(posA, posB, radiusB, cwB);
                const sB = signedArcLengthOnWheel(joint_i_plus_1.attachmentPointB_world, tangents.a_circle, posB, radiusB, cwB);
                path.stored[i+2] -= sB;
                joint_i.restLength += sB;
                //console.log(`sB merge: updated path.stored[${i+2}] by ${-sB}`);
                joint_i.attachmentPointA_world = tangents.a_attach;
                joint_i.attachmentPointB_world = tangents.a_circle;
              } else {
                joint_i.attachmentPointA_world = posA;
                joint_i.attachmentPointB_world = posB;
              }

              path.jointEntities.splice(i+1, 1);
              path.stored.splice(i+1, 1);
              path.cw.splice(i+1, 1);
              path.linkTypes.splice(i+1, 1);
              joint_i_plus_1.isActive = false;
              world.destroyEntity(jointId_i_plus_1);
            }
          }
        }
        //console.log(`path.stored up here: ${path.stored}`);
      }

      // -- New attachment points --
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        for (var jointIdx = 0; jointIdx < path.jointEntities.length; jointIdx++) {
          const jointId = path.jointEntities[jointIdx];
          const joint = world.getComponent(jointId, CableJointComponent);
          if (!joint.isActive) continue;
          const A = jointIdx;
          const B = jointIdx + 1;

          const entityA = joint.entityA;
          const entityB = joint.entityB;

          // Get components for Entity A
          const posA = world.getComponent(entityA, PositionComponent)?.pos;
          const radiusA = world.getComponent(entityA, RadiusComponent)?.radius;
          const cwA = path.cw[A];
          const attachmentLinkA = path.linkTypes[A] === 'attachment';
          const rollingLinkA = path.linkTypes[A] === 'rolling';
          const linkA = world.getComponent(entityA, CableLinkComponent);

          // Get components for Entity B
          const posB = world.getComponent(entityB, PositionComponent)?.pos;
          const velB = world.getComponent(entityB, VelocityComponent)?.vel;
          const radiusB = world.getComponent(entityB, RadiusComponent)?.radius;
          const cwB = path.cw[B];
          const attachmentLinkB = path.linkTypes[B] === 'attachment';
          const rollingLinkB = path.linkTypes[B] === 'rolling';
          const linkB = world.getComponent(entityB, CableLinkComponent);

          if (!posA || !linkA || !posB || !linkB) {
            console.warn(`CableJoint ${jointId} missing required components on entities ${entityA} or ${entityB}`);
            continue;
          }

          let attachmentA_current, attachmentB_current;

          // --- Calculate Current Attachment Points ---
          if (attachmentLinkA && rollingLinkB && radiusB) {
            const tangents = tangentFromPointToCircle(posA, posB, radiusB, cwB);
            debugPoints[`posA`] = { pos: posA.clone(), color: '#000000' };// black
            debugPoints[`posB`] = { pos: posB.clone(), color: '#FFFFFF' };// white
            attachmentA_current = tangents.a_attach; // This is just posA
            attachmentB_current = tangents.a_circle; // Tangent on circle B
            const sB = signedArcLengthOnWheel(joint.attachmentPointB_world, attachmentB_current, posB, radiusB, cwB);
            path.stored[B] -= sB;
            joint.restLength += sB;
            if (path.stored.length === 4 && B === 1) {
              //console.log(joint.attachmentPointB_world);
              //console.log(attachmentB_current);
              debugPoints[`joint_${jointId}_prevB`] =
                { pos: joint.attachmentPointB_world.clone(), color: '#FF00FF' };// Magenta
              debugPoints[`joint_${jointId}_currB`] =
                { pos: attachmentB_current.clone(), color: '#00FFFF' }; // Cyan
              console.log(joint.attachmentPointB_world.clone().subtract(attachmentB_current).length());
              console.log(`sB: updated path.stored[${B}] by ${-sB}. cwB was ${cwB}.`);
            }
          } else if (rollingLinkA && attachmentLinkB && radiusA) {
            const tangents = tangentFromCircleToPoint(posB, posA, radiusA, cwA);
            attachmentA_current = tangents.a_circle; // Tangent on circle A
            attachmentB_current = tangents.a_attach; // This is just posB
            const sA = signedArcLengthOnWheel(joint.attachmentPointA_world, attachmentA_current, posA, radiusA, cwA);
            path.stored[A] += sA;
            joint.restLength -= sA;
            if (path.stored.length === 4 && A === 1)
              console.log(`sA: updated path.stored[${A}] by ${-sA}`);
          } else if (rollingLinkA && rollingLinkB) {
            const tangents = tangentFromCircleToCircle(posA, radiusA, cwA, posB, radiusB, cwB);
            attachmentA_current = tangents.a_circle;
            attachmentB_current = tangents.b_circle;
            const sA = signedArcLengthOnWheel(joint.attachmentPointA_world, attachmentA_current, posA, radiusA, cwA);
            path.stored[A] += sA;
            joint.restLength -= sA;
            const sB = signedArcLengthOnWheel(joint.attachmentPointB_world, attachmentB_current, posB, radiusB, cwB);
            path.stored[B] -= sB;
            joint.restLength += sB;
            if (path.stored.length === 4 && (A === 1 || B === 1))
              console.log(`sA and sB: updated path.stored[${B}] by ${-sB} and path.stored[${A}] by ${sA}`);
          } else {
            attachmentA_current = posA.clone();
            attachmentB_current = posB.clone();
          }

          // Ensure rest length doesn't go negative
          if (joint.restLength < 0) joint.restLength = 0;

          joint.attachmentPointA_world.set(attachmentA_current);
          joint.attachmentPointB_world.set(attachmentB_current);
        }
      }

      // Split joints
      // Entities that can cause a split
      const potentialSplitters = world.query([PositionComponent, RadiusComponent, CableLinkComponent]);
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path || path.jointEntities.length < 1) continue;
        for (var jointIndex = 0; jointIndex < path.jointEntities.length; jointIndex++) {
          const jointId = path.jointEntities[jointIndex];
          const joint = world.getComponent(jointId, CableJointComponent);
          if (!joint.isActive) {
            console.warn("An inactive joint seems to be part of a path right now.");
            continue;
          }
          const pA = joint.attachmentPointA_world;
          const pB = joint.attachmentPointB_world;
          for (const splitterId of potentialSplitters) {
            if (splitterId === joint.entityA || splitterId === joint.entityB) {
              continue;
            }
            const posSplitter = world.getComponent(splitterId, PositionComponent).pos;
            const radiusSplitter = world.getComponent(splitterId, RadiusComponent).radius;
            if (lineSegmentCircleIntersection(pA, pB, posSplitter, radiusSplitter)) {
              console.log(`Splitting joint ${jointId} due to intersection with ${splitterId}`);
              const newJointId = world.createEntity();

              //console.log(path.stored);
              const cw = true;
              const linkTypeB = path.linkTypes[jointIndex + 1];
              const entityB = joint.entityB;
              const entityA = joint.entityA;
              var initialPoints;
              var initialDist1;
              var attachmentPointAForNewJoint;
              var attachmentPointBForNewJoint;
              const posB = world.getComponent(entityB, PositionComponent).pos;
              if (linkTypeB === 'rolling') {
                const radiusB = world.getComponent(entityB, RadiusComponent).radius;
                const cwB = path.cw[jointIndex + 1];
                initialPoints = tangentFromCircleToCircle(posSplitter, radiusSplitter, cw, posB, radiusB, cwB);
                initialDist1 = initialPoints.a_circle.clone().subtract(initialPoints.b_circle).length();
                attachmentPointAForNewJoint = initialPoints.a_circle;
                attachmentPointBForNewJoint = initialPoints.b_circle;
                const sB = signedArcLengthOnWheel(pB, attachmentPointBForNewJoint, posB, radiusB, cwB);
                path.stored[jointIndex + 1] -= sB;
                joint.restLength += sB;
                //console.log(`split increased restLength (sB) by ${sB}`)
              } else if (linkTypeB === 'attachment') {
                initialPoints = tangentFromCircleToPoint(posB, posSplitter, radiusSplitter, cw);
                initialDist1 = initialPoints.a_attach.clone().subtract(initialPoints.a_circle).length();
                attachmentPointAForNewJoint = initialPoints.a_circle;
                attachmentPointBForNewJoint = initialPoints.a_attach;
              } else {
                console.warn(`Splitting cable joint attached to ${linkTypeB} is not supported.`);
              }

              path.jointEntities.splice(jointIndex + 1, 0, newJointId);
              path.cw.splice(jointIndex + 1, 0, cw);
              path.linkTypes.splice(jointIndex + 1, 0, 'rolling');

              const linkTypeA = path.linkTypes[jointIndex];
              const posA = world.getComponent(entityA, PositionComponent).pos;
              var newAttachmentPointBForJoint;
              var newAttachmentPointAForJoint;
              var initialPoints2;
              var initialDist2;
              if (linkTypeA === 'rolling') {
                const radiusA = world.getComponent(entityA, RadiusComponent).radius;
                const cwA = path.cw[jointIndex];
                initialPoints2 = tangentFromCircleToCircle(posA, radiusA, cwA, posSplitter, radiusSplitter, cw);
                initialDist2 = initialPoints2.a_circle.clone().subtract(initialPoints2.b_circle).length();
                newAttachmentPointAForJoint = initialPoints.a_circle;
                const sA = signedArcLengthOnWheel(joint.attachmentPointA_world, newAttachmentPointAForJoint, posA, radiusA, cwA);
                joint.attachmentPointA_world.set(newAttachmentPointAForJoint);
                path.stored[jointIndex] += sA;
                joint.restLength -= sA;
                //console.log(`split increased restLength (-sA) by ${-sA}`)
                newAttachmentPointBForJoint = initialPoints.b_circle;
                console.log("New attachment A changes stored by: ", sA);
              } else if (linkTypeA === 'attachment') {
                initialPoints2 = tangentFromPointToCircle(pA, posSplitter, radiusSplitter, cw);
                initialDist2 = initialPoints2.a_circle.clone().subtract(initialPoints2.a_attach).length();
                newAttachmentPointBForJoint = initialPoints2.a_circle;
              } else {
                console.warn(`Splitting cable joint attached to ${linkTypeA} is not supported.`);
              }
              joint.entityB = splitterId;
              const s = signedArcLengthOnWheel(
                  newAttachmentPointBForJoint,
                  attachmentPointAForNewJoint,
                  posSplitter,
                  radiusSplitter,
                  cw
              );
              // The line is slightly stretched due to the intersection with the new link (the splitterId Entity).
              // Distributes the discrepancy (length_error) to both sides of the new link such that tension remains constant on both sides of the new link.
              // The paper states:
              // "The rest length of the original joint is distributed among the new joints such that the tension on both sides are equal."
              // "The rest length is split such that the tension remains constant."
              // "tension (the current length divided by the rest length)"
              const length_error = initialDist2 - (joint.restLength - initialDist1 - s);
              joint.restLength = initialDist2 - length_error*initialDist2/(initialDist1+initialDist2);
              //console.log(`New joint.restLength down here is ${joint.restLength}`);
              world.addComponent(newJointId, new CableJointComponent(
                splitterId, entityB, initialDist1 - length_error*initialDist1/(initialDist1+initialDist2), attachmentPointAForNewJoint, attachmentPointBForNewJoint));
              world.addComponent(newJointId, new RenderableComponent('line', '#0000FF'));
              //console.log("s is this: ", s);
              joint.attachmentPointB_world.set(newAttachmentPointBForJoint);
              path.stored.splice(jointIndex + 1, 0, s);

              //console.log(path.stored);
            }
          }
        }
      }

      const linkEntities = world.query([CableLinkComponent, PositionComponent]);
      for (const link of linkEntities) {
        world.getComponent(link, CableLinkComponent).prevPos = world.getComponent(link, PositionComponent).pos;
      }

      // Debugging/test loop 1
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path || path.jointEntities.length < 1) continue;
        var totalCurrentDist = 0.0;
        var totalCurrentRestLength = 0.0;
        for (var jointIdx = 0; jointIdx < path.jointEntities.length; jointIdx++) {
          const jointId = path.jointEntities[jointIdx];
          const joint = world.getComponent(jointId, CableJointComponent);

          // Ensure joint exist and is active
          if (!joint || !joint.isActive) continue;

          // Calculate current lengths using the attachment points updated in Pass A
          const currentDist = joint.attachmentPointA_world.distanceTo(joint.attachmentPointB_world);
          totalCurrentDist += currentDist + path.stored[jointIdx + 1];
          totalCurrentRestLength += joint.restLength + path.stored[jointIdx + 1];
        }

        const error = path.totalRestLength - totalCurrentRestLength;
        //console.log(`error path ${pathId}: ${error}`); // rest length error is and should be very close to zero
        //console.log(`stored: ${path.stored}`);
      }
    }
  }

  class PBDBallBallCollisions {
    runInPause = false;
    update(world, dt) {
      const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
      for (let i = 0; i < ballEntities.length; i++) {
        for (let j = i + 1; j < ballEntities.length; j++) {
          const e1 = ballEntities[i];
          const e2 = ballEntities[j];
          // TODO: When a ball moves, the joint.attachmentPointA_world and joint.attachmentPointB_world connected
          // to it must also move by the same amount
          //e1_jointAs = [];
          //e1_jointBs = [];
          //e2_jointAs = [];
          //e2_jointBs = [];
          //for (const jointId in world.query([CableJointComponent])) {
          //  const joint = world.getComponent(jointId, CableJointComponent);
          //  if (joint.entityA === e1) {
          //    e1_jointAs.push(jointId);
          //  }
          //  if (joint.entityB === e1) {
          //    e1_jointBs.push(jointId);
          //  }
          //  if (joint.entityA === e2) {
          //    e1_jointAs.push(jointId);
          //  }
          //  if (joint.entityB === e2) {
          //    e1_jointBs.push(jointId);
          //  }
          //}

          const p1 = world.getComponent(e1, PositionComponent).pos;
          const v1 = world.getComponent(e1, VelocityComponent).vel;
          const r1 = world.getComponent(e1, RadiusComponent).radius;
          const m1 = world.getComponent(e1, MassComponent).mass;
          const res1 = world.getComponent(e1, RestitutionComponent).restitution;

          const p2 = world.getComponent(e2, PositionComponent).pos;
          const v2 = world.getComponent(e2, VelocityComponent).vel;
          const r2 = world.getComponent(e2, RadiusComponent).radius;
          const m2 = world.getComponent(e2, MassComponent).mass;
          const res2 = world.getComponent(e2, RestitutionComponent).restitution;

          const restitution = Math.min(res1, res2);
          const dir = new Vector2().subtractVectors(p2, p1);
          const dSq = dir.lengthSq();
          const rSum = r1 + r2;

          if (dSq == 0.0 || dSq > rSum * rSum) continue;

          const d = Math.sqrt(dSq);
          dir.scale(1.0 / d); // Normalize

          // Resolve penetration
          const corr = (rSum - d) / 2.0;
          p1.add(dir, -corr);
          p2.add(dir, corr);

          // Resolve velocity
          const vel1_dot = v1.dot(dir);
          const vel2_dot = v2.dot(dir);

          const newV1_dot = (m1 * vel1_dot + m2 * vel2_dot - m2 * (vel1_dot - vel2_dot) * restitution) / (m1 + m2);
          const newV2_dot = (m1 * vel1_dot + m2 * vel2_dot - m1 * (vel2_dot - vel1_dot) * restitution) / (m1 + m2);

          v1.add(dir, newV1_dot - vel1_dot);
          v2.add(dir, newV2_dot - vel2_dot);
        }
      }
    }
  }

  class PBDBallObstacleCollisions {
    runInPause = false;

    update(world, dt) {
      const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
      const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent]);
      for (const ballId of ballEntities) {
        const p1 = world.getComponent(ballId, PositionComponent).pos;
        const v1 = world.getComponent(ballId, VelocityComponent).vel;
        const r1 = world.getComponent(ballId, RadiusComponent).radius;

        for (const obsId of obstacleEntities) {
          const p2 = world.getComponent(obsId, PositionComponent).pos;
          const r2 = world.getComponent(obsId, RadiusComponent).radius;
          const pushVel = 2.0;

          const dir = new Vector2().subtractVectors(p1, p2);
          const dSq = dir.lengthSq();
          const rSum = r1 + r2;

          if (dSq == 0.0 || dSq > rSum * rSum) continue;

          const d = Math.sqrt(dSq);
          dir.scale(1.0 / d); // Normalize

          // Resolve penetration
          const corr = rSum - d;
          p1.add(dir, corr);

          // Resolve velocity (simple push)
          const v_dot = v1.dot(dir);
          v1.add(dir, pushVel - v_dot); // Impart obstacle's push velocity along normal
        }
      }
    }
  }

  class PBDCableConstraintSolver {
    runInPause = false;

    update(world, dt) {
      const pathEntities = world.query([CablePathComponent]);
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path) continue;
        const jointEntities = path.jointEntities;
        const jointA = world.getComponent(jointEntities[0], CableJointComponent);
        const jointB = world.getComponent(jointEntities[jointEntities.length - 1], CableJointComponent);
        const entityA = jointA.entityA;
        const entityB = jointB.entityB;
        const posA = world.getComponent(entityA, PositionComponent)?.pos;
        const massA = world.getComponent(entityA, MassComponent)?.mass;
        const velA = world.getComponent(entityA, VelocityComponent)?.vel
        const posB = world.getComponent(entityB, PositionComponent)?.pos;
        const massB = world.getComponent(entityB, MassComponent)?.mass;
        const velB = world.getComponent(entityB, VelocityComponent)?.vel

        if (!posA || !massA || !posB || !massB) {
          console.warn(`CableJoint ${jointId} constraint skipped: Missing Pos/Mass on entities ${entityA} or ${entityB}`);
          continue;
        }

        const invMassA = massA > 0 ? 1.0 / massA : 0.0;
        const invMassB = massB > 0 ? 1.0 / massB : 0.0;
        const totalInvMass = invMassA + invMassB;

        if (totalInvMass <= 0.0) {
          continue; // Both objects immovable
        }

        // Use the attachment points calculated and cached by CableAttachmentUpdateSystem
        const pAttachA = jointA.attachmentPointA_world;
        const pAttachB = jointB.attachmentPointB_world;

        const dirA = new Vector2().subtractVectors(jointA.attachmentPointB_world, pAttachA);
        const dirB = new Vector2().subtractVectors(pAttachB, jointB.attachmentPointA_world);
        const currentDistA = dirA.length();
        const currentDistB = dirB.length();
        const restLengthA = jointA.restLength;
        const restLengthB = jointB.restLength;

        // Constraint: currentDist <= restLength
        if (currentDistA > restLengthA || currentDistB > restLengthB) {
          const errorA = currentDistA - restLengthA;
          const errorB = currentDistB - restLengthB;
          dirA.normalize();
          dirB.normalize();
          const corr = (errorA + errorB) / totalInvMass;

          // Calculate the displacement vectors (Standard PBD)
          const deltaA = dirA.clone().scale(invMassA * corr);
          const deltaB = dirB.clone().scale(-invMassB * corr);

          // Apply displacement to the entity positions.
          // This assumes the attachment point moves rigidly with the center.
          // A more correct PBD solver would handle angular effects.
          posA.add(deltaA);
          posB.add(deltaB);

          // Resolve velocity
          if (velA && invMassA > 0) {
            velA.add(deltaA, 1.0 / dt); // v_new = v_old + delta_p / dt
          }
          if (velB && invMassB > 0) {
            velB.add(deltaB, 1.0 / dt); // v_new = v_old + delta_p / dt
          }
        }
      }
    }
  }

  // --- System: Rendering ---
  class RenderSystem {
    runInPause = true; // Always render
    constructor(canvas, cScale, simHeight) {
      this.canvas = canvas;
      this.c = canvas.getContext("2d");
      this.cScale = cScale;
      this.simHeight = simHeight; // Needed for y-flipping
    }

    // Coordinate transformation helpers
    cX(x) { return x * this.cScale; }
    cY(y) { return this.canvas.height - y * this.cScale; }

    drawDisc(x, y, radius) {
      this.c.beginPath();
      this.c.arc(x, y, radius, 0.0, 2.0 * Math.PI);
      this.c.closePath();
      this.c.fill();
    }

    update(world, dt) {
      this.c.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Render Balls
      const ballEntities = world.query([BallTagComponent, PositionComponent, RadiusComponent, RenderableComponent]);
      for (const entityId of ballEntities) {
        const posComp = world.getComponent(entityId, PositionComponent);
        const radiusComp = world.getComponent(entityId, RadiusComponent);
        const renderComp = world.getComponent(entityId, RenderableComponent);

        this.c.fillStyle = renderComp.color;
        this.drawDisc(this.cX(posComp.pos.x), this.cY(posComp.pos.y), radiusComp.radius * this.cScale);
      }

      // Render Obstacles
      const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent, RenderableComponent]);
      for (const entityId of obstacleEntities) {
        const posComp = world.getComponent(entityId, PositionComponent);
        const radiusComp = world.getComponent(entityId, RadiusComponent);
        const renderComp = world.getComponent(entityId, RenderableComponent);

        this.c.fillStyle = renderComp.color;
        this.drawDisc(this.cX(posComp.pos.x), this.cY(posComp.pos.y), radiusComp.radius * this.cScale);
      }

      // Render Cable Joints
      const jointEntities = world.query([CableJointComponent, RenderableComponent]);
      this.c.lineWidth = 2;
      for (const entityId of jointEntities) {
        const jointComp = world.getComponent(entityId, CableJointComponent);
        const renderComp = world.getComponent(entityId, RenderableComponent); // Get render comp for color/shape check

        if (!jointComp.isActive || renderComp.shape !== 'line') continue; // Skip inactive or non-line joints

        const pA = jointComp.attachmentPointA_world;
        const pB = jointComp.attachmentPointB_world;

        // Check if points are valid (initialized)
        if (pA.lengthSq() > 0 && pB.lengthSq() > 0) {
          this.c.strokeStyle = renderComp.color; // Use component's color
          this.c.beginPath();
          this.c.moveTo(this.cX(pA.x), this.cY(pA.y));
          this.c.lineTo(this.cX(pB.x), this.cY(pB.y));
          this.c.stroke();
        }
      }
      this.c.lineWidth = 1; // Reset line width

      const debugPoints = world.getResource('debugRenderPoints');
      if (debugPoints) {
          const debugRadius = 3; // Pixel radius for debug dots
          this.c.save(); // Save current style state
          for (const key in debugPoints) {
              const pointData = debugPoints[key];
              if (pointData && pointData.pos) {
                  this.c.fillStyle = pointData.color;
                  // Use drawDisc or fillRect for small points
                  this.c.beginPath();
                  this.c.arc(
                      this.cX(pointData.pos.x),
                      this.cY(pointData.pos.y),
                      debugRadius,
                      0, 2 * Math.PI
                  );
                  this.c.fill();
              }
          }
          this.c.restore(); // Restore previous style state
      }
    }
  }


  // --- Global Setup ---
  const canvas = document.getElementById("myCanvas");

  canvas.width = window.innerWidth - 20;
  canvas.height = window.innerHeight - 100;

  const cScale = canvas.height/2;
  const simWidth = canvas.width / cScale;
  const simHeight = canvas.height / cScale;

  let world = new World();

  function setupScene() {
    world.clear(); // Clear entities and components

    // --- Resources ---
    world.setResource('gravity', new Vector2(0.0, -10.0));
    world.setResource('dt', 1.0 / 60.0);
    world.setResource('simWidth', simWidth);
    world.setResource('simHeight', simHeight);
    // Create a component for pause state and store it as a resource for easy access
    world.setResource('pauseState', new PauseStateComponent(true));
    world.setResource('debugRenderPoints', {}); // Initialize empty object for debug points


    // --- Entities and Components ---
    // Ball Entities
    const ballRadius = 0.03;
    const ballRestitution = 0.4; // Slightly higher for more bounce

    const ball1 = world.createEntity();
    world.addComponent(ball1, new BallTagComponent());
    world.addComponent(ball1, new PositionComponent(2.5*0.5, 1.1*0.5));
    world.addComponent(ball1, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball1, new RadiusComponent(ballRadius));
    world.addComponent(ball1, new MassComponent(0.1001));
    world.addComponent(ball1, new RestitutionComponent(ballRestitution));
    world.addComponent(ball1, new GravityAffectedComponent());
    world.addComponent(ball1, new RenderableComponent('circle', '#FF0000'));

    const ball2 = world.createEntity();
    world.addComponent(ball2, new BallTagComponent());
    world.addComponent(ball2, new PositionComponent(1.7*1.00, 2*0.3));
    world.addComponent(ball2, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball2, new RadiusComponent(ballRadius));
    world.addComponent(ball2, new MassComponent(0.1));
    world.addComponent(ball2, new RestitutionComponent(ballRestitution));
    world.addComponent(ball2, new GravityAffectedComponent());
    world.addComponent(ball2, new RenderableComponent('circle', '#00FF00'));

    // Obstacle Entities
    const obsColor = "#FF8000";
    const obs1 = world.createEntity();
    world.addComponent(obs1, new ObstacleTagComponent());
    world.addComponent(obs1, new PositionComponent(2*0.75, 2*0.75));
    world.addComponent(obs1, new MassComponent(-1.0));
    world.addComponent(obs1, new RadiusComponent(0.1));
    world.addComponent(obs1, new RenderableComponent('circle', obsColor));


    // --- Cable Setup ---
    // Path: ball1 -> obs1 -> ball2
    world.addComponent(obs1, new CableLinkComponent());
    world.addComponent(ball1, new CableLinkComponent());
    world.addComponent(ball2, new CableLinkComponent());

    // --- Calculate Initial Cable State ---
    // Need to compute initial attachment points and rest lengths
    // Get relevant components
    const pos_ball1 = world.getComponent(ball1, PositionComponent).pos;
    const pos_obs1 = world.getComponent(obs1, PositionComponent).pos;
    const radius_obs1 = world.getComponent(obs1, RadiusComponent).radius;
    const cw_obs1 = true;
    const link_obs1 = world.getComponent(obs1, CableLinkComponent);
    const pos_ball2 = world.getComponent(ball2, PositionComponent).pos;
    const link_ball2 = world.getComponent(ball2, CableLinkComponent);

    // Calculate initial points for joint1 (ball1 attachment <-> obs1 rolling)
    const initialPoints1 = tangentFromPointToCircle(pos_ball1, pos_obs1, radius_obs1, cw_obs1);
    const initialPoints2 = tangentFromCircleToPoint(pos_ball2, pos_obs1, radius_obs1, cw_obs1);

    // Create Cable Joint Entities with correct initial rest lengths
    const joint1 = world.createEntity(); // ball1 <-> obs1
    const initialDist1 = initialPoints1.a_attach.clone().subtract(initialPoints1.a_circle).length();
    world.addComponent(joint1, new CableJointComponent(
      ball1, obs1, initialDist1, initialPoints1.a_attach, initialPoints1.a_circle)); // Order matters
    world.addComponent(joint1, new RenderableComponent('line', '#FF0000')); // Red line

    const joint2 = world.createEntity(); // obs1 <-> ball2
    const initialDist2 = initialPoints2.a_attach.clone().subtract(initialPoints2.a_circle).length();
    world.addComponent(joint2, new CableJointComponent(
      obs1, ball2, initialDist2, initialPoints2.a_circle, initialPoints2.a_attach)); // Order matters
    world.addComponent(joint2, new RenderableComponent('line', '#FFFF00')); // Yellow line

    const cablePath = world.createEntity();
    world.addComponent(cablePath, new CablePathComponent([joint1, joint2], ['attachment', 'rolling', 'attachment'], [true, true, true])); // Order matters


    // --- Systems Registration (Order Matters!) ---
    if (world.systems.length === 0) { // Only register systems once
      world.registerSystem(new GravitySystem());      // Applies gravity acceleration
      world.registerSystem(new MovementSystem());     // Updates position based on velocity

      // --- Cable Systems (Run BEFORE constraint solving) ---

      world.registerSystem(new PBDBallBallCollisions());
      world.registerSystem(new PBDBallObstacleCollisions());
      world.registerSystem(new CableAttachmentUpdateSystem()); // Updates attachment points and rest lengths
      world.registerSystem(new PBDCableConstraintSolver());

      world.registerSystem(new RenderSystem(canvas, cScale, simHeight)); // Draws everything
    }

    // Update button text based on initial pause state
    const pauseState = world.getResource('pauseState');
    pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
  }


  // --- Main Loop ---
  let lastTime = 0;
  let doStep = true;

  function loop(currentTime) {
    const dt = world.getResource('dt');
    const pauseState = world.getResource('pauseState');

    if (!pauseState.paused || doStep) {
      if (doStep) pauseState.paused = false;
      console.log("----------------------------------------------");
      world.update(dt);
      if (doStep) pauseState.paused = true;
      doStep = false;
    }

    requestAnimationFrame(loop);
  }

  // --- Event Listeners ---
  pauseBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const pauseState = world.getResource('pauseState');
    if (pauseState) {
      pauseState.paused = !pauseState.paused;
      pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
    }
  });

  resetBtn.addEventListener('click', (e) => {
    e.preventDefault();
    setupScene();
    const pauseState = world.getResource('pauseState');
    if (pauseState) pauseState.paused = true;
    pauseBtn.textContent = "Resume";
    doStep = true;
  });

  stepBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const pauseState = world.getResource('pauseState');
    if (pauseState && pauseState.paused) {
      doStep = true;
    }
  });

  // --- Start ---
  setupScene();
  requestAnimationFrame(loop);

</script>

</body>
</html>
