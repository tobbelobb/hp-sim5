<!DOCTYPE html>
<html>
<head>
    <title>Cable Joints</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202020; font-family: sans-serif; }
        canvas { border: 1px solid black; display: block; margin: 10px auto; }
        #controls { text-align: center; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div id="controls">
        Score: <span id="score">0</span> |
        <button id="pauseBtn" tabindex="-1">Pause</button>
        <button id="resetBtn" tabindex="-1">Reset</button>
        <button id="stepBtn">Step</button>
    </div>
    <canvas id="myCanvas"></canvas>

<script>

  // --- Utility: Vector2 ---
  class Vector2 {
    constructor(x = 0.0, y = 0.0) { this.x = x; this.y = y; }
    set(v) { this.x = v.x; this.y = v.y; }
    clone() { return new Vector2(this.x, this.y); }
    add(v, s = 1.0) { this.x += v.x * s; this.y += v.y * s; return this; }
    addVectors(a, b) { this.x = a.x + b.x; this.y = a.y + b.y; return this; }
    subtract(v, s = 1.0) { this.x -= v.x * s; this.y -= v.y * s; return this; }
    subtractVectors(a, b) { this.x = a.x - b.x; this.y = a.y - b.y; return this; }
    distanceTo(b) { return Math.sqrt((this.x - b.x)*(this.x - b.x) + (this.y - b.y)*(this.y - b.y)); }
    length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    lengthSq() { return this.x * this.x + this.y * this.y; } // Optimization
    scale(s) { this.x *= s; this.y *= s; return this; }
    dot(v) { return this.x * v.x + this.y * v.y; }
    perp() { return new Vector2(-this.y, this.x); }
    normalize() { const l = this.length(); if (l > 0) this.scale(1.0 / l); return this; }
  }

  // --- Utility: Geometry ---
  function closestPointOnSegment(p, a, b) {
    const ab = new Vector2().subtractVectors(b, a);
    const ap = new Vector2().subtractVectors(p, a);
    let t = ap.dot(ab);
    if (t <= 0.0) return a.clone();
    const denom = ab.dot(ab);
    if (t >= denom) return b.clone();
    t = t / denom;
    return a.clone().add(ab, t);
  }

  // Helper: Calculate tangent points between a point and a circle (Algorithm 3 from Cable Joints paper)
  function _tangentPointCircle(p_attach, p_circle, r_circle, cw, pointIsFirst) {
    const dVec = new Vector2().subtractVectors(p_circle, p_attach);
    const dSq = dVec.lengthSq();

    if (dSq <= r_circle * r_circle + 1e-9) {
      console.warn("Cable tangent calculation: Attachment point inside or on rolling circle.");
      const dir = dVec.lengthSq() > 1e-9 ? dVec.clone().normalize() : new Vector2(1, 0);
      return {
        a_attach: p_attach.clone(),
        a_circle: p_circle.clone().add(dir, r_circle)
      };
    }

    const d = Math.sqrt(dSq);
    const alpha = Math.atan2(dVec.y, dVec.x);
    const phi = Math.asin(r_circle / d);

    let tangent_point_angle_on_circle;
    if ((cw && pointIsFirst) || (!cw && !pointIsFirst)) {
      tangent_point_angle_on_circle = alpha + phi + Math.PI/2;
    } else {
      tangent_point_angle_on_circle = alpha - phi - Math.PI/2;
    }

    const a_circle = new Vector2(
      p_circle.x + r_circle * Math.cos(tangent_point_angle_on_circle),
      p_circle.y + r_circle * Math.sin(tangent_point_angle_on_circle)
    );

    return {
      a_attach: p_attach.clone(), // Attachment point doesn't change
      a_circle: a_circle          // Calculated tangent point on the circle
    };
  }

  function tangentFromPointToCircle(p_attach, p_circle, r_circle, cw) {
    return _tangentPointCircle(p_attach, p_circle, r_circle, cw, true);
  }

  function tangentFromCircleToPoint(p_attach, p_circle, r_circle, cw) {
    return _tangentPointCircle(p_attach, p_circle, r_circle, cw, false);
  }


  function tangentFromCircleToCircle(posA, radiusA, cwA, posB, radiusB, cwB) {
    const dVec = new Vector2().subtractVectors(posB, posA);
    const dSq = dVec.lengthSq();
    const d = Math.sqrt(dSq);

    let r = (cwA === cwB) ? (radiusB - radiusA) : (radiusA + radiusB);
    if (d <= Math.abs(r)) {
      console.warn("Cable tangent calculation: Circles are overlapping or too close.");
      return null;
    }

    const alpha = Math.atan2(dVec.y, dVec.x);
    const phi = Math.asin(r / d);

    let angleA, angleB;
    if (!cwA === cwB) {
      if (!cwA) {
        angleA = alpha - Math.PI / 2 - phi;
        angleB = alpha - Math.PI / 2 - phi;
      } else {
        angleA = alpha + Math.PI / 2 + phi;
        angleB = alpha + Math.PI / 2 + phi;
      }
    } else {
      if (!cwA) {
        angleA = alpha - Math.PI / 2 + phi;
        angleB = alpha - Math.PI / 2 - phi;
      } else {
        angleA = alpha + Math.PI / 2 - phi;
        angleB = alpha + Math.PI / 2 + phi;
      }
    }

    const tangentA = new Vector2(
      posA.x + radiusA * Math.cos(angleA),
      posA.y + radiusA * Math.sin(angleA)
    );
    const tangentB = new Vector2(
      posB.x + radiusB * Math.cos(angleB),
      posB.y + radiusB * Math.sin(angleB)
    );

    return {
      a_circle: tangentA,
      b_circle: tangentB
    };
  }




  /**
   * Calculates signed arc length between two world-space points on the circumference of a wheel.
   *
   * @param {Vector2} prevPoint - Previous attachment point on the wheel (world-space)
   * @param {Vector2} currPoint - Current attachment point on the wheel (world-space)
   * @param {Vector2} center - Center of the wheel (world-space)
   * @param {number} radius - Radius of the wheel
   * @param {boolean} clockwisePreference - If true, positive arc length means CW, else CCW
   * @returns {number} Signed arc length (positive = preferred direction)
   */
  function signedArcLengthOnWheel(prevPoint, currPoint, center, radius, clockwisePreference) {
    const toPrev = new Vector2().subtractVectors(prevPoint, center);
    const toCurr = new Vector2().subtractVectors(currPoint, center);

    // Get angle between the two vectors (signed)
    let angle = Math.atan2(toCurr.y, toCurr.x) - Math.atan2(toPrev.y, toPrev.x);

    // Normalize angle to range [-π, π]
    if (angle > Math.PI) angle -= 2 * Math.PI;
    if (angle < -Math.PI) angle += 2 * Math.PI;

    // If wheel is clockwise, positive angle should represent CW → flip sign
    if (clockwisePreference) {
      angle *= -1;
    }

    // Arc length = radius * angle (signed)
    return radius * angle;
  }

  /**
   * Checks if a line segment intersects a circle.
   * @param {Vector2} p1 - Start point of the segment
   * @param {Vector2} p2 - End point of the segment
   * @param {Vector2} center - Center of the circle
   * @param {number} radius - Radius of the circle
   * @returns {boolean} True if the segment intersects the circle, false otherwise.
   */
  function lineSegmentCircleIntersection(p1, p2, center, radius) {
    // 1. Check if either endpoint is inside the circle
    if (p1.distanceTo(center) <= radius || p2.distanceTo(center) <= radius) {
      return true;
    }

    // 2. Check if the projection of the center onto the line lies within the segment
    const d = new Vector2().subtractVectors(p2, p1);
    const lc = new Vector2().subtractVectors(center, p1);
    const dLengthSq = d.lengthSq();

    // Project center onto the line containing the segment
    let t = lc.dot(d);
    if (dLengthSq > 1e-9) { // Avoid division by zero for zero-length segment
        t /= dLengthSq;
    }

    if (t < 0.0) {
      return false; // Closest point is p1
    } else if (t > 1.0) {
      return false; // Closest point is p2
    }

    const closestPointOnLine = p1.clone().add(d, t);

    // 3. Check if the closest point on the segment is within the circle's radius
    return closestPointOnLine.distanceTo(center) <= radius;
  }


  // --- ECS Core ---
  class World {
    constructor() {
      this.entities = new Map(); // entityId -> Set<ComponentClass>
      this.components = new Map(); // ComponentClass -> Map<entityId, ComponentInstance>
      this.nextEntityId = 0;
      this.systems = [];
      this.resources = {}; // Global data like gravity, dt
    }

    createEntity() {
      const id = this.nextEntityId++;
      this.entities.set(id, new Set());
      return id;
    }

    addComponent(entityId, component) {
      const componentClass = component.constructor;
      if (!this.components.has(componentClass)) {
        this.components.set(componentClass, new Map());
      }
      this.components.get(componentClass).set(entityId, component);
      if (this.entities.has(entityId)) {
        this.entities.get(entityId).add(componentClass);
      } else {
        console.warn(`Entity ${entityId} does not exist when adding ${componentClass.name}`);
      }
    }

    getComponent(entityId, componentClass) {
      const componentMap = this.components.get(componentClass);
      return componentMap ? componentMap.get(entityId) : undefined;
    }

    hasComponent(entityId, componentClass) {
      const componentMap = this.components.get(componentClass);
      return componentMap ? componentMap.has(entityId) : false;
    }

    removeComponent(entityId, componentClass) {
      const componentMap = this.components.get(componentClass);
      if (componentMap) {
        componentMap.delete(entityId);
      }
      const entityComponents = this.entities.get(entityId);
      if (entityComponents) {
        entityComponents.delete(componentClass);
      }
    }

    destroyEntity(entityId) {
      if (!this.entities.has(entityId)) return;
      for (const componentClass of this.entities.get(entityId)) {
        this.removeComponent(entityId, componentClass);
      }
      this.entities.delete(entityId);
    }

    query(componentClasses) {
      const entities = [];
      if (componentClasses.length === 0) return [];

      // Start with entities having the first component
      const firstComponentMap = this.components.get(componentClasses[0]);
      if (!firstComponentMap) return [];

      for (const entityId of firstComponentMap.keys()) {
        let hasAll = true;
        for (let i = 1; i < componentClasses.length; i++) {
          if (!this.hasComponent(entityId, componentClasses[i])) {
            hasAll = false;
            break;
          }
        }
        if (hasAll) {
          entities.push(entityId);
        }
      }
      return entities;
    }

    registerSystem(system) {
      this.systems.push(system);
    }

    setResource(name, value) {
      this.resources[name] = value;
    }

    getResource(name) {
      return this.resources[name];
    }

    clear() {
      this.entities.clear();
      this.components.clear();
      this.nextEntityId = 0;
      // Keep systems and resources
    }

    update(dt) {
      const pauseState = this.getResource('pauseState');
      const isPaused = pauseState ? pauseState.paused : false;

      for (const system of this.systems) {
        if (system.update && (!system.runInPause && isPaused)) {
          continue; // Skip non-pause systems if paused
        }
        if (system.update) {
          system.update(this, dt);
        }
      }
      canvas.focus();
    }
  }

  // --- Components (Plain Data) ---

  class PositionComponent { constructor(x = 0, y = 0) { this.pos = new Vector2(x, y); } }
  class VelocityComponent { constructor(x = 0, y = 0) { this.vel = new Vector2(x, y); } }
  class RadiusComponent { constructor(radius = 0.1) { this.radius = radius; } }
  class MassComponent { constructor(mass = 1.0) { this.mass = mass; } }
  class RestitutionComponent { constructor(restitution = 0.5) { this.restitution = restitution; } }
  class GravityAffectedComponent { /* Tag component */ }
  class BallTagComponent { /* Tag component */ }
  class ObstacleTagComponent { /* Tag component */ }
  class PauseStateComponent { constructor(paused = true) { this.paused = paused; } }
  class CableLinkComponent { constructor(x = 0, y = 0) { this.prevPos = new Vector2(x, y); } }

  // Represents a single segment constraint between two entities
  class CableJointComponent {
    constructor(entityA, entityB, restLength, attachmentPointA_world, attachmentPointB_world) {
      this.entityA = entityA;
      this.entityB = entityB;
      this.restLength = restLength; // dn - the dynamic maximum length
      this.isActive = true; // For merge/split logic
      this.attachmentPointA_world = attachmentPointA_world.clone();
      this.attachmentPointB_world = attachmentPointB_world.clone();
    }
  }

  // Represents the entire cable path
  class CablePathComponent {
    constructor(jointEntities = [], linkTypes = [], cw = []) {
      this.totalRestLength = 0.0;
      this.jointEntities = jointEntities; // Ordered list of CableJoint entity IDs
      this.linkTypes = linkTypes; // Ordered. linkTypes.length === jointEntities.length + 1
      this.cw = cw // Ordered. cw.length === linkTypes.length
      this.stored = new Array(cw.length).fill(0.0); // Ordered. stored.length === cw.length

      for (const jointId of jointEntities) {
        const joint = world.getComponent(jointId, CableJointComponent);
        this.totalRestLength += joint.restLength;
      }
      for (let i = 0; i < jointEntities.length - 1; i++) { // Iterate over adjacent pairs
        const jointId_i = jointEntities[i];
        const jointId_i_plus_1 = jointEntities[i + 1];
        const joint_i = world.getComponent(jointId_i, CableJointComponent);
        const joint_i_plus_1 = world.getComponent(jointId_i_plus_1, CableJointComponent);
        const linkId = joint_i.entityB;
        const linkId2 = joint_i_plus_1.entityA;
        if (linkId !== linkId2) {
          console.warn("Links don't match up. There's something wrong with this cable path.");
          return;
        }
        const isRolling = linkTypes[i + 1] === 'rolling';
        // Assuming standard path structure A->B, A->B, check B_i == A_i+1
        if (isRolling) {
          const rolling_link = world.getComponent(linkId, CableLinkComponent);
          const center = world.getComponent(linkId, PositionComponent).pos;
          const radius = world.getComponent(linkId, RadiusComponent).radius;
          const isCw = cw[i + 1];

          const initialStoredLength = signedArcLengthOnWheel(
              joint_i.attachmentPointB_world,
              joint_i_plus_1.attachmentPointA_world,
              center,
              radius,
              isCw
          );
          this.stored[i + 1] = initialStoredLength;
          this.totalRestLength += initialStoredLength;
        }
      }
    }
  }


  // Render-specific component (could be more complex)
  class RenderableComponent {
    constructor(shape = 'circle', color = '#888888') {
      this.shape = shape; // 'circle', 'flipper', 'border'
      this.color = color;
    }
  }

  // --- Systems (Logic) ---

  // --- System: Gravity ---
  class GravitySystem {
    runInPause = false;
    update(world, dt) {
      const gravity = world.getResource('gravity');
      if (!gravity) return;

      const entities = world.query([VelocityComponent, GravityAffectedComponent]);
      for (const entityId of entities) {
        const velComp = world.getComponent(entityId, VelocityComponent);
        velComp.vel.add(gravity, dt);
      }
    }
  }

  // --- System: Movement ---
  class MovementSystem {
    runInPause = false;
    update(world, dt) {
      // Update linear position
      const linearEntities = world.query([PositionComponent, VelocityComponent]);
      for (const entityId of linearEntities) {
        const posComp = world.getComponent(entityId, PositionComponent);
        const velComp = world.getComponent(entityId, VelocityComponent);
        posComp.pos.add(velComp.vel, dt);
      }
    }
  }


  // --- System: Cable Attachment Update ---
  // Calculates tangent points and updates rest lengths (dn) BEFORE the main solver
  class CableAttachmentUpdateSystem {
    runInPause = false; // Physics system

    update(world, dt) {
      const debugPoints = world.getResource('debugRenderPoints');
      // Clear points from the previous frame
      for (const key in debugPoints) {
          delete debugPoints[key];
      }

      const pathEntities = world.query([CablePathComponent]);
      //// Merge joints
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path || path.jointEntities.length < 2) continue;
        const jointsInPath = path.jointEntities;
        for (let i = 0; i < path.jointEntities.length - 1; i++) { // Iterate over adjacent pairs
          const jointId_i = path.jointEntities[i];
          const jointId_i_plus_1 = path.jointEntities[i + 1];
          const joint_i = world.getComponent(jointId_i, CableJointComponent);
          const joint_i_plus_1 = world.getComponent(jointId_i_plus_1, CableJointComponent);
          const linkId = joint_i.entityB;
          const linkId2 = joint_i_plus_1.entityA;
          if (linkId !== linkId2) {
            log.warn("Merge loop saw disconnected cable path");
          }
          //console.log(`was stored: ${path.stored[i+1]}`);
          const isRolling = path.linkTypes[i + 1] === 'rolling';
          if (isRolling) {
            if (path.stored[i + 1] < 0.0) {
              console.log(`Merging joints ${jointId_i} and ${jointId_i_plus_1}.`);
              const posA = world.getComponent(joint_i.entityA, PositionComponent).pos;
              const radiusA = world.getComponent(joint_i.entityA, RadiusComponent)?.radius;
              const cwA = path.cw[i];
              const posB = world.getComponent(joint_i_plus_1.entityB, PositionComponent).pos;
              const radiusB = world.getComponent(joint_i_plus_1.entityB, RadiusComponent)?.radius;
              const cwB = path.cw[i+2];

              const lengthToAdd = joint_i_plus_1.restLength + path.stored[i + 1];
              joint_i.restLength += lengthToAdd;
              joint_i.entityB = joint_i_plus_1.entityB;
              const isRollingA = path.linkTypes[i] === 'rolling';
              const isAttachmentA = path.linkTypes[i] === 'attachment';
              const isRollingB = path.linkTypes[i+2] === 'rolling';
              const isAttachmentB = path.linkTypes[i+2] === 'attachment';
              if (isRollingA && isRollingB) {
                const tangents = tangentFromCircleToCircle(posA, radiusA, cwA, posB, radiusB, cwB);
                const sA = signedArcLengthOnWheel(joint_i.attachmentPointA_world, tangents.a_circle, posA, radiusA, cwA);
                path.stored[i] += sA;
                joint_i.restLength -= sA; // Corrected from joint.restLength
                const sB = signedArcLengthOnWheel(joint_i_plus_1.attachmentPointB_world, tangents.b_circle, posB, radiusB, cwB);
                path.stored[i+2] -= sB;
                joint_i.restLength += sB; // Corrected from joint.restLength
                joint_i.attachmentPointA_world = tangents.a_circle;
                joint_i.attachmentPointB_world = tangents.b_circle;
              } else if (isRollingA && isAttachmentB) {
                const tangents = tangentFromCircleToPoint(posB, posA, radiusA, cwA);
                const sA = signedArcLengthOnWheel(joint_i.attachmentPointA_world, tangents.a_circle, posA, radiusA, cwA); // Corrected joint_1 typo
                path.stored[i] += sA;
                joint_i.restLength -= sA;
                joint_i.attachmentPointA_world = tangents.a_circle;
                joint_i.attachmentPointB_world = tangents.a_attach;
              } else if (isAttachmentA && isRollingB) {
                const tangents = tangentFromPointToCircle(posA, posB, radiusB, cwB);
                const sB = signedArcLengthOnWheel(joint_i_plus_1.attachmentPointB_world, tangents.a_circle, posB, radiusB, cwB);
                path.stored[i+2] -= sB;
                joint_i.restLength += sB;
                joint_i.attachmentPointA_world = tangents.a_attach;
                joint_i.attachmentPointB_world = tangents.a_circle;
              } else {
                joint_i.attachmentPointA_world = posA;
                joint_i.attachmentPointB_world = posB;
              }

              path.jointEntities.splice(i+1, 1);
              path.stored.splice(i+1, 1);
              path.cw.splice(i+1, 1);
              path.linkTypes.splice(i+1, 1);
              joint_i_plus_1.isActive = false;
              world.destroyEntity(jointId_i_plus_1);
            }
          }
        }
        //console.log(`path.stored up here: ${path.stored}`);
      }


      // -- New attachment points --
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path) continue; // Ensure path exists

        // Iterate through joints to calculate NEW tangent points and update lengths
        for (var jointIdx = 0; jointIdx < path.jointEntities.length; jointIdx++) {
          const jointId = path.jointEntities[jointIdx];
          const joint = world.getComponent(jointId, CableJointComponent);
          if (!joint || !joint.isActive) continue; // Check joint validity

          const A = jointIdx; // Index for link/cw/stored related to entity A side
          const B = jointIdx + 1; // Index for link/cw/stored related to entity B side

          const entityA = joint.entityA;
          const entityB = joint.entityB;

          // Get components for Entity A using CURRENT positions
          const posAComp = world.getComponent(entityA, PositionComponent);
          const radiusAComp = world.getComponent(entityA, RadiusComponent);
          const linkAComp = world.getComponent(entityA, CableLinkComponent); // Needed for prevPos if rolling
          const posA = posAComp?.pos;
          const radiusA = radiusAComp?.radius;
          const cwA = path.cw[A];
          const attachmentLinkA = path.linkTypes[A] === 'attachment';
          const rollingLinkA = path.linkTypes[A] === 'rolling';

          // Get components for Entity B using CURRENT positions
          const posBComp = world.getComponent(entityB, PositionComponent);
          const radiusBComp = world.getComponent(entityB, RadiusComponent);
          const linkBComp = world.getComponent(entityB, CableLinkComponent); // Needed for prevPos if rolling
          const posB = posBComp?.pos;
          const radiusB = radiusBComp?.radius;
          const cwB = path.cw[B];
          const attachmentLinkB = path.linkTypes[B] === 'attachment';
          const rollingLinkB = path.linkTypes[B] === 'rolling';

          // --- Essential Checks ---
          if (!posA || !posB) {
            console.warn(`CableJoint ${jointId} missing PositionComponent on entities ${entityA} or ${entityB}. Skipping update.`);
            continue;
          }
          if (rollingLinkA && (!radiusAComp || !linkAComp)) {
             console.warn(`CableJoint ${jointId} entity ${entityA} is 'rolling' but missing RadiusComponent or CableLinkComponent. Skipping update.`);
             continue;
          }
           if (rollingLinkB && (!radiusBComp || !linkBComp)) {
             console.warn(`CableJoint ${jointId} entity ${entityB} is 'rolling' but missing RadiusComponent or CableLinkComponent. Skipping update.`);
             continue;
          }
          // --- End Checks ---


          let attachmentA_current, attachmentB_current;
          let sA = 0; // Change in stored length on side A due to wrapping/unwrapping this frame
          let sB = 0; // Change in stored length on side B due to wrapping/unwrapping this frame

          // --- Calculate Ideal Current Attachment Points based on CURRENT entity positions ---
          let tangents; // Declare tangents variable outside specific cases
          if (attachmentLinkA && rollingLinkB) {
            tangents = tangentFromPointToCircle(posA, posB, radiusB, cwB);
            attachmentA_current = tangents.a_attach; // This is just posA
            attachmentB_current = tangents.a_circle; // Tangent on circle B
          } else if (rollingLinkA && attachmentLinkB) {
            tangents = tangentFromCircleToPoint(posB, posA, radiusA, cwA);
            attachmentA_current = tangents.a_circle; // Tangent on circle A
            attachmentB_current = tangents.a_attach; // This is just posB
          } else if (rollingLinkA && rollingLinkB) {
            tangents = tangentFromCircleToCircle(posA, radiusA, cwA, posB, radiusB, cwB);
            if (tangents) {
                attachmentA_current = tangents.a_circle;
                attachmentB_current = tangents.b_circle;
            } else {
                // Fallback if tangent calculation fails (e.g., overlap)
                console.warn(`Could not calculate tangents between rolling ${entityA} and ${entityB}. Using previous points.`);
                // Keep previous points to avoid NaN issues, but lengths won't update correctly this frame
                attachmentA_current = joint.attachmentPointA_world.clone();
                attachmentB_current = joint.attachmentPointB_world.clone();
                // Set sA and sB to 0 because we couldn't calculate the change
                sA = 0;
                sB = 0;
                // Skip the arc length calculation below for this case
                // We will jump directly to updating the joint's points at the end
            }
          } else { // attachmentLinkA && attachmentLinkB
            attachmentA_current = posA.clone();
            attachmentB_current = posB.clone();
            sA = 0; // No arc length change for point-to-point
            sB = 0;
          }

          // --- Calculate Wrapping/Unwrapping (sA, sB) if tangents were calculated ---
          // This section is skipped if tangents == null (e.g., circle-circle overlap fallback)
          if (tangents !== null) { // Check if tangents were successfully calculated or if it's point-to-point
              if (rollingLinkA) {
                  // Project the previous attachment point onto the current frame
                  const vec_prevCenter_to_prevAttachA = joint.attachmentPointA_world.clone().subtract(linkAComp.prevPos);
                  const projected_prevAttachA = posA.clone().add(vec_prevCenter_to_prevAttachA);
                  // Calculate arc length between projected old point and new point, relative to current center
                  sA = signedArcLengthOnWheel(projected_prevAttachA, attachmentA_current, posA, radiusA, cwA);
              } else {
                  sA = 0; // Not rolling, no arc length change on A
              }

              if (rollingLinkB) {
                  // Project the previous attachment point onto the current frame
                  const vec_prevCenter_to_prevAttachB = joint.attachmentPointB_world.clone().subtract(linkBComp.prevPos);
                  const projected_prevAttachB = posB.clone().add(vec_prevCenter_to_prevAttachB);
                  // Calculate arc length between projected old point and new point, relative to current center
                  sB = signedArcLengthOnWheel(projected_prevAttachB, attachmentB_current, posB, radiusB, cwB);
              } else {
                  sB = 0; // Not rolling, no arc length change on B
              }
          }
          // --- End Wrapping/Unwrapping Calculation ---


          // --- Update stored lengths and rest length based on calculated sA and sB ---
          // sA > 0 means cable wrapped onto A (in preferred direction) -> stored[A] increases, restLength decreases
          path.stored[A] += sA;
          joint.restLength -= sA;
          //console.log(`Added rest length ${-sA}`);

          // sB > 0 means cable wrapped onto B (in preferred direction) -> stored[B] increases, restLength decreases
          // Correction from previous attempt: My interpretation of signedArcLength was reversed for the second point.
          // If signedArcLength(prev, curr) is positive (meaning curr is 'ahead' of prev in the preferred direction),
          // it means cable has *unwrapped* from the wheel between prev and curr.
          // So, stored length should DECREASE, and free length (restLength) should INCREASE.
          path.stored[B] -= sB; // Correct: Positive sB means unwrapped, so decrease stored
          joint.restLength += sB; // Correct: Positive sB means unwrapped, so increase free length
          //console.log(`Added rest length ${sA}`);

          // Debugging logs (optional)
          //if (sA !== 0 || sB !== 0) {
              //console.log(`Joint ${jointId}: sA=${sA.toFixed(4)}, sB=${sB.toFixed(4)} -> stored[A]=${path.stored[A].toFixed(4)}, stored[B]=${path.stored[B].toFixed(4)}, restLen=${joint.restLength.toFixed(4)}`);
          //}


          // Ensure rest length doesn't go negative
          if (joint.restLength < 0) {
              // Simple clamping - might need refinement if issues arise
              // console.warn(`Joint ${jointId} restLength became negative (${joint.restLength.toFixed(4)}), clamping to 0.`);
              // Optionally distribute deficit back to stored lengths if needed
              joint.restLength = 0;
          }

          // --- Update the joint's stored attachment points for the NEXT frame's comparison ---
          joint.attachmentPointA_world.set(attachmentA_current);
          joint.attachmentPointB_world.set(attachmentB_current);

        } // End loop through joints
      } // End loop through paths

      // Split joints
      // Entities that can cause a split
      const potentialSplitters = world.query([PositionComponent, RadiusComponent, CableLinkComponent]);
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path || path.jointEntities.length < 1) continue;
        for (var jointIndex = 0; jointIndex < path.jointEntities.length; jointIndex++) {
          const jointId = path.jointEntities[jointIndex];
          const joint = world.getComponent(jointId, CableJointComponent);
          if (!joint.isActive) {
            console.warn("An inactive joint seems to be part of a path right now.");
            continue;
          }
          const pA = joint.attachmentPointA_world;
          const pB = joint.attachmentPointB_world;
          for (const splitterId of potentialSplitters) {
            if (splitterId === joint.entityA || splitterId === joint.entityB) {
              continue;
            }
            const posSplitter = world.getComponent(splitterId, PositionComponent).pos;
            const radiusSplitter = world.getComponent(splitterId, RadiusComponent).radius;
            if (lineSegmentCircleIntersection(pA, pB, posSplitter, radiusSplitter)) {
              console.log(`Splitting joint ${jointId} due to intersection with ${splitterId}`);
              const newJointId = world.createEntity();

              //console.log(path.stored);
              const cw = true;
              const linkTypeB = path.linkTypes[jointIndex + 1];
              const entityB = joint.entityB;
              const entityA = joint.entityA;
              var initialPoints;
              var initialDist1;
              var attachmentPointAForNewJoint;
              var attachmentPointBForNewJoint;
              const posB = world.getComponent(entityB, PositionComponent).pos;
              if (linkTypeB === 'rolling') {
                const radiusB = world.getComponent(entityB, RadiusComponent).radius;
                const cwB = path.cw[jointIndex + 1];
                initialPoints = tangentFromCircleToCircle(posSplitter, radiusSplitter, cw, posB, radiusB, cwB);
                initialDist1 = initialPoints.a_circle.clone().subtract(initialPoints.b_circle).length();
                attachmentPointAForNewJoint = initialPoints.a_circle;
                attachmentPointBForNewJoint = initialPoints.b_circle;
                const sB = signedArcLengthOnWheel(pB, attachmentPointBForNewJoint, posB, radiusB, cwB);
                path.stored[jointIndex + 1] -= sB;
                joint.restLength += sB;
              } else if (linkTypeB === 'attachment') {
                initialPoints = tangentFromCircleToPoint(posB, posSplitter, radiusSplitter, cw);
                initialDist1 = initialPoints.a_attach.clone().subtract(initialPoints.a_circle).length();
                attachmentPointAForNewJoint = initialPoints.a_circle;
                attachmentPointBForNewJoint = initialPoints.a_attach;
              } else {
                console.warn(`Splitting cable joint attached to ${linkTypeB} is not supported.`);
              }

              path.jointEntities.splice(jointIndex + 1, 0, newJointId);
              path.cw.splice(jointIndex + 1, 0, cw);
              path.linkTypes.splice(jointIndex + 1, 0, 'rolling');

              const linkTypeA = path.linkTypes[jointIndex];
              const posA = world.getComponent(entityA, PositionComponent).pos;
              var newAttachmentPointBForJoint;
              var newAttachmentPointAForJoint;
              var initialPoints2;
              var initialDist2;
              if (linkTypeA === 'rolling') {
                const radiusA = world.getComponent(entityA, RadiusComponent).radius;
                const cwA = path.cw[jointIndex];
                initialPoints2 = tangentFromCircleToCircle(posA, radiusA, cwA, posSplitter, radiusSplitter, cw);
                initialDist2 = initialPoints2.a_circle.clone().subtract(initialPoints2.b_circle).length();
                newAttachmentPointAForJoint = initialPoints.a_circle;
                const sA = signedArcLengthOnWheel(pA, newAttachmentPointAForJoint, posA, radiusA, cwA);
                joint.attachmentPointA_world.set(newAttachmentPointAForJoint);
                path.stored[jointIndex] += sA;
                joint.restLength -= sA;
                //console.log(`split increased restLength (-sA) by ${-sA}`)
                newAttachmentPointBForJoint = initialPoints.b_circle;
                console.log("New attachment A changes stored by: ", sA);
              } else if (linkTypeA === 'attachment') {
                initialPoints2 = tangentFromPointToCircle(posA, posSplitter, radiusSplitter, cw); // HERE
                initialDist2 = initialPoints2.a_circle.clone().subtract(initialPoints2.a_attach).length();
                newAttachmentPointBForJoint = initialPoints2.a_circle;
              } else {
                console.warn(`Splitting cable joint attached to ${linkTypeA} is not supported.`);
              }
              joint.entityB = splitterId;
              const s = signedArcLengthOnWheel(
                  newAttachmentPointBForJoint,
                  attachmentPointAForNewJoint,
                  posSplitter,
                  radiusSplitter,
                  cw
              );
              // The line is slightly stretched due to the intersection with the new link (the splitterId Entity).
              // Distributes the discrepancy (length_error) to both sides of the new link such that tension remains constant on both sides of the new link.
              // The paper states:
              // "The rest length of the original joint is distributed among the new joints such that the tension on both sides are equal."
              // "The rest length is split such that the tension remains constant."
              // "tension (the current length divided by the rest length)"
              // Distribute original rest length (minus new stored length s)
              // between the two new segments to maintain equal tension.
              const originalRestLength = joint.restLength; // Store before modifying
              const totalDist = initialDist1 + initialDist2;
              let newRestLength1 = 0; // For new joint (splitter -> entityB)
              let newRestLength2 = 0; // For original joint (entityA -> splitter)

              if (totalDist > 1e-9) { // Avoid division by zero if distances are tiny
                  const availableRestLength = originalRestLength - s;
                  if (availableRestLength < 0) {
                      console.warn(`Split resulted in negative available rest length (${availableRestLength.toFixed(4)}). Clamping.`);
                      // This might happen if s is large due to tight wrapping.
                      // Simple clamp for now, might need better handling.
                      newRestLength1 = 0;
                      newRestLength2 = 0;
                  } else {
                      newRestLength1 = availableRestLength * initialDist1 / totalDist;
                      newRestLength2 = availableRestLength * initialDist2 / totalDist;
                  }
              } else {
                  console.warn("Split occurred with near-zero distance between new segments.");
                  // Assign zero rest lengths if distances are negligible
                  newRestLength1 = 0;
                  newRestLength2 = 0;
              }

              // Update original joint (now entityA -> splitter)
              joint.restLength = newRestLength2;
              joint.attachmentPointB_world.set(newAttachmentPointBForJoint); // Update endpoint

              // Create the new joint (splitter -> entityB)
              world.addComponent(newJointId, new CableJointComponent(
                  splitterId, entityB, newRestLength1, attachmentPointAForNewJoint, attachmentPointBForNewJoint));
              world.addComponent(newJointId, new RenderableComponent('line', '#0000FF')); // Blue line for new joint

              console.log(`Split: L_orig=${originalRestLength.toFixed(4)}, s=${s.toFixed(4)} -> L1=${newRestLength1.toFixed(4)} (d1=${initialDist1.toFixed(4)}), L2=${newRestLength2.toFixed(4)} (d2=${initialDist2.toFixed(4)})`);
              path.stored.splice(jointIndex + 1, 0, s);

              //console.log(path.stored);
            }
          }
        }
      }

      const linkEntities = world.query([CableLinkComponent, PositionComponent]);
      for (const link of linkEntities) {
        const pos = world.getComponent(link, PositionComponent).pos;
        const prevPos = world.getComponent(link, CableLinkComponent).prevPos;
        //console.log("Current pos: ", pos)
        //console.log("Previous pos: ", prevPos)
        world.getComponent(link, CableLinkComponent).prevPos = pos.clone();
      }

      // Debugging/test loop 1
      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path || path.jointEntities.length < 1) continue;
        var totalCurrentDist = 0.0;
        var totalCurrentRestLength = 0.0;
        for (var jointIdx = 0; jointIdx < path.jointEntities.length; jointIdx++) {
          const jointId = path.jointEntities[jointIdx];
          const joint = world.getComponent(jointId, CableJointComponent);

          // Ensure joint exist and is active
          if (!joint || !joint.isActive) continue;

          // Calculate current lengths using the attachment points updated in Pass A
          const currentDist = joint.attachmentPointA_world.distanceTo(joint.attachmentPointB_world);
          totalCurrentDist += currentDist + path.stored[jointIdx + 1];
          totalCurrentRestLength += joint.restLength + path.stored[jointIdx + 1];
        }

        const error = path.totalRestLength - totalCurrentRestLength;
        console.log(`error path ${pathId}: ${error}`); // rest length error is and should be very close to zero
        //console.log(`stored: ${path.stored}`);
      }
    }
  }

  class PBDBallBallCollisions {
    runInPause = false;
    update(world, dt) {
      const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
      for (let i = 0; i < ballEntities.length; i++) {
        for (let j = i + 1; j < ballEntities.length; j++) {
          const e1 = ballEntities[i];
          const e2 = ballEntities[j];

          const p1 = world.getComponent(e1, PositionComponent).pos;
          const v1 = world.getComponent(e1, VelocityComponent).vel;
          const r1 = world.getComponent(e1, RadiusComponent).radius;
          const m1 = world.getComponent(e1, MassComponent).mass;
          const res1 = world.getComponent(e1, RestitutionComponent).restitution;

          const p2 = world.getComponent(e2, PositionComponent).pos;
          const v2 = world.getComponent(e2, VelocityComponent).vel;
          const r2 = world.getComponent(e2, RadiusComponent).radius;
          const m2 = world.getComponent(e2, MassComponent).mass;
          const res2 = world.getComponent(e2, RestitutionComponent).restitution;

          const restitution = Math.min(res1, res2);
          const dir = new Vector2().subtractVectors(p2, p1);
          const dSq = dir.lengthSq();
          const rSum = r1 + r2;

          if (dSq == 0.0 || dSq > rSum * rSum) continue;

          const d = Math.sqrt(dSq);
          dir.scale(1.0 / d); // Normalize

          // Resolve penetration
          const corr = (rSum - d) / 2.0;
          p1.add(dir, -corr);
          p2.add(dir, corr);

          // Resolve velocity
          const vel1_dot = v1.dot(dir);
          const vel2_dot = v2.dot(dir);

          const newV1_dot = (m1 * vel1_dot + m2 * vel2_dot - m2 * (vel1_dot - vel2_dot) * restitution) / (m1 + m2);
          const newV2_dot = (m1 * vel1_dot + m2 * vel2_dot - m1 * (vel2_dot - vel1_dot) * restitution) / (m1 + m2);

          v1.add(dir, newV1_dot - vel1_dot);
          v2.add(dir, newV2_dot - vel2_dot);
        }
      }
    }
  }

  class PBDBallObstacleCollisions {
    runInPause = false;

    update(world, dt) {
      const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
      const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent]);
      for (const ballId of ballEntities) {
        const p1 = world.getComponent(ballId, PositionComponent).pos;
        const v1 = world.getComponent(ballId, VelocityComponent).vel;
        const r1 = world.getComponent(ballId, RadiusComponent).radius;

        for (const obsId of obstacleEntities) {
          const p2 = world.getComponent(obsId, PositionComponent).pos;
          const r2 = world.getComponent(obsId, RadiusComponent).radius;
          const pushVel = 2.0;

          const dir = new Vector2().subtractVectors(p1, p2);
          const dSq = dir.lengthSq();
          const rSum = r1 + r2;

          if (dSq == 0.0 || dSq > rSum * rSum) continue;

          const d = Math.sqrt(dSq);
          dir.scale(1.0 / d); // Normalize

          // Resolve penetration
          const corr = rSum - d;
          p1.add(dir, corr);

          // Resolve velocity (simple push)
          const v_dot = v1.dot(dir);
          v1.add(dir, pushVel - v_dot); // Impart obstacle's push velocity along normal
        }
      }
    }
  }

  class PBDCableConstraintSolver {
    runInPause = false;

    update(world, dt) {
      const pathEntities = world.query([CablePathComponent]);
      const epsilon = 1e-9; // Small value to avoid division by zero

      for (const pathId of pathEntities) {
        const path = world.getComponent(pathId, CablePathComponent);
        if (!path || path.jointEntities.length === 0) continue;

        // --- 1. Calculate Total Current Length and Overall Tension ---
        let totalCurrentLength = 0.0;
        for (let i = 0; i < path.jointEntities.length; i++) {
          const jointId = path.jointEntities[i];
          const joint = world.getComponent(jointId, CableJointComponent);
          if (!joint || !joint.isActive) continue;

          const currentSegmentLength = joint.attachmentPointA_world.distanceTo(joint.attachmentPointB_world);
          totalCurrentLength += currentSegmentLength;

          // Add stored length for the link *after* this joint (if it exists)
          if (path.linkTypes[i+1] === 'rolling') {
             totalCurrentLength += path.stored[i+1];
          }
        }

        let overallTension = 0.0;
        if (path.totalRestLength > epsilon) {
          overallTension = totalCurrentLength / path.totalRestLength;
        }

        // --- Calculate Total Inverse Mass for the Entire Path ---
        let pathTotalInvMass = 0.0;
        const uniqueEntities = new Set();
        for (const jointId of path.jointEntities) {
            const joint = world.getComponent(jointId, CableJointComponent);
            if (!joint || !joint.isActive) continue;

            const entityA = joint.entityA;
            const entityB = joint.entityB;

            if (!uniqueEntities.has(entityA)) {
                uniqueEntities.add(entityA);
                const massAComp = world.getComponent(entityA, MassComponent);
                if (massAComp) {
                    const massA = massAComp.mass;
                    pathTotalInvMass += (massA > 0 ? 1.0 / massA : 0.0);
                }
            }
            if (!uniqueEntities.has(entityB)) {
                uniqueEntities.add(entityB);
                const massBComp = world.getComponent(entityB, MassComponent);
                if (massBComp) {
                    const massB = massBComp.mass;
                    pathTotalInvMass += (massB > 0 ? 1.0 / massB : 0.0);
                }
            }
        }

        // If the entire path is immovable, skip corrections for this path
        if (pathTotalInvMass <= epsilon) {
            continue;
        }

        // --- Calculate Total Path Error ---
        const totalPathError = totalCurrentLength - path.totalRestLength;

        // --- 2. Iterate Through Joints and Apply Corrections ---
        // Apply correction only if the entire path is longer than its rest length
        if (totalPathError > epsilon) {
          for (const jointId of path.jointEntities) {
            const joint = world.getComponent(jointId, CableJointComponent);
            if (!joint || !joint.isActive) continue;

            const entityA = joint.entityA;
            const entityB = joint.entityB;
            const posAComp = world.getComponent(entityA, PositionComponent);
            const massAComp = world.getComponent(entityA, MassComponent);
            const velAComp = world.getComponent(entityA, VelocityComponent);
            const posBComp = world.getComponent(entityB, PositionComponent);
            const massBComp = world.getComponent(entityB, MassComponent);
            const velBComp = world.getComponent(entityB, VelocityComponent);

            // Check if necessary components exist
            if (!posAComp || !massAComp || !posBComp || !massBComp) {
              console.warn(`PBDCableConstraintSolver skipped joint ${jointId}: Missing Pos/Mass on entities ${entityA} or ${entityB}`);
              continue;
            }
            const posA = posAComp.pos;
            const massA = massAComp.mass;
            const velA = velAComp?.vel; // Velocity is optional for correction
            const posB = posBComp.pos;
            const massB = massBComp.mass;
            const velB = velBComp?.vel; // Velocity is optional for correction

            const invMassA = massA > 0 ? 1.0 / massA : 0.0;
            const invMassB = massB > 0 ? 1.0 / massB : 0.0;
            // Note: We use pathTotalInvMass calculated above, not the local totalInvMass

            // Use the attachment points calculated and cached by CableAttachmentUpdateSystem
            const pAttachA = joint.attachmentPointA_world;
            const pAttachB = joint.attachmentPointB_world;

            const dir = new Vector2().subtractVectors(pAttachB, pAttachA);
            const currentLength = dir.length();

            // We use the totalPathError calculated earlier, not individual joint error.
            // Apply correction if the joint has non-zero length (to avoid NaN with normalization)
            if (currentLength > epsilon) {
              dir.scale(1.0 / currentLength); // Normalize direction vector

              // Use the path's total error and total inverse mass for the correction magnitude
              const corr = totalPathError / pathTotalInvMass;

              // Calculate displacement vectors (Standard PBD)
              // Distribute correction based on individual inverse masses
              // Note: Sign convention depends on direction vector (pB - pA)
              const deltaA = dir.clone().scale(invMassA * corr);
              const deltaB = dir.clone().scale(-invMassB * corr);

              // Apply displacement to the entity positions.
              posA.add(deltaA);
              posB.add(deltaB);

              // Apply velocity correction (optional, but good for stability)
              if (velA && invMassA > 0 && dt > epsilon) {
                velA.add(deltaA, 1.0 / dt); // v_new = v_old + delta_p / dt
              }
              if (velB && invMassB > 0 && dt > epsilon) {
                velB.add(deltaB, 1.0 / dt); // v_new = v_old + delta_p / dt
              }
            } // End if currentLength > epsilon
          } // End loop through joints in path
        }  // End if totalPathError > epsilon
      } // End loop through paths
    } // end update
  } // end PBDCableConstraintSolver

  // --- System: Rendering ---
  class RenderSystem {
    runInPause = true; // Always render
    constructor(canvas, cScale, simHeight) {
      this.canvas = canvas;
      this.c = canvas.getContext("2d");
      this.baseCScale = cScale; // Original scale (pixels per sim unit at 1x zoom)
      this.simHeight = simHeight; // Original sim height (usually 2.0)

      // --- Viewport Settings ---
      this.viewScaleMultiplier = 1.6; // Zoom level (2.0 = 2x zoom)
      // Calculate the original full simulation width
      const originalSimWidth = this.canvas.width / this.baseCScale;
      // Set the horizontal offset in simulation units to center the middle half
      this.viewOffsetX_sim = 0.6;
      // Vertical offset (optional, keep 0 for now to center vertically at y=0)
      this.viewOffsetY_sim = 1.0;
      // --- End Viewport Settings ---

      // Calculate the effective scale used for drawing
      this.effectiveCScale = this.baseCScale * this.viewScaleMultiplier;
    }

    // Coordinate transformation helpers
    cX(simX) {
      // 1. Shift simulation coordinate relative to the view offset
      // 2. Scale by the effective scale
      return (simX - this.viewOffsetX_sim) * this.effectiveCScale;
    }
    cY(simY) {
      // 1. Shift simulation coordinate relative to the view offset
      // 2. Scale by the effective scale
      // 3. Flip Y and potentially adjust based on canvas height if needed (standard flip)
      // Note: Simple vertical centering at y=0 is assumed here.
      // For true vertical panning, this needs adjustment similar to cX.
      const scaledY = (simY - this.viewOffsetY_sim) * this.effectiveCScale;
      // Center the view vertically. We map simY=viewOffsetY_sim to canvas.height/2
      return this.canvas.height / 2.0 - scaledY;
       // Original simple flip: return this.canvas.height - scaledY;
    }

    // Use effective scale for radius
    drawDisc(simX, simY, simRadius) {
      this.c.beginPath();
      this.c.arc(
        this.cX(simX),
        this.cY(simY),
        simRadius * this.effectiveCScale, // Scale radius by zoom
        0.0, 2.0 * Math.PI
      );
      this.c.closePath();
      this.c.fill();
    }

    update(world, dt) {
      this.c.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Base line width and debug radius (adjust as needed)
      const baseLineWidth = 2;
      const baseDebugRadius = 3;

      // Render Balls
      const ballEntities = world.query([BallTagComponent, PositionComponent, RadiusComponent, RenderableComponent]);
      for (const entityId of ballEntities) {
        const posComp = world.getComponent(entityId, PositionComponent);
        const radiusComp = world.getComponent(entityId, RadiusComponent);
        const renderComp = world.getComponent(entityId, RenderableComponent);

        this.c.fillStyle = renderComp.color;
        // Use drawDisc with simulation coordinates/radius
        this.drawDisc(posComp.pos.x, posComp.pos.y, radiusComp.radius);
      }

      // Render Obstacles
      const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent, RenderableComponent]);
      for (const entityId of obstacleEntities) {
        const posComp = world.getComponent(entityId, PositionComponent);
        const radiusComp = world.getComponent(entityId, RadiusComponent);
        const renderComp = world.getComponent(entityId, RenderableComponent);

        this.c.fillStyle = renderComp.color;
        // Use drawDisc with simulation coordinates/radius
        this.drawDisc(posComp.pos.x, posComp.pos.y, radiusComp.radius);
      }

      // Render Cable Joints
      const jointEntities = world.query([CableJointComponent, RenderableComponent]);
      // Scale line width by zoom
      this.c.lineWidth = baseLineWidth * this.viewScaleMultiplier;
      for (const entityId of jointEntities) {
        const jointComp = world.getComponent(entityId, CableJointComponent);
        const renderComp = world.getComponent(entityId, RenderableComponent);

        if (!jointComp.isActive || renderComp.shape !== 'line') continue;

        const pA = jointComp.attachmentPointA_world;
        const pB = jointComp.attachmentPointB_world;

        if (pA.lengthSq() > 0 && pB.lengthSq() > 0) {
          this.c.strokeStyle = renderComp.color;
          this.c.beginPath();
          // Use transformed coordinates
          this.c.moveTo(this.cX(pA.x), this.cY(pA.y));
          this.c.lineTo(this.cX(pB.x), this.cY(pB.y));
          this.c.stroke();
        }
      }
      this.c.lineWidth = 1; // Reset line width (or keep scaled?)

      // Render Debug Points
      const debugPoints = world.getResource('debugRenderPoints');
      if (debugPoints) {
          // Keep debug points a constant pixel size, or scale them?
          const scaledDebugRadius = baseDebugRadius; // Option 1: Constant pixel size
          // const scaledDebugRadius = baseDebugRadius * this.viewScaleMultiplier; // Option 2: Scale with zoom
          this.c.save();
          for (const key in debugPoints) {
              const pointData = debugPoints[key];
              if (pointData && pointData.pos) {
                  this.c.fillStyle = pointData.color;
                  this.c.beginPath();
                  // Use transformed coordinates
                  this.c.arc(
                      this.cX(pointData.pos.x),
                      this.cY(pointData.pos.y),
                      scaledDebugRadius,
                      0, 2 * Math.PI
                  );
                  this.c.fill();
              }
          }
          this.c.restore();
      }
    }
  }


  // --- Global Setup ---
  const canvas = document.getElementById("myCanvas");

  canvas.width = window.innerWidth - 20;
  canvas.height = window.innerHeight - 100;

  const cScale = canvas.height/2;
  const simWidth = canvas.width / cScale;
  const simHeight = canvas.height / cScale;

  let world = new World();

  function setupScene() {
    world.clear(); // Clear entities and components

    // --- Resources ---
    world.setResource('gravity', new Vector2(0.0, -10.0));
    world.setResource('dt', 1.0 / 100.0);
    world.setResource('simWidth', simWidth);
    world.setResource('simHeight', simHeight);
    // Create a component for pause state and store it as a resource for easy access
    world.setResource('pauseState', new PauseStateComponent(true));
    world.setResource('debugRenderPoints', {}); // Initialize empty object for debug points


    // --- Entities and Components ---
    // Ball Entities
    const ballRadius = 0.03;
    const ballRestitution = 0.4; // Slightly higher for more bounce

    const ball1 = world.createEntity();
    world.addComponent(ball1, new BallTagComponent());
    world.addComponent(ball1, new PositionComponent(2.5*0.5, 1.1*0.5));
    world.addComponent(ball1, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball1, new RadiusComponent(ballRadius));
    world.addComponent(ball1, new MassComponent(0.1001));
    world.addComponent(ball1, new RestitutionComponent(ballRestitution));
    world.addComponent(ball1, new GravityAffectedComponent());
    world.addComponent(ball1, new RenderableComponent('circle', '#FF0000'));

    const ball2 = world.createEntity();
    world.addComponent(ball2, new BallTagComponent());
    world.addComponent(ball2, new PositionComponent(1.7*1.00, 2*0.3));
    world.addComponent(ball2, new VelocityComponent(-0.7, 0.0));
    world.addComponent(ball2, new RadiusComponent(ballRadius));
    world.addComponent(ball2, new MassComponent(0.1));
    world.addComponent(ball2, new RestitutionComponent(ballRestitution));
    world.addComponent(ball2, new GravityAffectedComponent());
    world.addComponent(ball2, new RenderableComponent('circle', '#00FF00'));

    // Obstacle Entities
    const obsColor = "#FF8000";
    const obs1 = world.createEntity();
    world.addComponent(obs1, new ObstacleTagComponent());
    world.addComponent(obs1, new PositionComponent(2*0.75, 2*0.75));
    world.addComponent(obs1, new MassComponent(-1.0));
    world.addComponent(obs1, new RadiusComponent(0.1));
    world.addComponent(obs1, new RenderableComponent('circle', obsColor));


    // --- Cable Setup ---
    // Path: ball1 -> obs1 -> ball2
    world.addComponent(obs1, new CableLinkComponent());
    world.addComponent(ball1, new CableLinkComponent());
    world.addComponent(ball2, new CableLinkComponent());

    // --- Calculate Initial Cable State ---
    // Need to compute initial attachment points and rest lengths
    // Get relevant components
    const pos_ball1 = world.getComponent(ball1, PositionComponent).pos;
    const link_ball1 = world.getComponent(ball1, CableLinkComponent);
    link_ball1.prevPos = pos_ball1.clone();
    const pos_obs1 = world.getComponent(obs1, PositionComponent).pos;
    const radius_obs1 = world.getComponent(obs1, RadiusComponent).radius;
    const cw_obs1 = true;
    const link_obs1 = world.getComponent(obs1, CableLinkComponent);
    link_obs1.prevPos = pos_obs1.clone();
    const pos_ball2 = world.getComponent(ball2, PositionComponent).pos;
    const link_ball2 = world.getComponent(ball2, CableLinkComponent);
    link_ball2.prevPos = pos_ball2.clone();

    // Calculate initial points for joint1 (ball1 attachment <-> obs1 rolling)
    const initialPoints1 = tangentFromPointToCircle(pos_ball1, pos_obs1, radius_obs1, cw_obs1);
    const initialPoints2 = tangentFromCircleToPoint(pos_ball2, pos_obs1, radius_obs1, cw_obs1);

    // Create Cable Joint Entities with correct initial rest lengths
    const joint1 = world.createEntity(); // ball1 <-> obs1
    const initialDist1 = initialPoints1.a_attach.clone().subtract(initialPoints1.a_circle).length();
    world.addComponent(joint1, new CableJointComponent(
      ball1, obs1, initialDist1, initialPoints1.a_attach, initialPoints1.a_circle)); // Order matters
    world.addComponent(joint1, new RenderableComponent('line', '#FF0000')); // Red line

    const joint2 = world.createEntity(); // obs1 <-> ball2
    const initialDist2 = initialPoints2.a_attach.clone().subtract(initialPoints2.a_circle).length();
    world.addComponent(joint2, new CableJointComponent(
      obs1, ball2, initialDist2, initialPoints2.a_circle, initialPoints2.a_attach)); // Order matters
    world.addComponent(joint2, new RenderableComponent('line', '#FFFF00')); // Yellow line

    const cablePath = world.createEntity();
    world.addComponent(cablePath, new CablePathComponent([joint1, joint2], ['attachment', 'rolling', 'attachment'], [true, true, true])); // Order matters


    // --- Systems Registration (Order Matters!) ---
    if (world.systems.length === 0) { // Only register systems once
      world.registerSystem(new GravitySystem());      // Applies gravity acceleration
      world.registerSystem(new MovementSystem());     // Updates position based on velocity

      // --- Cable Systems (Run BEFORE constraint solving) ---

      world.registerSystem(new PBDBallBallCollisions());
      world.registerSystem(new PBDBallObstacleCollisions());
      world.registerSystem(new CableAttachmentUpdateSystem()); // Updates attachment points and rest lengths
      world.registerSystem(new PBDCableConstraintSolver());

      world.registerSystem(new RenderSystem(canvas, cScale, simHeight)); // Draws everything
    }

    // Update button text based on initial pause state
    const pauseState = world.getResource('pauseState');
    pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
  }


  // --- Main Loop ---
  let lastTime = 0;
  let doStep = true;

  function loop(currentTime) {
    const dt = world.getResource('dt');
    const pauseState = world.getResource('pauseState');

    if (!pauseState.paused || doStep) {
      if (doStep) pauseState.paused = false;
      console.log("----------------------------------------------");
      world.update(dt);
      if (doStep) pauseState.paused = true;
      doStep = false;
    }

    requestAnimationFrame(loop);
  }

  // --- Event Listeners ---
  pauseBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const pauseState = world.getResource('pauseState');
    if (pauseState) {
      pauseState.paused = !pauseState.paused;
      pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
    }
  });

  resetBtn.addEventListener('click', (e) => {
    e.preventDefault();
    setupScene();
    const pauseState = world.getResource('pauseState');
    if (pauseState) pauseState.paused = true;
    pauseBtn.textContent = "Resume";
    doStep = true;
  });

  stepBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const pauseState = world.getResource('pauseState');
    if (pauseState && pauseState.paused) {
      doStep = true;
    }
  });

  // --- Start ---
  setupScene();
  requestAnimationFrame(loop);

</script>

</body>
</html>
