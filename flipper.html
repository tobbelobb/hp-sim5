<!DOCTYPE html>
<html>
<head>
    <title>ECS Pinball</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202020; font-family: sans-serif; }
        canvas { border: 1px solid black; display: block; margin: 10px auto; }
        #controls { text-align: center; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div id="controls">
        Score: <span id="score">0</span> |
        <button id="pauseBtn" tabindex="-1">Pause</button>
        <button id="resetBtn" tabindex="-1">Reset</button>
    </div>
    <canvas id="myCanvas"></canvas>

<script>

    // --- Utility: Vector2 ---
    // (Same as before, keep it separate as it's a fundamental data type)
    class Vector2 {
        constructor(x = 0.0, y = 0.0) { this.x = x; this.y = y; }
        set(v) { this.x = v.x; this.y = v.y; }
        clone() { return new Vector2(this.x, this.y); }
        add(v, s = 1.0) { this.x += v.x * s; this.y += v.y * s; return this; }
        addVectors(a, b) { this.x = a.x + b.x; this.y = a.y + b.y; return this; }
        subtract(v, s = 1.0) { this.x -= v.x * s; this.y -= v.y * s; return this; }
        subtractVectors(a, b) { this.x = a.x - b.x; this.y = a.y - b.y; return this; }
        length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        lengthSq() { return this.x * this.x + this.y * this.y; } // Optimization
        scale(s) { this.x *= s; this.y *= s; return this; }
        dot(v) { return this.x * v.x + this.y * v.y; }
        perp() { return new Vector2(-this.y, this.x); }
        normalize() { const l = this.length(); if (l > 0) this.scale(1.0 / l); return this; }
    }

    // --- Utility: Geometry ---
    function closestPointOnSegment(p, a, b) {
        const ab = new Vector2().subtractVectors(b, a);
        const ap = new Vector2().subtractVectors(p, a);
        let t = ap.dot(ab);
        if (t <= 0.0) return a.clone();
        const denom = ab.dot(ab);
        if (t >= denom) return b.clone();
        t = t / denom;
        return a.clone().add(ab, t);
    }

    // --- ECS Core ---
    class World {
        constructor() {
            this.entities = new Map(); // entityId -> Set<ComponentClass>
            this.components = new Map(); // ComponentClass -> Map<entityId, ComponentInstance>
            this.nextEntityId = 0;
            this.systems = [];
            this.resources = {}; // Global data like gravity, dt
        }

        createEntity() {
            const id = this.nextEntityId++;
            this.entities.set(id, new Set());
            return id;
        }

        addComponent(entityId, component) {
            const componentClass = component.constructor;
            if (!this.components.has(componentClass)) {
                this.components.set(componentClass, new Map());
            }
            this.components.get(componentClass).set(entityId, component);
            if (this.entities.has(entityId)) {
                this.entities.get(entityId).add(componentClass);
            } else {
                 console.warn(`Entity ${entityId} does not exist when adding ${componentClass.name}`);
            }
        }

        getComponent(entityId, componentClass) {
            const componentMap = this.components.get(componentClass);
            return componentMap ? componentMap.get(entityId) : undefined;
        }

        hasComponent(entityId, componentClass) {
             const componentMap = this.components.get(componentClass);
             return componentMap ? componentMap.has(entityId) : false;
        }

        removeComponent(entityId, componentClass) {
             const componentMap = this.components.get(componentClass);
             if (componentMap) {
                 componentMap.delete(entityId);
             }
             const entityComponents = this.entities.get(entityId);
             if (entityComponents) {
                 entityComponents.delete(componentClass);
             }
        }

        destroyEntity(entityId) {
            if (!this.entities.has(entityId)) return;
            for (const componentClass of this.entities.get(entityId)) {
                this.removeComponent(entityId, componentClass);
            }
            this.entities.delete(entityId);
        }

        query(componentClasses) {
            const entities = [];
            if (componentClasses.length === 0) return [];

            // Start with entities having the first component
            const firstComponentMap = this.components.get(componentClasses[0]);
            if (!firstComponentMap) return [];

            for (const entityId of firstComponentMap.keys()) {
                let hasAll = true;
                for (let i = 1; i < componentClasses.length; i++) {
                    if (!this.hasComponent(entityId, componentClasses[i])) {
                        hasAll = false;
                        break;
                    }
                }
                if (hasAll) {
                    entities.push(entityId);
                }
            }
            return entities;
        }

        registerSystem(system) {
            this.systems.push(system);
        }

        setResource(name, value) {
            this.resources[name] = value;
        }

        getResource(name) {
            return this.resources[name];
        }

        clear() {
             this.entities.clear();
             this.components.clear();
             this.nextEntityId = 0;
             // Keep systems and resources usually
        }

        update(dt) {
            const pauseState = this.getResource('pauseState');
            const isPaused = pauseState ? pauseState.paused : false;

            for (const system of this.systems) {
                if (system.update && (!system.runInPause && isPaused)) {
                    continue; // Skip non-pause systems if paused
                }
                 if (system.update) {
                    system.update(this, dt);
                 }
            }
            canvas.focus();
        }
    }

    // --- Components (Plain Data) ---

    class PositionComponent { constructor(x = 0, y = 0) { this.pos = new Vector2(x, y); } }
    class VelocityComponent { constructor(x = 0, y = 0) { this.vel = new Vector2(x, y); } }
    class RadiusComponent { constructor(radius = 0.1) { this.radius = radius; } }
    class MassComponent { constructor(mass = 1.0) { this.mass = mass; } }
    class RestitutionComponent { constructor(restitution = 0.5) { this.restitution = restitution; } }
    class GravityAffectedComponent { /* Tag component */ }
    class BallTagComponent { /* Tag component */ }
    class ScoredTagComponent { /* Tag component */ }
    class ObstacleTagComponent { /* Tag component */ }
    class FlipperTagComponent { /* Tag component */ }
    class BorderComponent { constructor(points = []) { this.points = points.map(p => p.clone()); } }
    class ScoreComponent { constructor(score = 0) { this.value = score; } }
    class PauseStateComponent { constructor(paused = true) { this.paused = paused; } }
    class OrientationComponent { constructor(angle = 0.0) { this.angle = angle; } } // Angle in radians
    class AngularVelocityComponent { constructor(velocity = 0.0) { this.angVel = velocity; } } // Radians per second
    class InertiaComponent { constructor(inertia = Infinity) { this.invInertia = inertia > 0 ? 1.0 / inertia : 0.0; } } // Store inverse inertia
    class WheelOrientationComponent { constructor(clockwisePreference = true) { this.clockwisePreference = clockwisePreference; } } // For tangent selection (Fig 3/4)

    // Defines how a cable interacts with this entity at a specific point
    class CableLinkComponent {
        constructor(type = 'attachment', spoolLength = 0.0) {
            this.type = type; // 'rolling', 'attachment', 'pinhole', 'hybrid'
            this.spoolLength = spoolLength; // Remaining length for hybrid/spool types
            // Cache previous world attachment point to calculate surface distance travelled (s1/s2)
            this.prevAttachmentPointWorld = new Vector2();
            this.currentAttachmentPointLocal = new Vector2(); // Updated by CableAttachmentUpdateSystem
        }
    }

    // Represents a single segment constraint between two entities
    class CableJointComponent {
        constructor(entityA, entityB, restLength = 1.0) {
            this.entityA = entityA;
            this.entityB = entityB;
            this.restLength = restLength; // dn - the dynamic maximum length
            this.isActive = true; // For merge/split logic
            // Cache world attachment points calculated by CableAttachmentUpdateSystem
            this.attachmentPointA_world = new Vector2();
            this.attachmentPointB_world = new Vector2();
        }
    }

    // Represents the entire cable path
    class CablePathComponent {
        constructor(jointEntities = []) {
            this.jointEntities = jointEntities; // Ordered list of CableJoint entity IDs
        }
    }


    class FlipperStateComponent {
        constructor(length, restAngle, maxRotation, angularVelocity) {
            this.length = length;
            this.restAngle = restAngle;
            this.maxRotation = Math.abs(maxRotation);
            this.sign = Math.sign(maxRotation); // Direction it rotates
            this.angularVelocity = angularVelocity;
            // Dynamic state
            this.rotation = 0.0; // Current rotation from restAngle
            this.currentAngularVelocity = 0.0; // Velocity in the last frame
            this.pressed = false; // Was it activated?
        }
    }

    class ObstaclePushComponent { constructor(pushVel = 2.0) { this.pushVel = pushVel; } }


    // Render-specific component (could be more complex)
    class RenderableComponent {
        constructor(shape = 'circle', color = '#888888') {
            this.shape = shape; // 'circle', 'flipper', 'border'
            this.color = color;
        }
    }

    // --- Systems (Logic) ---

    // --- System: Input --- (Simplified Click Handling)
    class InputSystem {
         runInPause = true; // Input should work even when paused to unpause/interact

         constructor(canvas) {
             this.canvas = canvas;
             this.clicks = [];
             this.releases = [];
             this.canvas.setAttribute('tabindex', '0');
             this.canvas.style.outline = 'none';
             this.canvas.focus();
             this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this)); // works for mouse and touch
             this.canvas.addEventListener('pointerup', this.handlePointerUp.bind(this));
             this.canvas.addEventListener('keydown', this.handleKeydown.bind(this));
             this.canvas.addEventListener('keyup', this.handleKeyup.bind(this));
         }

         handleKeyup(event) {
             if (event.key == 'ArrowLeft' || event.key == 'ArrowRight') {
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 if (flipperEntities.length < 2) {
                   return;
                 }
                 var firstPos = world.getComponent(flipperEntities[0], PositionComponent).pos;
                 var secondPos = world.getComponent(flipperEntities[1], PositionComponent).pos;
                 if (firstPos.x < secondPos.x) {
                     if (event.key == 'ArrowLeft') {
                       this.releases.push(firstPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.releases.push(secondPos);
                     }
                 } else {
                     if (event.key == 'ArrowLeft') {
                       this.releases.push(secondPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.releases.push(firstPos);
                     }
                 }
             }
         }

         handleKeydown(event) {
             if (event.key == 'ArrowLeft' || event.key == 'ArrowRight') {
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 if (flipperEntities.length < 2) {
                   return;
                 }
                 var firstPos = world.getComponent(flipperEntities[0], PositionComponent).pos;
                 var secondPos = world.getComponent(flipperEntities[1], PositionComponent).pos;
                 if (firstPos.x < secondPos.x) {
                     if (event.key == 'ArrowLeft') {
                       this.clicks.push(firstPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.clicks.push(secondPos);
                     }
                 } else {
                     if (event.key == 'ArrowLeft') {
                       this.clicks.push(secondPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.clicks.push(firstPos);
                     }
                 }
             }
         }

         handlePointerDown(event) {
             const rect = this.canvas.getBoundingClientRect();
             const scale = this.canvas.height / world.getResource('simHeight'); // Need access to world/scale somehow
             const simX = (event.clientX - rect.left) / scale;
             const simY = (this.canvas.height - (event.clientY - rect.top)) / scale;
             this.clicks.push(new Vector2(simX, simY));
         }

         handlePointerUp(event) {
             const rect = this.canvas.getBoundingClientRect();
             const scale = this.canvas.height / world.getResource('simHeight'); // Need access to world/scale somehow
             const simX = (event.clientX - rect.left) / scale;
             const simY = (this.canvas.height - (event.clientY - rect.top)) / scale;
             this.releases.push(new Vector2(simX, simY));
         }

         update(world, dt) {
             if (this.clicks.length === 0 && this.releases.length == 0) return;

             if (this.clicks.length > 0) {
                 const clickPos = this.clicks.shift(); // Process one click per frame for simplicity
                 // Find flippers and check if clicked near pivot
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 for (const entityId of flipperEntities) {
                     const pos = world.getComponent(entityId, PositionComponent).pos;
                     const state = world.getComponent(entityId, FlipperStateComponent);
                     // Simple distance check to pivot
                     if (clickPos.clone().subtract(pos).lengthSq() < state.length ** 2) { // Click near pivot activates
                          state.pressed = true;
                     }
                 }
             }

             if (this.releases.length > 0) {
                 const releasePos = this.releases.shift();
                 // Find flippers and check if released near pivot
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 for (const entityId of flipperEntities) {
                     const pos = world.getComponent(entityId, PositionComponent).pos;
                     const state = world.getComponent(entityId, FlipperStateComponent);
                     // Simple distance check to pivot
                     if (releasePos.clone().subtract(pos).lengthSq() < state.length ** 2) { // release near pivot activates
                          state.pressed = false;
                     }
                 }
             }

             // Could add logic here to interact with pause button entity if it existed
         }
    }


    // --- System: Flipper Motion ---
    class FlipperMotionSystem {
        runInPause = true;
        update(world, dt) {
            const flipperEntities = world.query([FlipperStateComponent]);
            for (const entityId of flipperEntities) {
                const state = world.getComponent(entityId, FlipperStateComponent);

                const prevRotation = state.rotation;
                if (state.pressed) {
                    state.rotation = Math.min(state.rotation + dt * state.angularVelocity, state.maxRotation);
                } else {
                    state.rotation = Math.max(state.rotation - dt * state.angularVelocity, 0.0);
                }
                // Avoid division by zero if dt is tiny
                state.currentAngularVelocity = (dt > 1e-6) ? state.sign * (state.rotation - prevRotation) / dt : 0.0;
            }
        }
    }

    // --- System: Gravity ---
    class GravitySystem {
        runInPause = false;
        update(world, dt) {
            const gravity = world.getResource('gravity');
            if (!gravity) return;

            const entities = world.query([VelocityComponent, GravityAffectedComponent]);
            for (const entityId of entities) {
                const velComp = world.getComponent(entityId, VelocityComponent);
                velComp.vel.add(gravity, dt);
            }
        }
    }

    // --- System: Movement ---
    class MovementSystem {
        runInPause = false;
        update(world, dt) {
            const entities = world.query([PositionComponent, VelocityComponent]);
            for (const entityId of entities) {
                const posComp = world.getComponent(entityId, PositionComponent);
                const velComp = world.getComponent(entityId, VelocityComponent);
                posComp.pos.add(velComp.vel, dt);
            }
        }
    }


    // --- System: Cable Attachment Update ---
    // Calculates tangent points and updates rest lengths (dn) BEFORE the main solver
    class CableAttachmentUpdateSystem {
        runInPause = false; // Physics system

        // Helper: Calculate tangent points between two circles (Algorithm 4 from paper)
        _tangentCircleCircle(p1, r1, wheelOrientation1, p2, r2, wheelOrientation2) {
            const dVec = new Vector2().subtractVectors(p2, p1);
            const dSq = dVec.lengthSq();
            const d = Math.sqrt(dSq);

            // Determine effective radii based on orientation matching
            let r, r_eff1, r_eff2;
            const orientationsEqual = wheelOrientation1.clockwisePreference === wheelOrientation2.clockwisePreference;
            if (orientationsEqual) {
                r = Math.abs(r2 - r1); // Difference for same winding
                r_eff1 = r1;
                r_eff2 = r2;
            } else {
                r = r1 + r2; // Sum for opposite winding
                r_eff1 = r1;
                r_eff2 = -r2; // Effectively flips the second radius sign for calculation
            }

            if (d <= r + 1e-6) { // Add tolerance for floating point
                 // Circles overlapping or tangent internally/externally in a way that doesn't allow the desired tangent
                 console.warn("Cable tangent calculation: Circles too close or overlapping. d=", d, "r=", r);
                 // Fallback: Return points on the line connecting centers, offset by radii along that line.
                 // This might not be the 'tangent' but prevents errors.
                 const dir = dVec.lengthSq() > 1e-9 ? dVec.clone().normalize() : new Vector2(1, 0); // Avoid normalizing zero vector
                 return {
                     a1: p1.clone().add(dir, r1),
                     a2: p2.clone().add(dir, -r2) // Move p2's point back along the center line
                 };
            }


            // Angle of the line connecting centers
            let alpha = Math.atan2(dVec.y, dVec.x);
            // Angle offset due to radii difference/sum
            const phi = Math.acos(r / d); // Use acos as per paper's geometry implied by Fig 3/4 logic

            let alpha1, alpha2;

            // Calculate angles based on relative orientations (Paper Appendix Alg 4 logic)
            if (orientationsEqual) {
                // External tangents
                // Determine which tangent pair based on clockwisePreference.
                // We need *one* consistent tangent based on the winding order implied by preferences.
                // Let's assume the preference dictates the "upper" or "lower" tangent relative to the center line.
                // If both CW, maybe they prefer the tangent that wraps "under" (alpha - (pi/2 - phi))?
                // If both CCW, maybe they prefer the tangent that wraps "over" (alpha + (pi/2 - phi))?
                // This needs a clearer definition based on Fig 3/4. Let's try one version:
                if (wheelOrientation1.clockwisePreference) { // Assume CW prefers "lower" tangent
                    alpha1 = alpha - (Math.PI / 2 - phi);
                    alpha2 = alpha - (Math.PI / 2 - phi);
                } else { // Assume CCW prefers "upper" tangent
                     alpha1 = alpha + (Math.PI / 2 - phi);
                     alpha2 = alpha + (Math.PI / 2 - phi);
                }
                 // TODO: Verify this interpretation of preference vs tangent selection.

            } else {
                // Internal tangents (crossed)
                // Again, preference should pick one of the two internal tangents.
                // If C1 is CW and C2 is CCW, which crossed tangent is preferred?
                // Let's try one combination based on the formula structure:
                 if (wheelOrientation1.clockwisePreference) { // C1 CW, C2 CCW
                    alpha1 = alpha - (Math.PI / 2 + phi); // C1 angle
                    alpha2 = alpha + (Math.PI / 2 + phi); // C2 angle (opposite side)
                } else { // C1 CCW, C2 CW
                    alpha1 = alpha + (Math.PI / 2 + phi); // C1 angle
                    alpha2 = alpha - (Math.PI / 2 + phi); // C2 angle (opposite side)
                }
                 // TODO: Verify this interpretation.
            }


            // Calculate attachment points using the angles
            const a1 = new Vector2(p1.x + r1 * Math.cos(alpha1), p1.y + r1 * Math.sin(alpha1));
            const a2 = new Vector2(p2.x + r2 * Math.cos(alpha2), p2.y + r2 * Math.sin(alpha2)); // Use original r2

            return { a1, a2 };
        }

        // Helper: Calculate distance moved along circle surface between two angles
        _arcLength(radius, angle_start, angle_end) {
             let deltaAngle = angle_end - angle_start;

             // Normalize angle difference to [-PI, PI] to get shortest arc
             while (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
             while (deltaAngle <= -Math.PI) deltaAngle += 2 * Math.PI;

             // The sign of deltaAngle now indicates the direction of the shortest rotation.
             // Positive deltaAngle = Counter-Clockwise rotation.
             // Negative deltaAngle = Clockwise rotation.
             return radius * deltaAngle; // Signed arc length
        }


        update(world, dt) {
            const jointEntities = world.query([CableJointComponent]);

            for (const jointId of jointEntities) {
                const joint = world.getComponent(jointId, CableJointComponent);
                if (!joint.isActive) continue;

                const entityA = joint.entityA;
                const entityB = joint.entityB;

                // Get components for Entity A
                const posA = world.getComponent(entityA, PositionComponent)?.pos;
                const orientCompA = world.getComponent(entityA, OrientationComponent); // Needed for s1 calc
                const radiusA = world.getComponent(entityA, RadiusComponent)?.radius; // Assume circle for now
                const wheelOrientA = world.getComponent(entityA, WheelOrientationComponent); // Assume exists if rolling
                const linkA = world.getComponent(entityA, CableLinkComponent);

                // Get components for Entity B
                const posB = world.getComponent(entityB, PositionComponent)?.pos;
                const orientCompB = world.getComponent(entityB, OrientationComponent); // Needed for s2 calc
                const radiusB = world.getComponent(entityB, RadiusComponent)?.radius; // Assume circle for now
                const wheelOrientB = world.getComponent(entityB, WheelOrientationComponent); // Assume exists if rolling
                const linkB = world.getComponent(entityB, CableLinkComponent);

                if (!posA || !linkA || !posB || !linkB) {
                    console.warn(`CableJoint ${jointId} missing required components on entities ${entityA} or ${entityB}`);
                    continue;
                }

                // Store previous world points before calculating new ones
                const prevAttachA_world = linkA.prevAttachmentPointWorld.clone();
                const prevAttachB_world = linkB.prevAttachmentPointWorld.clone();

                let attachmentA_current, attachmentB_current;
                let s1 = 0.0; // Signed distance travelled on surface A (+ve CCW, -ve CW)
                let s2 = 0.0; // Signed distance travelled on surface B (+ve CCW, -ve CW)

                // --- Calculate Current Attachment Points ---
                // TODO: Handle different link types (attachment, pinhole, general shapes)
                if (linkA.type === 'rolling' && linkB.type === 'rolling' && radiusA && wheelOrientA && radiusB && wheelOrientB) {
                    // --- Rolling <-> Rolling (Circle-Circle Tangent) ---
                    const tangents = this._tangentCircleCircle(posA, radiusA, wheelOrientA, posB, radiusB, wheelOrientB);
                    attachmentA_current = tangents.a1;
                    attachmentB_current = tangents.a2;

                    // --- Calculate Surface Distances (s1, s2) ---
                    // Requires knowing the angle change of the bodies themselves.
                    // We don't have previous orientation stored, nor angular velocity applied yet.
                    // Approximation: Calculate angle change based on previous vs current attachment point angles.
                    // This is inaccurate as it mixes body translation and rotation.
                    // A better approach needs AngularVelocityComponent and OrientationComponent updates integrated.
                    if (prevAttachA_world.lengthSq() > 0 && orientCompA) { // Check if initialized and orientation exists
                         const anglePrevA = Math.atan2(prevAttachA_world.y - posA.y, prevAttachA_world.x - posA.x);
                         const angleCurrA = Math.atan2(attachmentA_current.y - posA.y, attachmentA_current.x - posA.x);
                         s1 = this._arcLength(radiusA, anglePrevA, angleCurrA); // Signed arc length based on attachment point movement
                    }
                     if (prevAttachB_world.lengthSq() > 0 && orientCompB) {
                         const anglePrevB = Math.atan2(prevAttachB_world.y - posB.y, prevAttachB_world.x - posB.x);
                         const angleCurrB = Math.atan2(attachmentB_current.y - posB.y, attachmentB_current.x - posB.x);
                         s2 = this._arcLength(radiusB, anglePrevB, angleCurrB); // Signed arc length
                    }

                    // Store current points for next frame
                    // linkA.prevAttachmentPointWorld.set(attachmentA_current); // Moved after rest length update
                    // linkB.prevAttachmentPointWorld.set(attachmentB_current);

                } else if (linkA.type === 'attachment' && linkB.type === 'rolling' && radiusB && wheelOrientB) {
                    // --- Attachment <-> Rolling ---
                    // Attachment point A is just the position of entity A
                    attachmentA_current = posA.clone();
                    s1 = 0; // No surface travel on attachment point

                    // Find tangent from point A to circle B
                    // Simplified: Use Algorithm 3 logic (Tangent Point Circle) - needs implementation
                    // Placeholder: Use center of B for now
                    console.warn(`CableAttachmentUpdateSystem: Attachment-Rolling tangent not fully implemented for joint ${jointId}`);
                    attachmentB_current = posB.clone(); // Placeholder
                    s2 = 0; // Placeholder

                    // linkA.prevAttachmentPointWorld.set(attachmentA_current); // Moved after rest length update
                    // linkB.prevAttachmentPointWorld.set(attachmentB_current); // Update B's prev point

                } else if (linkA.type === 'rolling' && linkB.type === 'attachment' && radiusA && wheelOrientA) {
                     // --- Rolling <-> Attachment ---
                     attachmentB_current = posB.clone();
                     s2 = 0;

                     console.warn(`CableAttachmentUpdateSystem: Rolling-Attachment tangent not fully implemented for joint ${jointId}`);
                     attachmentA_current = posA.clone(); // Placeholder
                     s1 = 0; // Placeholder

                     // linkA.prevAttachmentPointWorld.set(attachmentA_current); // Update A's prev point
                     // linkB.prevAttachmentPointWorld.set(attachmentB_current); // Moved after rest length update

                } else if (linkA.type === 'attachment' && linkB.type === 'attachment') {
                    // --- Attachment <-> Attachment ---
                    attachmentA_current = posA.clone(); // Attach at center
                    attachmentB_current = posB.clone();
                    s1 = 0;
                    s2 = 0;
                     // No surface distance change for fixed attachments
                     // linkA.prevAttachmentPointWorld.set(attachmentA_current); // Moved after rest length update
                     // linkB.prevAttachmentPointWorld.set(attachmentB_current);

                } else {
                    // --- Other combinations (Pinhole, Hybrid, General Shapes) ---
                    console.warn(`CableAttachmentUpdateSystem: Unsupported link type combination for joint ${jointId}`);
                    attachmentA_current = posA.clone(); // Fallback
                    attachmentB_current = posB.clone(); // Fallback
                    s1 = 0;
                    s2 = 0;
                    // linkA.prevAttachmentPointWorld.set(attachmentA_current); // Moved after rest length update
                    // linkB.prevAttachmentPointWorld.set(attachmentB_current);
                }

                // --- Update Rest Length (dn) ---
                // dn+1 = dn + effect_of_s1 + effect_of_s2
                // The effect depends on whether the signed arc length s corresponds to winding or unwinding
                // for the specific tangent connection determined by wheel orientations.

                // Let's analyze Fig 2 Bottom Left:
                // - Both wheels CW preference (assumed).
                // - Both rotate CW. s1 < 0, s2 < 0 (using our _arcLength convention).
                // - Wheel A unwinds cable: Effect should be positive, proportional to |s1|.
                // - Wheel B winds cable: Effect should be negative, proportional to |s2|.
                // - Formula given: dn+1 = dn + s1 - s2. This implies s1 is positive unwound length, s2 is positive wound length.
                // This conflicts with our signed s convention.

                // Let's redefine s1, s2 as the *amount of cable released* from each wheel.
                // If wheel A (CW pref) rotates CW (negative deltaAngle), it *releases* cable. released_s1 = -s1 = +ve.
                // If wheel A (CW pref) rotates CCW (positive deltaAngle), it *takes up* cable. released_s1 = -s1 = -ve.
                // So, released_s1 = -s1 if CW pref, released_s1 = +s1 if CCW pref.
                // released_s1 = s1 * (wheelOrientA.clockwisePreference ? -1 : 1); // Check logic

                // Let's rethink based on the tangent calculation and winding direction.
                // The tangent calculation implicitly defines which side of the wheel the cable leaves/arrives.
                // We need to know if the rotation deltaAngle moves the tangent point *along* the cable path (winding)
                // or *against* the cable path (unwinding).

                // SIMPLIFICATION ATTEMPT 2: Use the paper's formula structure directly,
                // but calculate s1_paper and s2_paper as the *positive lengths* corresponding
                // to the arc travelled, and determine the signs based on winding/unwinding.

                let s1_effect = 0;
                let s2_effect = 0;

                // Determine winding/unwinding based on rotation direction (sign of s) and wheel preference.
                // This is complex and depends on the specific tangent chosen.
                // Example: If tangent leaves A "underneath" (due to CW pref), CW rotation (s1<0) should UNWIND. Effect = +|s1|.
                // Example: If tangent arrives at B "underneath" (due to CW pref), CW rotation (s2<0) should WIND. Effect = -|s2|.

                // Placeholder: Assume s1/s2 from _arcLength directly represent change for dn+1 = dn + s1 + s2 (like Fig 2 right)
                // This is likely incorrect for the general case but provides a starting point.
                 joint.restLength += s1 + s2; // Highly likely incorrect sign logic

                // Ensure rest length doesn't go negative (unless intended for spools)
                if (joint.restLength < 0) joint.restLength = 0;


                // Store calculated world attachment points in the joint component for the solver
                joint.attachmentPointA_world.set(attachmentA_current);
                joint.attachmentPointB_world.set(attachmentB_current);

                // Initialize prevAttachmentPointWorld on first run *after* calculating current points
                if (prevAttachA_world.lengthSq() === 0) {
                    linkA.prevAttachmentPointWorld.set(attachmentA_current);
                } else {
                    // Store current points for next frame (only if not first run)
                    linkA.prevAttachmentPointWorld.set(attachmentA_current);
                }
                 if (prevAttachB_world.lengthSq() === 0) {
                    linkB.prevAttachmentPointWorld.set(attachmentB_current);
                } else {
                     linkB.prevAttachmentPointWorld.set(attachmentB_current);
                }


                // TODO: Handle Hybrid link logic (check spoolLength, switch type)
                // TODO: Handle Merge/Split triggers (e.g., spoolLength < 0)
            }
        }
    }


    // --- System: Cable Pinhole System ---
    // Balances rest lengths across pinholes (Algorithm 1, lines 9-15)
    class CablePinholeSystem {
         runInPause = false;

         update(world, dt) {
             // Query for pinhole links. Need CablePathComponent to easily find adjacent joints.
             const cablePaths = world.query([CablePathComponent]);
             if (cablePaths.length === 0) return; // No paths defined

             // Iterate through all defined cable paths
             for (const pathId of cablePaths) {
                 const pathComp = world.getComponent(pathId, CablePathComponent);
                 const joints = pathComp.jointEntities;

                 // Iterate through the path looking for pinholes by checking link types at connection points
                 for (let i = 0; i < joints.length - 1; i++) {
                     const jointLeftId = joints[i];
                     const jointRightId = joints[i+1];

                     const jointLeft = world.getComponent(jointLeftId, CableJointComponent);
                     const jointRight = world.getComponent(jointRightId, CableJointComponent);

                     if (!jointLeft || !jointRight || !jointLeft.isActive || !jointRight.isActive) continue;

                     // The entity connecting these two joints is the potential pinhole
                     const potentialPinholeEntity = jointLeft.entityB; // Assumes joint connects A->B, B->C
                     if (potentialPinholeEntity !== jointRight.entityA) {
                          console.warn("Cable path inconsistency detected near joint", jointLeftId);
                          continue; // Skip if joints aren't connected as expected
                     }

                     const pinholeLink = world.getComponent(potentialPinholeEntity, CableLinkComponent);
                     if (!pinholeLink || pinholeLink.type !== 'pinhole') continue; // Not a pinhole connection

                     // --- Found a Pinhole: Apply Algorithm 1 logic ---

                     // Get current distances (d) - calculated using current attachment points from previous system
                     // Ensure attachment points are valid before calculating length
                     if (jointLeft.attachmentPointA_world.lengthSq() === 0 || jointLeft.attachmentPointB_world.lengthSq() === 0 ||
                         jointRight.attachmentPointA_world.lengthSq() === 0 || jointRight.attachmentPointB_world.lengthSq() === 0) {
                         console.warn(`Pinhole ${potentialPinholeEntity}: Skipping due to uninitialized attachment points on joints ${jointLeftId} or ${jointRightId}`);
                         continue;
                     }

                     const d_left = jointLeft.attachmentPointB_world.clone().subtract(jointLeft.attachmentPointA_world).length();
                     const d_right = jointRight.attachmentPointB_world.clone().subtract(jointRight.attachmentPointA_world).length();

                     // Get rest lengths (dn)
                     const dn_left = jointLeft.restLength;
                     const dn_right = jointRight.restLength;

                     // Algorithm 1, lines 11 & 13 logic: Transfer overstretch
                     const overstretch_left = d_left - dn_left;
                     const overstretch_right = d_right - dn_right;

                     let adjustment = 0;
                     const tolerance = 1e-6; // Tolerance for floating point comparisons

                     // If left side is tight (overstretched) and right has slack (or less overstretched)
                     if (overstretch_left > tolerance) {
                         // Amount to potentially transfer from right's slack or length
                         // Transfer amount is the overstretch, but capped by the available length on the other side
                         const transferAmount = Math.min(overstretch_left, Math.max(0, dn_right)); // Don't make dn_right negative
                         adjustment = transferAmount;
                     }
                     // If right side is tight (overstretched) and left has slack (or less overstretched)
                     else if (overstretch_right > tolerance) {
                          // Amount to potentially transfer from left's slack or length
                          const transferAmount = Math.min(overstretch_right, Math.max(0, dn_left)); // Don't make dn_left negative
                          adjustment = -transferAmount; // Negative because we transfer from left to right
                     }

                     // Apply the adjustment atomically if significant
                     if (Math.abs(adjustment) > 1e-9) {
                        jointLeft.restLength += adjustment;
                        jointRight.restLength -= adjustment;
                        // Clamp rest lengths to avoid negative values due to floating point errors
                        if (jointLeft.restLength < 0) jointLeft.restLength = 0;
                        if (jointRight.restLength < 0) jointRight.restLength = 0;
                     }
                 }
             }
         }
    }


    // --- System: PBD Constraint Solver ---
    // Handles both Collisions and Cable Joint constraints using PBD
    class PBDConstraintSolverSystem {
        runInPause = false;

        // --- Helper Functions (Keep existing ones) ---
        _getFlipperTip(flipperPos, flipperState) {
             const angle = flipperState.restAngle + flipperState.sign * flipperState.rotation;
             const dir = new Vector2(Math.cos(angle), Math.sin(angle));
             return flipperPos.clone().add(dir, flipperState.length);
        }

        update(world, dt) {
            const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
            const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent, ObstaclePushComponent]);
            const flipperEntities = world.query([FlipperTagComponent, PositionComponent, RadiusComponent, FlipperStateComponent, RestitutionComponent]);
            const borderEntities = world.query([BorderComponent]); // Should be only one

            // --- Ball-Ball Collisions ---
            for (let i = 0; i < ballEntities.length; i++) {
                for (let j = i + 1; j < ballEntities.length; j++) {
                    const e1 = ballEntities[i];
                    const e2 = ballEntities[j];

                    const p1 = world.getComponent(e1, PositionComponent).pos;
                    const v1 = world.getComponent(e1, VelocityComponent).vel;
                    const r1 = world.getComponent(e1, RadiusComponent).radius;
                    const m1 = world.getComponent(e1, MassComponent).mass;
                    const res1 = world.getComponent(e1, RestitutionComponent).restitution;

                    const p2 = world.getComponent(e2, PositionComponent).pos;
                    const v2 = world.getComponent(e2, VelocityComponent).vel;
                    const r2 = world.getComponent(e2, RadiusComponent).radius;
                    const m2 = world.getComponent(e2, MassComponent).mass;
                    const res2 = world.getComponent(e2, RestitutionComponent).restitution;

                    const restitution = Math.min(res1, res2);
                    const dir = new Vector2().subtractVectors(p2, p1);
                    const dSq = dir.lengthSq();
                    const rSum = r1 + r2;

                    if (dSq == 0.0 || dSq > rSum * rSum) continue;

                    const d = Math.sqrt(dSq);
                    dir.scale(1.0 / d); // Normalize

                    // Resolve penetration
                    const corr = (rSum - d) / 2.0;
                    p1.add(dir, -corr);
                    p2.add(dir, corr);

                    // Resolve velocity
                    const vel1_dot = v1.dot(dir);
                    const vel2_dot = v2.dot(dir);

                    const newV1_dot = (m1 * vel1_dot + m2 * vel2_dot - m2 * (vel1_dot - vel2_dot) * restitution) / (m1 + m2);
                    const newV2_dot = (m1 * vel1_dot + m2 * vel2_dot - m1 * (vel2_dot - vel1_dot) * restitution) / (m1 + m2);

                    v1.add(dir, newV1_dot - vel1_dot);
                    v2.add(dir, newV2_dot - vel2_dot);
                }
            }

            // --- Ball-Obstacle Collisions ---
             for (const ballId of ballEntities) {
                const p1 = world.getComponent(ballId, PositionComponent).pos;
                const v1 = world.getComponent(ballId, VelocityComponent).vel;
                const r1 = world.getComponent(ballId, RadiusComponent).radius;

                 for (const obsId of obstacleEntities) {
                     const p2 = world.getComponent(obsId, PositionComponent).pos;
                     const r2 = world.getComponent(obsId, RadiusComponent).radius;
                     const pushVel = world.getComponent(obsId, ObstaclePushComponent).pushVel;

                     const dir = new Vector2().subtractVectors(p1, p2);
                     const dSq = dir.lengthSq();
                     const rSum = r1 + r2;

                     if (dSq == 0.0 || dSq > rSum * rSum) continue;

                     const d = Math.sqrt(dSq);
                     dir.scale(1.0 / d); // Normalize

                     // Resolve penetration
                     const corr = rSum - d;
                     p1.add(dir, corr);

                     // Resolve velocity (simple push)
                     const v_dot = v1.dot(dir);
                     v1.add(dir, pushVel - v_dot); // Impart obstacle's push velocity along normal

                     // Add ScoredTagComponent to the ball that scored
                     world.addComponent(ballId, new ScoredTagComponent());
                 }
             }


             // --- Ball-Flipper Collisions ---
            for (const ballId of ballEntities) {
                const p1 = world.getComponent(ballId, PositionComponent).pos;
                const v1 = world.getComponent(ballId, VelocityComponent).vel;
                const r1 = world.getComponent(ballId, RadiusComponent).radius;
                // Ball restitution handled in border/ball-ball

                 for (const flipId of flipperEntities) {
                     const fp = world.getComponent(flipId, PositionComponent).pos;
                     const fr = world.getComponent(flipId, RadiusComponent).radius; // Flipper thickness/radius
                     const fs = world.getComponent(flipId, FlipperStateComponent);
                     // Note: Flipper restitution isn't used in the original logic this way,
                     // it simply imparts surface velocity. We'll stick to that.

                     const tip = this._getFlipperTip(fp, fs);
                     const closest = closestPointOnSegment(p1, fp, tip);

                     const dir = new Vector2().subtractVectors(p1, closest);
                     const dSq = dir.lengthSq();
                     const rSum = r1 + fr;

                     if (dSq == 0.0 || dSq > rSum * rSum) continue;

                     const d = Math.sqrt(dSq);
                     dir.scale(1.0 / d); // Normalize

                     // Resolve penetration
                     const corr = rSum - d;
                     p1.add(dir, corr);

                     // Resolve velocity - Calculate surface velocity at contact point
                     const radiusVec = closest.clone().subtract(fp); // Vector from pivot to contact point
                     // Add the penetration correction offset relative to the pivot
                     const contactPointOnFlipperSurface = fp.clone().add(radiusVec).add(dir, -fr); // Approx point on flipper surface
                     const radiusToSurface = contactPointOnFlipperSurface.subtract(fp);


                     // Velocity of the flipper surface at the contact point = w x r (angular velocity cross radius vector)
                     // In 2D, (0,0,w) x (rx, ry, 0) = (-w*ry, w*rx, 0)
                     const surfaceVel = new Vector2(-fs.currentAngularVelocity * radiusToSurface.y, fs.currentAngularVelocity * radiusToSurface.x);

                     // Project ball velocity and surface velocity onto the collision normal
                     const v_dot = v1.dot(dir);
                     const surfVel_dot = surfaceVel.dot(dir);

                     // Simple model: Make the ball's normal velocity match the flipper's surface normal velocity
                     // This effectively means v_new_dot = surfVel_dot
                     // More physically plausible might involve restitution e = (v_new_dot - surfVel_dot) / (surfVel_dot - v_dot)
                     // But sticking to original logic:
                     v1.add(dir, surfVel_dot - v_dot);

                 }
            }

            // --- Ball-Border Collisions ---
             if (borderEntities.length > 0) {
                 const borderId = borderEntities[0]; // Assume only one border
                 const borderComp = world.getComponent(borderId, BorderComponent);
                 const borderPoints = borderComp.points;

                 if (borderPoints.length >= 3) {
                     for (const ballId of ballEntities) {
                         const p1 = world.getComponent(ballId, PositionComponent).pos;
                         const v1 = world.getComponent(ballId, VelocityComponent).vel;
                         const r1 = world.getComponent(ballId, RadiusComponent).radius;
                         const res1 = world.getComponent(ballId, RestitutionComponent).restitution;

                         let minDistSq = Infinity;
                         let closestSegPoint = new Vector2();
                         let edgeNormal = new Vector2();
                         let edgeStart = null;
                         let edgeEnd = null;

                         // Find closest point on the entire border polygon
                         for (let i = 0; i < borderPoints.length; i++) {
                             const a = borderPoints[i];
                             const b = borderPoints[(i + 1) % borderPoints.length];
                             const closestPtOnSeg = closestPointOnSegment(p1, a, b);
                             const distSq = p1.clone().subtract(closestPtOnSeg).lengthSq();

                             if (distSq < minDistSq) {
                                 minDistSq = distSq;
                                 closestSegPoint.set(closestPtOnSeg);
                                 edgeStart = a;
                                 edgeEnd = b;
                             }
                         }

                         if (minDistSq > r1 * r1) continue; // Not colliding

                         // Calculate normal (outward-pointing assuming clockwise vertices)
                         const edgeVec = new Vector2().subtractVectors(edgeEnd, edgeStart);
                         const normal = edgeVec.perp().normalize(); // Points outwards for CW polygon

                         // Check if the ball center is outside the border (it should be!)
                         // If the closest point is a vertex, the normal needs careful handling,
                         // but for simple penetration resolution, using the segment normal is often okay.
                         const ballToClosest = new Vector2().subtractVectors(p1, closestSegPoint);
                         let collisionNormal = ballToClosest.clone();
                         if (collisionNormal.lengthSq() < 1e-9) {
                             // Ball center is exactly on the border segment, use edge normal
                             collisionNormal.set(normal);
                         } else {
                              collisionNormal.normalize();
                         }


                         // Ensure normal points from border towards ball
                         // Check if ball is roughly 'inside' the normal direction from the closest point
                         if (ballToClosest.dot(normal) < 0) {
                            // Ball might be inside corner, use segment normal but check distance
                            collisionNormal.set(normal); // Use segment normal for resolution
                         }


                         const dist = Math.sqrt(minDistSq);

                         // Resolve penetration
                         const penetration = r1 - dist;
                         if (penetration > 0) {
                             p1.add(collisionNormal, penetration);
                         }

                         // Resolve velocity
                         const v_dot = v1.dot(collisionNormal);
                         if (v_dot < 0) { // Only apply restitution if moving towards the wall
                             const v_new_dot = -v_dot * res1; // Reflect velocity component
                             v1.add(collisionNormal, v_new_dot - v_dot);
                         }
                     }
                 }
            } // end Ball-Border Collisions


            // --- Cable Joint Constraints ---
            const jointEntities = world.query([CableJointComponent]);
            for (const jointId of jointEntities) {
                const joint = world.getComponent(jointId, CableJointComponent);
                if (!joint.isActive) continue;

                const entityA = joint.entityA;
                const entityB = joint.entityB;

                // Get components (Position, Mass are essential for PBD)
                const posA = world.getComponent(entityA, PositionComponent)?.pos;
                const massA = world.getComponent(entityA, MassComponent)?.mass;
                const posB = world.getComponent(entityB, PositionComponent)?.pos;
                const massB = world.getComponent(entityB, MassComponent)?.mass;

                if (!posA || !massA || !posB || !massB) {
                    console.warn(`CableJoint ${jointId} constraint skipped: Missing Pos/Mass on entities ${entityA} or ${entityB}`);
                    continue;
                }

                const invMassA = massA > 0 ? 1.0 / massA : 0.0;
                const invMassB = massB > 0 ? 1.0 / massB : 0.0;
                const totalInvMass = invMassA + invMassB;

                if (totalInvMass <= 0.0) continue; // Both objects immovable

                // Use the attachment points calculated and cached by CableAttachmentUpdateSystem
                const pAttachA = joint.attachmentPointA_world;
                const pAttachB = joint.attachmentPointB_world;

                const dir = new Vector2().subtractVectors(pAttachB, pAttachA);
                const currentDist = dir.length();
                const restLength = joint.restLength; // dn

                // Constraint: currentDist <= restLength
                if (currentDist > restLength) {
                    const error = currentDist - restLength;
                    dir.normalize(); // Normalize direction vector

                    // Calculate position correction (PBD)
                    // deltaP = error * direction / totalInvMass
                    // Apply correction weighted by inverse mass
                    const correction = dir.scale(error / totalInvMass);

                    // Apply position corrections
                    // TODO: Account for rotation if attachment points are not centers
                    // Simple correction assuming attachment points move with entity centers:
                    posA.add(correction, invMassA);
                    posB.add(correction, -invMassB); // Move in opposite direction

                    // If handling rotation, the correction needs to be applied differently:
                    // deltaPosA = invMassA * correction
                    // deltaPosB = -invMassB * correction
                    // deltaRotA = invInertiaA * cross(radiusVecA, correction)
                    // deltaRotB = -invInertiaB * cross(radiusVecB, correction)
                    // This requires InertiaComponent and OrientationComponent updates.
                }
            } // end Cable Joint Constraints


        } // end update
    }


    class ScoreSystem {
        runInPause = false;

        update(world, dt) {
            // One entity is holding the global score
            const scoreEntity = world.query([ScoreComponent])[0]; // Shold be only one scoreEntity
            const scoreComp = scoreEntity !== undefined ? world.getComponent(scoreEntity, ScoreComponent) : null;

            // Multiple entities might have scored since the previous update
            const scoredEntities = world.query([ScoredTagComponent]);
            for (const scoredId of scoredEntities) {
               world.removeComponent(scoredId, ScoredTagComponent);
               scoreComp.value++;
            }
        }
    }


    // --- System: Score Display ---
    class ScoreDisplaySystem {
        runInPause = true; // Score should update even if paused? Or maybe not? Your call.
        constructor(elementId) {
            this.scoreElement = document.getElementById(elementId);
        }
        update(world, dt) {
            const scoreEntity = world.query([ScoreComponent])[0]; // Shold be only one scoreEntity
            if (scoreEntity !== undefined && this.scoreElement) {
                const scoreComp = world.getComponent(scoreEntity, ScoreComponent);
                this.scoreElement.textContent = scoreComp.value.toString();
            }
        }
    }

    // --- System: Rendering ---
    class RenderSystem {
        runInPause = true; // Always render
        constructor(canvas, cScale, simHeight) {
            this.canvas = canvas;
            this.c = canvas.getContext("2d");
            this.cScale = cScale;
            this.simHeight = simHeight; // Needed for y-flipping
        }

        // Coordinate transformation helpers
        cX(x) { return x * this.cScale; }
        cY(y) { return this.canvas.height - y * this.cScale; }

        drawDisc(x, y, radius) {
            this.c.beginPath();
            this.c.arc(x, y, radius, 0.0, 2.0 * Math.PI);
            this.c.closePath();
            this.c.fill();
        }

        update(world, dt) {
            this.c.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Render Border
            const borderEntities = world.query([BorderComponent, RenderableComponent]);
            if (borderEntities.length > 0) {
                 const borderComp = world.getComponent(borderEntities[0], BorderComponent);
                 const renderComp = world.getComponent(borderEntities[0], RenderableComponent);
                 const points = borderComp.points;
                 if (points.length >= 2) {
                    this.c.strokeStyle = renderComp.color;
                    this.c.lineWidth = 5; // Make this a component property?
                    this.c.beginPath();
                    let v = points[0];
                    this.c.moveTo(this.cX(v.x), this.cY(v.y));
                    for (let i = 1; i < points.length + 1; i++) {
                        v = points[i % points.length];
                        this.c.lineTo(this.cX(v.x), this.cY(v.y));
                    }
                    this.c.stroke();
                    this.c.lineWidth = 1;
                 }
            }


            // Render Balls
            const ballEntities = world.query([BallTagComponent, PositionComponent, RadiusComponent, RenderableComponent]);
            for (const entityId of ballEntities) {
                const posComp = world.getComponent(entityId, PositionComponent);
                const radiusComp = world.getComponent(entityId, RadiusComponent);
                const renderComp = world.getComponent(entityId, RenderableComponent);

                this.c.fillStyle = renderComp.color;
                this.drawDisc(this.cX(posComp.pos.x), this.cY(posComp.pos.y), radiusComp.radius * this.cScale);
            }

            // Render Obstacles
            const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent, RenderableComponent]);
            for (const entityId of obstacleEntities) {
                 const posComp = world.getComponent(entityId, PositionComponent);
                 const radiusComp = world.getComponent(entityId, RadiusComponent);
                 const renderComp = world.getComponent(entityId, RenderableComponent);

                 this.c.fillStyle = renderComp.color;
                 this.drawDisc(this.cX(posComp.pos.x), this.cY(posComp.pos.y), radiusComp.radius * this.cScale);
            }


            // Render Flippers
            const flipperEntities = world.query([FlipperTagComponent, PositionComponent, RadiusComponent, FlipperStateComponent, RenderableComponent]);
            for (const entityId of flipperEntities) {
                 const posComp = world.getComponent(entityId, PositionComponent);
                 const radiusComp = world.getComponent(entityId, RadiusComponent); // Flipper thickness
                 const stateComp = world.getComponent(entityId, FlipperStateComponent);
                 const renderComp = world.getComponent(entityId, RenderableComponent);

                 this.c.fillStyle = renderComp.color;

                 const pivotX = this.cX(posComp.pos.x);
                 const pivotY = this.cY(posComp.pos.y);
                 const angle = stateComp.restAngle + stateComp.sign * stateComp.rotation;

                 this.c.save(); // Save context state
                 this.c.translate(pivotX, pivotY);
                 this.c.rotate(-angle); // Rotate Coordinate System (negative because canvas y is down)

                 // Draw the flipper rectangle and circles
                 const flipperDrawLength = stateComp.length * this.cScale;
                 const flipperDrawRadius = radiusComp.radius * this.cScale;

                 this.c.fillRect(0.0, -flipperDrawRadius, flipperDrawLength, 2.0 * flipperDrawRadius);
                 this.drawDisc(0, 0, flipperDrawRadius); // At pivot
                 this.drawDisc(flipperDrawLength, 0, flipperDrawRadius); // At tip

                 this.c.restore(); // Restore context state
            }
        }
    }


    // --- Global Setup ---
    const canvas = document.getElementById("myCanvas");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetBtn = document.getElementById("resetBtn");

    canvas.width = window.innerWidth - 20;
    canvas.height = window.innerHeight - 100;

    const flipperHeight = 1.7; // Target simulation height for scaling
    const cScale = canvas.height / flipperHeight;
    const simWidth = canvas.width / cScale;
    const simHeight = canvas.height / cScale;

    let world = new World();

    function setupScene() {
         world.clear(); // Clear entities and components

        // --- Resources ---
        world.setResource('gravity', new Vector2(0.0, -3.0));
        world.setResource('dt', 1.0 / 60.0);
        world.setResource('simWidth', simWidth);
        world.setResource('simHeight', simHeight);
        // Create a component for pause state and store it as a resource for easy access
        world.setResource('pauseState', new PauseStateComponent(true));


        // --- Entities and Components ---

        const offset = 0.02;

        // Border Entity (Clockwise points for outward normal calc)
        const borderEntity = world.createEntity();
        const borderPoints = [
             new Vector2(0.74, 0.0),
             new Vector2(0.74, 0.25),
             new Vector2(1.0 - offset, 0.4),
             new Vector2(1.0 - offset, flipperHeight - offset),
             new Vector2(offset, flipperHeight - offset),
             new Vector2(offset, 0.4),
             new Vector2(0.26, 0.25),
             new Vector2(0.26, 0.0)
        ];
        world.addComponent(borderEntity, new BorderComponent(borderPoints));
        world.addComponent(borderEntity, new RenderableComponent('border', '#000000'));


        // Ball Entities
        const ballRadius = 0.03;
        const ballMass = Math.PI * ballRadius * ballRadius;
        const ballRestitution = 0.4; // Slightly higher for more bounce

        const ball1 = world.createEntity();
        world.addComponent(ball1, new BallTagComponent());
        world.addComponent(ball1, new PositionComponent(0.92, 0.5));
        world.addComponent(ball1, new VelocityComponent(-0.2, 3.5));
        world.addComponent(ball1, new RadiusComponent(ballRadius));
        world.addComponent(ball1, new MassComponent(ballMass));
        world.addComponent(ball1, new RestitutionComponent(ballRestitution));
        world.addComponent(ball1, new GravityAffectedComponent());
        world.addComponent(ball1, new RenderableComponent('circle', '#a0a0a0'));

        const ball2 = world.createEntity();
        world.addComponent(ball2, new BallTagComponent());
        world.addComponent(ball2, new PositionComponent(0.08, 0.5));
        world.addComponent(ball2, new VelocityComponent(0.2, 3.5));
        world.addComponent(ball2, new RadiusComponent(ballRadius));
        world.addComponent(ball2, new MassComponent(ballMass));
        world.addComponent(ball2, new RestitutionComponent(ballRestitution));
        world.addComponent(ball2, new GravityAffectedComponent());
        world.addComponent(ball2, new RenderableComponent('circle', '#a0a0a0'));

        // Obstacle Entities
        const obsColor = "#FF8000";
        const obsPush = 2.0;

        const obs1 = world.createEntity();
        world.addComponent(obs1, new ObstacleTagComponent());
        world.addComponent(obs1, new PositionComponent(0.25, 0.6));
        world.addComponent(obs1, new MassComponent(-1.0));
        world.addComponent(obs1, new RadiusComponent(0.1));
        world.addComponent(obs1, new ObstaclePushComponent(obsPush));
        world.addComponent(obs1, new RenderableComponent('circle', obsColor));

        const obs2 = world.createEntity();
        world.addComponent(obs2, new ObstacleTagComponent());
        world.addComponent(obs2, new PositionComponent(0.75, 0.5));
        world.addComponent(obs2, new MassComponent(-1.0));
        world.addComponent(obs2, new RadiusComponent(0.1));
        world.addComponent(obs2, new ObstaclePushComponent(obsPush));
        world.addComponent(obs2, new RenderableComponent('circle', obsColor));

        const obs3 = world.createEntity();
        world.addComponent(obs3, new ObstacleTagComponent());
        world.addComponent(obs3, new PositionComponent(0.7, 1.0));
        world.addComponent(obs3, new MassComponent(-1.0));
        world.addComponent(obs3, new RadiusComponent(0.12));
        world.addComponent(obs3, new ObstaclePushComponent(obsPush));
        world.addComponent(obs3, new RenderableComponent('circle', obsColor));

        const obs4 = world.createEntity();
        world.addComponent(obs4, new ObstacleTagComponent());
        world.addComponent(obs4, new PositionComponent(0.2, 1.2));
        world.addComponent(obs4, new MassComponent(-1.0));
        world.addComponent(obs4, new RadiusComponent(0.1));
        world.addComponent(obs4, new ObstaclePushComponent(obsPush));
        world.addComponent(obs4, new RenderableComponent('circle', obsColor));


        // Flipper Entities
        const flipRadius = 0.03; // Thickness
        const flipLength = 0.2;
        const flipMaxRotation = 1.0; // Radians
        const flipRestAngle = 0.5; // Radians from horizontal
        const flipAngularVelocity = 20.0; // Radians per second
        const flipColor = "#FF0000";
        const flipRestitution = 0.2;

        const flipper1 = world.createEntity();
        world.addComponent(flipper1, new FlipperTagComponent());
        world.addComponent(flipper1, new PositionComponent(0.26, 0.22));
        world.addComponent(flipper1, new RadiusComponent(flipRadius));
        world.addComponent(flipper1, new FlipperStateComponent(flipLength, -flipRestAngle, flipMaxRotation, flipAngularVelocity));
        world.addComponent(flipper1, new RestitutionComponent(flipRestitution));
        world.addComponent(flipper1, new RenderableComponent('flipper', flipColor));

        const flipper2 = world.createEntity();
        world.addComponent(flipper2, new FlipperTagComponent());
        world.addComponent(flipper2, new PositionComponent(0.74, 0.22));
        world.addComponent(flipper2, new RadiusComponent(flipRadius));
        world.addComponent(flipper2, new FlipperStateComponent(flipLength, Math.PI + flipRestAngle, -flipMaxRotation, flipAngularVelocity));
        world.addComponent(flipper2, new RestitutionComponent(flipRestitution));
        world.addComponent(flipper2, new RenderableComponent('flipper', flipColor));

        // Score Entity
        const scoreEntity = world.createEntity();
        world.addComponent(scoreEntity, new ScoreComponent(0));


        // --- Cable Setup ---
        // Connect: ball2 -> obs4 -> obs3 -> ball1
        // Entities involved: ball2, obs4, obs3, ball1
        // Obstacles need WheelOrientation and CableLink (rolling)
        // Balls need CableLink (attachment or rolling?) Let's use attachment for simplicity.

        // Add necessary components to obstacles (assuming they act as wheels)
        world.addComponent(obs4, new WheelOrientationComponent(true)); // Clockwise preference
        world.addComponent(obs4, new CableLinkComponent('rolling'));
        world.addComponent(obs3, new WheelOrientationComponent(true)); // Clockwise preference
        world.addComponent(obs3, new CableLinkComponent('rolling'));
        // Add CableLink to balls (as attachment points)
        world.addComponent(ball1, new CableLinkComponent('attachment'));
        world.addComponent(ball2, new CableLinkComponent('attachment'));

        // Create Cable Joint Entities
        const initialRestLengthSegment = 0.2; // Initial guess, will be dynamic

        const joint1 = world.createEntity(); // ball2 <-> obs4
        world.addComponent(joint1, new CableJointComponent(ball2, obs4, initialRestLengthSegment));

        const joint2 = world.createEntity(); // obs4 <-> obs3
        world.addComponent(joint2, new CableJointComponent(obs4, obs3, initialRestLengthSegment));

        const joint3 = world.createEntity(); // obs3 <-> ball1
        world.addComponent(joint3, new CableJointComponent(obs3, ball1, initialRestLengthSegment));

        // Optional: Create Cable Path Entity
        const cablePath = world.createEntity();
        world.addComponent(cablePath, new CablePathComponent([joint1, joint2, joint3]));


        // --- Systems Registration (Order Matters!) ---
        if (world.systems.length === 0) { // Only register systems once
             world.registerSystem(new InputSystem(canvas));
             world.registerSystem(new FlipperMotionSystem()); // Handles flipper input -> state change
             world.registerSystem(new GravitySystem());      // Applies gravity acceleration
             world.registerSystem(new MovementSystem());     // Updates position based on velocity

             // --- Cable Systems (Run BEFORE constraint solving) ---
             world.registerSystem(new CableAttachmentUpdateSystem()); // Updates attachment points and rest lengths
             world.registerSystem(new CablePinholeSystem());        // Balances rest lengths across pinholes (if any)

             // --- Constraint Solver (Handles collisions AND cable joints) ---
             world.registerSystem(new PBDConstraintSolverSystem()); // Resolves penetrations and cable length violations

             // --- Scoring and Rendering ---
             world.registerSystem(new ScoreSystem());             // Updates score based on tags
             world.registerSystem(new ScoreDisplaySystem('score')); // Displays score
             world.registerSystem(new RenderSystem(canvas, cScale, simHeight)); // Draws everything
        }

         // Update button text based on initial pause state
         const pauseState = world.getResource('pauseState');
         pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
    }


    // --- Main Loop ---
    let lastTime = 0;
    function gameLoop(currentTime) {
        const dt = world.getResource('dt'); // Use fixed timestep for stability
        // Alternative: Calculate actual elapsed time
        // const elapsed = (currentTime - lastTime) / 1000.0;
        // lastTime = currentTime;
        // const dt = Math.min(elapsed, 1.0 / 30.0); // Clamp max dt

        world.update(dt);

        requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners ---
    pauseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const pauseState = world.getResource('pauseState');
        if (pauseState) {
            pauseState.paused = !pauseState.paused;
            pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
        }
    });

    resetBtn.addEventListener('click', (e) => {
        e.preventDefault();
        setupScene(); // Re-initialize the world state
        // Ensure pause state resource is reset if needed
        const pauseState = world.getResource('pauseState');
        if (pauseState) pauseState.paused = true; // Start paused after reset
        pauseBtn.textContent = "Resume";
    });

    // --- Start ---
    setupScene();
    requestAnimationFrame(gameLoop);

</script>

</body>
</html>
