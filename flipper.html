<!DOCTYPE html>
<html>
<head>
    <title>ECS Pinball</title>
    <style>
        body {
            margin: 0;
            overflow-y: auto;
            background-color: #303030;
            font-family: sans-serif;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90vw;
            max-width: calc(90vh/1.7);
        }
        canvas {
            border: none;
            width: 100%;
            aspect-ratio: 1 / 1.7; /* Maintain aspect ratio (simWidth ~1.0 / simHeight 1.7) */
            max-height: calc(100vh - 120px);
            margin: auto;
        }
        #controls {
            width: 100%; /* Ensure controls take full width of container */
            text-align: center;
            margin-bottom: 10px;
            color: white;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="controls">
            Score: <span id="score">0</span> |
            <button id="pauseBtn" tabindex="-1">Pause</button>
            <button id="resetBtn" tabindex="-1">Reset</button>
            <button id="stepBtn">Step</button>
            <button id="dumpBtn" tabindex="-1">Dump State</button>
        </div>
        <canvas id="myCanvas"></canvas>
    </div>
<script src="cable_joints/cable_joints_core.js"></script>
<script>
    class OrientationComponent {
        constructor(angle = 0.0) {
            this.angle = angle; // Current angle in radians
            this.prevAngle = angle; // Angle at the start of the timestep
        }
    }
    class ScoreComponent { constructor(score = 0) { this.value = score; } }
    class FlipperTagComponent { }
    class ScoredTagComponent { }
    class BorderComponent { constructor(points = []) { this.points = points.map(p => p.clone()); } }
    class FlipperStateComponent {
        constructor(length, restAngle, maxRotation, angularVelocity) {
            this.length = length;
            this.restAngle = restAngle;
            this.maxRotation = Math.abs(maxRotation);
            this.sign = Math.sign(maxRotation); // Direction it rotates
            this.angularVelocity = angularVelocity;
            // Dynamic state
            this.rotation = 0.0; // Current rotation from restAngle
            this.currentAngularVelocity = 0.0; // Velocity in the last frame
            this.pressed = false; // Was it activated?
        }
    }
    class AngularVelocityComponent { constructor(velocity = 0.0) { this.angVel = velocity; } } // Radians per second
    class ObstaclePushComponent { constructor(pushVel = 2.0) { this.pushVel = pushVel; } }


    // --- System: Input --- (Simplified Click Handling)
    class InputSystem {
         runInPause = true; // Input should work even when paused to unpause/interact

         constructor(canvas) {
             this.canvas = canvas;
             this.clicks = [];
             this.releases = [];
             this.eventLog = [];     // ← record inputs per frame
             this.frame = 0;         // ← frame counter
             this.canvas.setAttribute('tabindex', '0');
             this.canvas.style.outline = 'none';
             this.canvas.focus();
             this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this)); // works for mouse and touch
             this.canvas.addEventListener('pointerup', this.handlePointerUp.bind(this));
             this.canvas.addEventListener('keydown', this.handleKeydown.bind(this));
             this.canvas.addEventListener('keyup', this.handleKeyup.bind(this));
         }

        // on Space → emit minimal debug dump
        dumpDebugScenario() {
            // Custom stringification to serialize Vector2 instances
            const resStr = JSON.stringify(world.resources);
            const logEntries = this.eventLog.map(frame => {
                const clicksStr = frame.clicks.map(p => `new Vector2(${p.x}, ${p.y})`).join(', ');
                const releasesStr = frame.releases.map(p => `new Vector2(${p.x}, ${p.y})`).join(', ');
                return `{ "frame": ${frame.frame}, "clicks": [${clicksStr}], "releases": [${releasesStr}] }`;
            }).join(', ');
            console.log('DEBUG_SCENARIO_DUMP', `{ "resources": ${resStr}, "inputLog": [${logEntries}] }`);
        }

         handleKeyup(event) {
             if (event.key == 'ArrowLeft' || event.key == 'ArrowRight') {
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 if (flipperEntities.length < 2) {
                   return;
                 }
                 var firstPos = world.getComponent(flipperEntities[0], PositionComponent).pos;
                 var secondPos = world.getComponent(flipperEntities[1], PositionComponent).pos;
                 if (firstPos.x < secondPos.x) {
                     if (event.key == 'ArrowLeft') {
                       this.releases.push(firstPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.releases.push(secondPos);
                     }
                 } else {
                     if (event.key == 'ArrowLeft') {
                       this.releases.push(secondPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.releases.push(firstPos);
                     }
                 }
             }
         }

         handleKeydown(event) {
             if (event.code === 'Space') {
                 this.dumpDebugScenario();
             }
             if (event.key == 'ArrowLeft' || event.key == 'ArrowRight') {
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 if (flipperEntities.length < 2) {
                   return;
                 }
                 var firstPos = world.getComponent(flipperEntities[0], PositionComponent).pos;
                 var secondPos = world.getComponent(flipperEntities[1], PositionComponent).pos;
                 if (firstPos.x < secondPos.x) {
                     if (event.key == 'ArrowLeft') {
                       this.clicks.push(firstPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.clicks.push(secondPos);
                     }
                 } else {
                     if (event.key == 'ArrowLeft') {
                       this.clicks.push(secondPos);
                     }
                     if  (event.key == 'ArrowRight') {
                       this.clicks.push(firstPos);
                     }
                 }
             }
         }

         handlePointerDown(event) {
             const rect = this.canvas.getBoundingClientRect();
             const scale = this.canvas.height / world.getResource('simHeight'); // Need access to world/scale somehow
             const simX = (event.clientX - rect.left) / scale;
             const simY = (this.canvas.height - (event.clientY - rect.top)) / scale;
             this.clicks.push(new Vector2(simX, simY));
         }

         handlePointerUp(event) {
             const rect = this.canvas.getBoundingClientRect();
             const scale = this.canvas.height / world.getResource('simHeight'); // Need access to world/scale somehow
             const simX = (event.clientX - rect.left) / scale;
             const simY = (this.canvas.height - (event.clientY - rect.top)) / scale;
             this.releases.push(new Vector2(simX, simY));
         }

         update(world, dt) {
             // snapshot and clear inputs each frame
             const clicksFrame = this.clicks.slice();
             const releasesFrame = this.releases.slice();
             if (clicksFrame.length > 0 || releasesFrame.length > 0) {
                 this.eventLog.push({ frame: this.frame, clicks: clicksFrame, releases: releasesFrame });
             }
             this.frame++;

             if (clicksFrame.length > 0) {
                 const clickPos = this.clicks.shift(); // Process one click per frame for simplicity
                 // Find flippers and check if clicked near pivot
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 for (const entityId of flipperEntities) {
                     const pos = world.getComponent(entityId, PositionComponent).pos;
                     const state = world.getComponent(entityId, FlipperStateComponent);
                     // Simple distance check to pivot
                     if (clickPos.clone().subtract(pos).lengthSq() < state.length ** 2) { // Click near pivot activates
                          state.pressed = true;
                     }
                 }
             }

             if (this.releases.length > 0) {
                 const releasePos = this.releases.shift();
                 // Find flippers and check if released near pivot
                 const flipperEntities = world.query([FlipperTagComponent, PositionComponent, FlipperStateComponent]);
                 for (const entityId of flipperEntities) {
                     const pos = world.getComponent(entityId, PositionComponent).pos;
                     const state = world.getComponent(entityId, FlipperStateComponent);
                     // Simple distance check to pivot
                     if (releasePos.clone().subtract(pos).lengthSq() < state.length ** 2) { // release near pivot activates
                          state.pressed = false;
                     }
                 }
             }

             // Could add logic here to interact with pause button entity if it existed
         }
    }


    // --- System: Flipper Motion ---
    class FlipperMotionSystem {
        runInPause = true;
        update(world, dt) {
            const flipperEntities = world.query([FlipperStateComponent]);
            for (const entityId of flipperEntities) {
                const state = world.getComponent(entityId, FlipperStateComponent);

                const prevRotation = state.rotation;
                if (state.pressed) {
                    state.rotation = Math.min(state.rotation + dt * state.angularVelocity, state.maxRotation);
                } else {
                    state.rotation = Math.max(state.rotation - dt * state.angularVelocity, 0.0);
                }
                // Avoid division by zero if dt is tiny
                state.currentAngularVelocity = (dt > 1e-6) ? state.sign * (state.rotation - prevRotation) / dt : 0.0;
            }
        }
    }

    class ScoreSystem {
        runInPause = false;

        update(world, dt) {
            // One entity is holding the global score
            const scoreEntity = world.query([ScoreComponent])[0]; // Shold be only one scoreEntity
            const scoreComp = scoreEntity !== undefined ? world.getComponent(scoreEntity, ScoreComponent) : null;

            // Multiple entities might have scored since the previous update
            const scoredEntities = world.query([ScoredTagComponent]);
            for (const scoredId of scoredEntities) {
               world.removeComponent(scoredId, ScoredTagComponent);
               scoreComp.value++;
            }
        }
    }


    // --- System: Score Display ---
    class ScoreDisplaySystem {
        runInPause = true; // Score should update even if paused? Or maybe not? Your call.
        constructor(elementId) {
            this.scoreElement = document.getElementById(elementId);
        }
        update(world, dt) {
            const scoreEntity = world.query([ScoreComponent])[0]; // Shold be only one scoreEntity
            if (scoreEntity !== undefined && this.scoreElement) {
                const scoreComp = world.getComponent(scoreEntity, ScoreComponent);
                this.scoreElement.textContent = scoreComp.value.toString();
            }
        }
    }

    class PBDBallFlipperCollisions {
      _getFlipperTip(flipperPos, flipperState) {
        const angle = flipperState.restAngle + flipperState.sign * flipperState.rotation;
        const dir = new Vector2(Math.cos(angle), Math.sin(angle));
        return flipperPos.clone().add(dir, flipperState.length);
      }

      update(world, dt) {
        const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
        const flipperEntities = world.query([FlipperTagComponent, PositionComponent, RadiusComponent, FlipperStateComponent, RestitutionComponent]);
        for (const ballId of ballEntities) {
          const p1 = world.getComponent(ballId, PositionComponent).pos;
          const v1 = world.getComponent(ballId, VelocityComponent).vel;
          const r1 = world.getComponent(ballId, RadiusComponent).radius;
          // Ball restitution handled in border/ball-ball

          for (const flipId of flipperEntities) {
            const fp = world.getComponent(flipId, PositionComponent).pos;
            const fr = world.getComponent(flipId, RadiusComponent).radius; // Flipper thickness/radius
            const fs = world.getComponent(flipId, FlipperStateComponent);

            const tip = this._getFlipperTip(fp, fs);
            const closest = closestPointOnSegment(p1, fp, tip);

            const dir = new Vector2().subtractVectors(p1, closest);
            const dSq = dir.lengthSq();
            const rSum = r1 + fr;

            if (dSq == 0.0 || dSq > rSum * rSum) continue;

            const d = Math.sqrt(dSq);
            dir.scale(1.0 / d); // Normalize

            // Resolve penetration
            const corr = rSum - d;
            p1.add(dir, corr);

            // Resolve velocity - Calculate surface velocity at contact point
            const radiusVec = closest.clone().subtract(fp); // Vector from pivot to contact point
            // Add the penetration correction offset relative to the pivot
            const contactPointOnFlipperSurface = fp.clone().add(radiusVec).add(dir, -fr); // Approx point on flipper surface
            const radiusToSurface = contactPointOnFlipperSurface.subtract(fp);


            // Velocity of the flipper surface at the contact point = w x r (angular velocity cross radius vector)
            // In 2D, (0,0,w) x (rx, ry, 0) = (-w*ry, w*rx, 0)
            const surfaceVel = new Vector2(-fs.currentAngularVelocity * radiusToSurface.y, fs.currentAngularVelocity * radiusToSurface.x);

            // Project ball velocity and surface velocity onto the collision normal
            const v_dot = v1.dot(dir);
            const surfVel_dot = surfaceVel.dot(dir);

            // Simple model: Make the ball's normal velocity match the flipper's surface normal velocity
            // This effectively means v_new_dot = surfVel_dot
            // More physically plausible might involve restitution e = (v_new_dot - surfVel_dot) / (surfVel_dot - v_dot)
            // But sticking to original logic:
            v1.add(dir, surfVel_dot - v_dot);

          }
        }
      }
    }

    class PBDBallBorderCollisions {
      update(world, dt) {
        const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
        const borderEntities = world.query([BorderComponent]);
        if (borderEntities.length > 0) {
          const borderId = borderEntities[0]; // Assume only one border
          const borderComp = world.getComponent(borderId, BorderComponent);
          const borderPoints = borderComp.points;

          if (borderPoints.length >= 3) {
            for (const ballId of ballEntities) {
              const p1 = world.getComponent(ballId, PositionComponent).pos;
              const v1 = world.getComponent(ballId, VelocityComponent).vel;
              const r1 = world.getComponent(ballId, RadiusComponent).radius;
              const res1 = world.getComponent(ballId, RestitutionComponent).restitution;

              let minDistSq = Infinity;
              let closestSegPoint = new Vector2();
              let edgeNormal = new Vector2();
              let edgeStart = null;
              let edgeEnd = null;

              // Find closest point on the entire border polygon
              for (let i = 0; i < borderPoints.length; i++) {
                const a = borderPoints[i];
                const b = borderPoints[(i + 1) % borderPoints.length];
                const closestPtOnSeg = closestPointOnSegment(p1, a, b);
                const distSq = p1.clone().subtract(closestPtOnSeg).lengthSq();

                if (distSq < minDistSq) {
                  minDistSq = distSq;
                  closestSegPoint.set(closestPtOnSeg);
                  edgeStart = a;
                  edgeEnd = b;
                }
              }

              if (minDistSq > r1 * r1) continue; // Not colliding

              // Calculate normal (outward-pointing assuming clockwise vertices)
              const edgeVec = new Vector2().subtractVectors(edgeEnd, edgeStart);
              const normal = edgeVec.perp().normalize(); // Points outwards for CW polygon

              // Check if the ball center is outside the border (it should be!)
              // If the closest point is a vertex, the normal needs careful handling,
              // but for simple penetration resolution, using the segment normal is often okay.
              const ballToClosest = new Vector2().subtractVectors(p1, closestSegPoint);
              let collisionNormal = ballToClosest.clone();
              if (collisionNormal.lengthSq() < 1e-9) {
                // Ball center is exactly on the border segment, use edge normal
                collisionNormal.set(normal);
              } else {
                collisionNormal.normalize();
              }


              // Ensure normal points from border towards ball
              // Check if ball is roughly 'inside' the normal direction from the closest point
              if (ballToClosest.dot(normal) < 0) {
                // Ball might be inside corner, use segment normal but check distance
                collisionNormal.set(normal); // Use segment normal for resolution
              }


              const dist = Math.sqrt(minDistSq);

              // Resolve penetration
              const penetration = r1 - dist;
              if (penetration > 0) {
                p1.add(collisionNormal, penetration);
              }

              // Resolve velocity
              const v_dot = v1.dot(collisionNormal);
              if (v_dot < 0) { // Only apply restitution if moving towards the wall
                const v_new_dot = -v_dot * res1; // Reflect velocity component
                v1.add(collisionNormal, v_new_dot - v_dot);
              }
            }
          }
        }
      }
    }

    class PBDBallObstacleCollisions2 {
      update(world, dt) {
        const ballEntities = world.query([BallTagComponent, PositionComponent, VelocityComponent, RadiusComponent, MassComponent, RestitutionComponent]);
        const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent, ObstaclePushComponent]);
        for (const ballId of ballEntities) {
          const p1 = world.getComponent(ballId, PositionComponent).pos;
          const v1 = world.getComponent(ballId, VelocityComponent).vel;
          const r1 = world.getComponent(ballId, RadiusComponent).radius;

          for (const obsId of obstacleEntities) {
            const p2 = world.getComponent(obsId, PositionComponent).pos;
            const r2 = world.getComponent(obsId, RadiusComponent).radius;
            const pushVel = world.getComponent(obsId, ObstaclePushComponent).pushVel;

            const dir = new Vector2().subtractVectors(p1, p2);
            const dSq = dir.lengthSq();
            const rSum = r1 + r2;

            if (dSq == 0.0 || dSq > rSum * rSum) continue;

            const d = Math.sqrt(dSq);
            dir.scale(1.0 / d); // Normalize

            // Resolve penetration
            const corr = rSum - d;
            p1.add(dir, corr);

            // Resolve velocity (simple push)
            const v_dot = v1.dot(dir);
            v1.add(dir, pushVel - v_dot); // Impart obstacle's push velocity along normal

            // Add ScoredTagComponent to the ball that scored
            world.addComponent(ballId, new ScoredTagComponent());
          }
        }
      }
    }


    // --- System: Rendering ---
    class RenderSystem2 {
      runInPause = true; // Always render
      constructor(canvas, cScale, simHeight) {
        this.canvas = canvas;
        this.c = canvas.getContext("2d");
        this.cScale = cScale;
        this.simHeight = simHeight; // Needed for y-flipping
      }

      // Coordinate transformation helpers
      cX(x) { return x * this.cScale; }
      cY(y) { return this.canvas.height - y * this.cScale; }

      drawDisc(x, y, radius) {
        this.c.beginPath();
        this.c.arc(x, y, radius, 0.0, 2.0 * Math.PI);
        this.c.closePath();
        this.c.fill();
      }

      update(world, dt) {
        this.c.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Render Border
        const borderEntities = world.query([BorderComponent, RenderableComponent]);
        if (borderEntities.length > 0) {
          const borderComp = world.getComponent(borderEntities[0], BorderComponent);
          const renderComp = world.getComponent(borderEntities[0], RenderableComponent);
          const points = borderComp.points;
          if (points.length >= 2) {
            this.c.strokeStyle = renderComp.color;
            this.c.lineWidth = 5; // Make this a component property?
            this.c.beginPath();
            let v = points[0];
            this.c.moveTo(this.cX(v.x), this.cY(v.y));
            for (let i = 1; i < points.length + 1; i++) {
              v = points[i % points.length];
              this.c.lineTo(this.cX(v.x), this.cY(v.y));
            }
            this.c.stroke();
            this.c.lineWidth = 1;
          }
        }


        // Render Balls
        const ballEntities = world.query([BallTagComponent, PositionComponent, RadiusComponent, RenderableComponent]);
        for (const entityId of ballEntities) {
          const posComp = world.getComponent(entityId, PositionComponent);
          const radiusComp = world.getComponent(entityId, RadiusComponent);
          const renderComp = world.getComponent(entityId, RenderableComponent);

          this.c.fillStyle = renderComp.color;
          this.drawDisc(this.cX(posComp.pos.x), this.cY(posComp.pos.y), radiusComp.radius * this.cScale);
        }

        // Render Obstacles
        const obstacleEntities = world.query([ObstacleTagComponent, PositionComponent, RadiusComponent, RenderableComponent]);
        for (const entityId of obstacleEntities) {
          const posComp = world.getComponent(entityId, PositionComponent);
          const radiusComp = world.getComponent(entityId, RadiusComponent);
          const renderComp = world.getComponent(entityId, RenderableComponent);

          this.c.fillStyle = renderComp.color;
          this.drawDisc(this.cX(posComp.pos.x), this.cY(posComp.pos.y), radiusComp.radius * this.cScale);
        }


        // Render Flippers
        const flipperEntities = world.query([FlipperTagComponent, PositionComponent, RadiusComponent, FlipperStateComponent, RenderableComponent]);
        for (const entityId of flipperEntities) {
          const posComp = world.getComponent(entityId, PositionComponent);
          const radiusComp = world.getComponent(entityId, RadiusComponent); // Flipper thickness
          const stateComp = world.getComponent(entityId, FlipperStateComponent);
          const renderComp = world.getComponent(entityId, RenderableComponent);

          this.c.fillStyle = renderComp.color;

          const pivotX = this.cX(posComp.pos.x);
          const pivotY = this.cY(posComp.pos.y);
          const angle = stateComp.restAngle + stateComp.sign * stateComp.rotation;

          this.c.save(); // Save context state
          this.c.translate(pivotX, pivotY);
          this.c.rotate(-angle); // Rotate Coordinate System (negative because canvas y is down)

          // Draw the flipper rectangle and circles
          const flipperDrawLength = stateComp.length * this.cScale;
          const flipperDrawRadius = radiusComp.radius * this.cScale;

          this.c.fillRect(0.0, -flipperDrawRadius, flipperDrawLength, 2.0 * flipperDrawRadius);
          this.drawDisc(0, 0, flipperDrawRadius); // At pivot
          this.drawDisc(flipperDrawLength, 0, flipperDrawRadius); // At tip

          this.c.restore(); // Restore context state
        }

        // Render Cable Joints
        const jointEntities = world.query([CableJointComponent, RenderableComponent]);
        this.c.strokeStyle = '#FFFF00'; // Default yellow, could use component color
        this.c.lineWidth = 2;
        for (const entityId of jointEntities) {
          const jointComp = world.getComponent(entityId, CableJointComponent);
          const renderComp = world.getComponent(entityId, RenderableComponent); // Get render comp for color/shape check

          if (!jointComp.isActive || renderComp.shape !== 'line') continue; // Skip inactive or non-line joints

          // Use cached world attachment points
          const pA = jointComp.attachmentPointA_world;
          const pB = jointComp.attachmentPointB_world;

          // Check if points are valid (initialized)
          if (pA.lengthSq() > 0 && pB.lengthSq() > 0) {
            this.c.strokeStyle = renderComp.color; // Use component's color
            this.c.beginPath();
            this.c.moveTo(this.cX(pA.x), this.cY(pA.y));
            this.c.lineTo(this.cX(pB.x), this.cY(pB.y));
            this.c.stroke();
          }
        }
        this.c.lineWidth = 1; // Reset line width


      }
    }

    // --- Global Setup ---
    const canvas = document.getElementById("myCanvas");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const stepBtn = document.getElementById("stepBtn");

    // --- Global World ---
    let world = new World();
    let renderSystemInstance = null; // Hold reference to render system

    // --- Scene Setup ---
    function setupScene() {
        world.clear(); // Clear entities and components

        // --- Set Canvas Size from CSS ---
        // Match drawing buffer size to the CSS display size
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        // --- Calculate Simulation Dimensions & Scale ---
        const simHeight = 1.7; // Target simulation height remains fixed
        const cScale = canvas.height / simHeight; // Calculate scale based on actual height
        const simWidth = canvas.width / cScale; // Calculate sim width based on actual width and scale

        console.log(`Canvas: ${canvas.width}x${canvas.height}, Sim: ${simWidth.toFixed(2)}x${simHeight.toFixed(2)}, Scale: ${cScale.toFixed(2)}`);


        // --- Resources ---
        world.setResource('gravity', new Vector2(0.0, -3.0));
        world.setResource('dt', 1.0 / 100.0);
        world.setResource('simWidth', simWidth);
        world.setResource('simHeight', simHeight); // Store the reference simHeight
        world.setResource('pauseState', new PauseStateComponent(true));
        world.setResource('debugRenderPoints', {}); // Initialize debug points resource
        world.setResource('errorState', new SimulationErrorStateComponent(false)); // Initialize error state


        // --- Entities and Components ---

        const offset = 0.02;

        // Border Entity (Clockwise points for outward normal calc)
        const borderEntity = world.createEntity();
        const borderPoints = [
             new Vector2(0.74, 0.0),
             new Vector2(0.74, 0.25),
             new Vector2(1.0 - offset, 0.4),
             new Vector2(1.0 - offset, simHeight - offset),
             new Vector2(offset, simHeight - offset),
             new Vector2(offset, 0.4),
             new Vector2(0.26, 0.25),
             new Vector2(0.26, 0.0)
        ];
        world.addComponent(borderEntity, new BorderComponent(borderPoints));
        world.addComponent(borderEntity, new RenderableComponent('border', '#000000'));


        // Ball Entities
        const ballRadius = 0.03;
        const ballMass = Math.PI * ballRadius * ballRadius;
        const ballRestitution = 0.4; // Slightly higher for more bounce

        const ball1 = world.createEntity();
        world.addComponent(ball1, new BallTagComponent());
        world.addComponent(ball1, new PositionComponent(0.92, 0.5));
        world.addComponent(ball1, new VelocityComponent(0.0, 0.0));
        world.addComponent(ball1, new RadiusComponent(ballRadius));
        world.addComponent(ball1, new MassComponent(ballMass));
        world.addComponent(ball1, new RestitutionComponent(ballRestitution));
        world.addComponent(ball1, new GravityAffectedComponent());
        world.addComponent(ball1, new RenderableComponent('circle', '#a0a0a0'));

        const ball2 = world.createEntity();
        world.addComponent(ball2, new BallTagComponent());
        world.addComponent(ball2, new PositionComponent(0.08, 0.5));
        world.addComponent(ball2, new VelocityComponent(0.0, 0.0));
        world.addComponent(ball2, new RadiusComponent(ballRadius));
        world.addComponent(ball2, new MassComponent(ballMass));
        world.addComponent(ball2, new RestitutionComponent(ballRestitution));
        world.addComponent(ball2, new GravityAffectedComponent());
        world.addComponent(ball2, new RenderableComponent('circle', '#a0a0a0'));

        // Obstacle Entities
        const obsColor1 = "#FF8000";
        const obsColor2 = "#0F7090";
        const obsPush = 2.0;

        const obs1 = world.createEntity();
        world.addComponent(obs1, new ObstacleTagComponent());
        world.addComponent(obs1, new PositionComponent(0.25, 0.6));
        world.addComponent(obs1, new MassComponent(-1.0));
        world.addComponent(obs1, new RadiusComponent(0.1));
        world.addComponent(obs1, new ObstaclePushComponent(obsPush));
        world.addComponent(obs1, new RenderableComponent('circle', obsColor2));

        const obs2 = world.createEntity();
        world.addComponent(obs2, new ObstacleTagComponent());
        world.addComponent(obs2, new PositionComponent(0.75, 0.5));
        world.addComponent(obs2, new MassComponent(-1.0));
        world.addComponent(obs2, new RadiusComponent(0.1));
        world.addComponent(obs2, new ObstaclePushComponent(obsPush));
        world.addComponent(obs2, new RenderableComponent('circle', obsColor2));

        const obs3 = world.createEntity();
        world.addComponent(obs3, new ObstacleTagComponent());
        world.addComponent(obs3, new PositionComponent(0.7, 1.0));
        world.addComponent(obs3, new MassComponent(-1.0));
        world.addComponent(obs3, new RadiusComponent(0.12));
        world.addComponent(obs3, new ObstaclePushComponent(obsPush));
        world.addComponent(obs3, new RenderableComponent('circle', obsColor1));

        const obs4 = world.createEntity();
        world.addComponent(obs4, new ObstacleTagComponent());
        world.addComponent(obs4, new PositionComponent(0.2, 1.2));
        world.addComponent(obs4, new MassComponent(-1.0));
        world.addComponent(obs4, new RadiusComponent(0.1));
        world.addComponent(obs4, new ObstaclePushComponent(obsPush));
        world.addComponent(obs4, new RenderableComponent('circle', obsColor1));


        // Flipper Entities
        const flipRadius = 0.03; // Thickness
        const flipLength = 0.2;
        const flipMaxRotation = 1.0; // Radians
        const flipRestAngle = 0.5; // Radians from horizontal
        const flipAngularVelocity = 20.0; // Radians per second
        const flipColor = "#FF0000";
        const flipRestitution = 0.2;

        const flipper1 = world.createEntity();
        world.addComponent(flipper1, new FlipperTagComponent());
        world.addComponent(flipper1, new PositionComponent(0.26, 0.22));
        world.addComponent(flipper1, new RadiusComponent(flipRadius));
        world.addComponent(flipper1, new FlipperStateComponent(flipLength, -flipRestAngle, flipMaxRotation, flipAngularVelocity));
        world.addComponent(flipper1, new RestitutionComponent(flipRestitution));
        world.addComponent(flipper1, new RenderableComponent('flipper', flipColor));

        const flipper2 = world.createEntity();
        world.addComponent(flipper2, new FlipperTagComponent());
        world.addComponent(flipper2, new PositionComponent(0.74, 0.22));
        world.addComponent(flipper2, new RadiusComponent(flipRadius));
        world.addComponent(flipper2, new FlipperStateComponent(flipLength, Math.PI + flipRestAngle, -flipMaxRotation, flipAngularVelocity));
        world.addComponent(flipper2, new RestitutionComponent(flipRestitution));
        world.addComponent(flipper2, new RenderableComponent('flipper', flipColor));

        // Score Entity
        const scoreEntity = world.createEntity();
        world.addComponent(scoreEntity, new ScoreComponent(0));


        // --- Cable Setup ---
        // Connect: ball2 -> obs4 -> obs3 -> ball1

        // Add necessary components to obstacles (assuming they act as wheels)
        world.addComponent(obs4, new CableLinkComponent());
        world.addComponent(obs3, new CableLinkComponent());
        //world.addComponent(obs2, new CableLinkComponent());
        //world.addComponent(obs1, new CableLinkComponent());
        world.addComponent(ball1, new CableLinkComponent());
        world.addComponent(ball2, new CableLinkComponent());

        // --- Calculate Initial Cable State ---
        // Need to compute initial attachment points and rest lengths
        // Get relevant components
        const pos_ball1 = world.getComponent(ball1, PositionComponent).pos;
        const pos_ball2 = world.getComponent(ball2, PositionComponent).pos;
        const pos_obs3 = world.getComponent(obs3, PositionComponent).pos;
        const radius_obs3 = world.getComponent(obs3, RadiusComponent).radius;
        const pos_obs4 = world.getComponent(obs4, PositionComponent).pos;
        const radius_obs4 = world.getComponent(obs4, RadiusComponent).radius;

        // Calculate initial points for joint1 (ball2 attachment <-> obs4 rolling)
        const joint1 = world.createEntity();
        const initialPoints1 = tangentFromPointToCircle(pos_ball2, pos_obs4, radius_obs4, true);
        const initialDist1 = initialPoints1.a_attach.clone().subtract(initialPoints1.a_circle).length();
        world.addComponent(joint1, new CableJointComponent(
          ball2, obs4, initialDist1, initialPoints1.a_attach, initialPoints1.a_circle)); // Order matters
        world.addComponent(joint1, new RenderableComponent('line', '#FF0000')); // Red line


        // Calculate initial points for joint2 (obs4 rolling <-> obs3 rolling)
        const joint2 = world.createEntity();
        const initialPoints2 = tangentFromCircleToCircle(pos_obs4, radius_obs4, true, pos_obs3, radius_obs3, true);
        const initialDist2 = initialPoints2.a_circle.clone().subtract(initialPoints2.b_circle).length();
        world.addComponent(joint2, new CableJointComponent(
          obs4, obs3, initialDist2, initialPoints2.a_circle, initialPoints2.b_circle)); // Order matters
        world.addComponent(joint2, new RenderableComponent('line', '#FFFF00')); // Yellow line

        // Calculate initial points for joint3 (obs3 rolling <-> ball1 attachment)
        const joint3 = world.createEntity();
        const initialPoints3 = tangentFromCircleToPoint(pos_ball1, pos_obs3, radius_obs3, true);
        const initialDist3 = initialPoints3.a_attach.clone().subtract(initialPoints3.a_circle).length();
        world.addComponent(joint3, new CableJointComponent(
          obs3, ball1, initialDist3, initialPoints3.a_circle, initialPoints3.a_attach)); // Order matters
        world.addComponent(joint3, new RenderableComponent('line', '#00FF00')); // Green line

        // Create Cable Path Entity
        const cablePath = world.createEntity();
        // CablePathComponent constructor now calculates initial stored length and totalRestLength
        const pathComp = new CablePathComponent(
          world,
          [joint1, joint2, joint3],
          ['attachment', 'rolling', 'rolling', 'attachment'],
          [true, true, true, true]
        );
        world.addComponent(cablePath, pathComp);


        // --- Systems Registration (Order Matters!) ---
        if (world.systems.length === 0) { // Only register systems once
             const inputSystemInstance = new InputSystem(canvas);
             world.registerSystem(inputSystemInstance);
             world.registerSystem(new InputReplaySystem(
               [],
             inputSystemInstance));
             world.registerSystem(new InputSystem(canvas));
             world.registerSystem(new FlipperMotionSystem()); // Handles flipper input -> state change
             world.registerSystem(new GravitySystem());      // Applies gravity acceleration
             world.registerSystem(new MovementSystem());     // Updates position based on velocity
             world.registerSystem(new PBDBallBallCollisions());
             world.registerSystem(new PBDBallObstacleCollisions2());
             world.registerSystem(new PBDBallFlipperCollisions());
             world.registerSystem(new PBDBallBorderCollisions());
             world.registerSystem(new CableAttachmentUpdateSystem());
             world.registerSystem(new PBDCableConstraintSolver());

            // --- Scoring and Rendering ---
            world.registerSystem(new ScoreSystem());
            world.registerSystem(new ScoreDisplaySystem('score'));

            // Create or update RenderSystem
            if (!renderSystemInstance) {
                const renderSystemInstance = new RenderSystem2(canvas, cScale, simHeight);
                world.registerSystem(renderSystemInstance);
                world.setResource('renderSystem', renderSystemInstance); // Store for potential access elsewhere
            } else {
                // Update existing render system instance with new scale/dimensions if needed
                renderSystemInstance.cScale = cScale;
                renderSystemInstance.simHeight = simHeight;
                // Ensure canvas reference is still correct (should be)
                // renderSystemInstance.canvas = canvas;
                // renderSystemInstance.c = canvas.getContext("2d");
            }
        } else {
          world.systems[InputSystem]
        }

        // Update button text based on initial pause state
         const pauseState = world.getResource('pauseState');
         pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
    }


    // --- Main Loop ---
    let lastTime = 0;
    let doStep = true; // Whether to do a single step when paused

    function gameLoop(currentTime) {
        const dt = world.getResource('dt');
        const pauseState = world.getResource('pauseState');

        if (!pauseState.paused || doStep) {
            if (doStep) pauseState.paused = false;
            world.update(dt);
            if (doStep) pauseState.paused = true;
            doStep = false; // Reset step flag after executing one step
        }

        requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners ---
    pauseBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const pauseState = world.getResource('pauseState');
        if (pauseState) {
            pauseState.paused = !pauseState.paused;
            pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
        }
    });

    resetBtn.addEventListener('click', (e) => {
        e.preventDefault();
        setupScene(); // Re-initialize the world state
        // Ensure pause state resource is reset if needed
        const pauseState = world.getResource('pauseState');
        if (pauseState) pauseState.paused = true; // Start paused after reset
        pauseBtn.textContent = "Resume";
        doStep = true;
    });

    stepBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const pauseState = world.getResource('pauseState');
        if (pauseState && pauseState.paused) {
            doStep = true;
        }
    });
    const dumpBtn = document.getElementById('dumpBtn');
    dumpBtn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log(dumpWorldState(world));
    });

    // --- Start ---
    setupScene();
    requestAnimationFrame(gameLoop);

</script>

</body>
</html>
