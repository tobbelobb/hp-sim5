<!DOCTYPE html>
<html>
<head>
    <title>Cable Joints - Tests</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; font-family: sans-serif; color: white; }
        canvas { border: 1px solid black; display: block; margin: 10px auto; background-color: #202020; }
        #testResults { position: absolute; top: 10px; left: 10px; background-color: rgba(50,50,50,0.8); color: white; padding: 10px; border: 1px solid #ccc; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        #controls { padding: 10px; text-align: center; }
    </style>
</head>
<body>
    <div id="controls">
        Select Test to Visualize:
        <select id="testSelector">
            <option value="testSimpleMerge">Simple Merge</option>
            <option value="testSimpleSplit">Simple Split</option>
            <option value="testAttachmentUpdate">Attachment Update</option>
            <option value="testLargeInitialWrap">Large Initial Wrap</option>
            <option value="testGeneratedError1">Test Generated Error 1</option>
            <option value="testTangentCircleCircle_TT">Tangent Circle-Circle (T, T)</option>
            <option value="testTangentCircleCircle_TF">Tangent Circle-Circle (T, F)</option>
            <option value="testTangentCircleCircle_FT">Tangent Circle-Circle (F, T)</option>
            <option value="testTangentCircleCircle_FF">Tangent Circle-Circle (F, F)</option>
            <option value="testTangentPointCapsule_leftCw">Tangent Point-Capsule (left, cw)</option>
            <option value="testTangentPointCapsule_leftCCw">Tangent Point-Capsule (left, ccw)</option>
            <option value="testTangentPointCapsule_rightCw">Tangent Point-Capsule (right, cw)</option>
            <option value="testTangentPointCapsule_rightCCw">Tangent Point-Capsule (right, ccw)</option>
            <option value="testTangentPointCapsule_inlineRightCw">Tangent Point-Capsule (inline right, cw)</option>
            <option value="testTangentPointCapsule_inlineRightCCw">Tangent Point-Capsule (inline right, ccw)</option>
            <option value="testTangentPointCapsule_inlineRightCw2">Tangent Point-Capsule (inline2 right, cw)</option>
            <option value="testTangentPointCapsule_inlineRightCCw2">Tangent Point-Capsule (inline2 right, ccw)</option>
            <option value="testTangentPointCapsule_inlineLeftCw">Tangent Point-Capsule (inline left, cw)</option>
            <option value="testTangentPointCapsule_inlineLeftCCw">Tangent Point-Capsule (inline left, ccw)</option>
            <option value="testTangentPointCapsule_inlineLeftCw2">Tangent Point-Capsule (inline2 left, cw)</option>
            <option value="testTangentPointCapsule_inlineLeftCCw2" selected>Tangent Point-Capsule (inline2 left, ccw)</option>
        </select>
        <button id="runBtn">Run &amp; Visualize</button>
    </div>
    <canvas id="testCanvas"></canvas>
    <div id="testResults">
        <h4>Test Results:</h4>
        <ul id="testList"></ul>
    </div>

<script src="cable_joints_core.js"></script>
<script>
  const canvas = document.getElementById("testCanvas");
  canvas.width = window.innerWidth * 0.8; // Adjust size as needed
  canvas.height = window.innerHeight * 0.7;

  const cScale = canvas.height / 2.0; // Base scale (pixels per sim unit)
  const simWidth = canvas.width / cScale;
  const simHeight = canvas.height / cScale;

  // Make world accessible globally within this test file (for debugging)
  window.testWorld = null;
  // Remove global renderSystem, it will be created per test run

  // --- Test Suite ---
  const testResultsList = document.getElementById('testList');
  let testsPassed = 0;
  let testsFailed = 0;

  function logTestResult(name, passed, message = '') {
      const li = document.createElement('li');
      li.style.color = passed ? 'lightgreen' : 'salmon';
      li.textContent = `${passed ? 'PASS' : 'FAIL'} - ${name}${message ? ': ' + message : ''}`;
      testResultsList.appendChild(li);
      if (passed) testsPassed++; else testsFailed++;
  }

  function assertEquals(expected, actual, testName, valueName) {
      if (expected !== actual) {
          logTestResult(testName, false, `${valueName} expected ${expected}, got ${actual}`);
          return false;
      }
      return true;
  }

  function assertNear(expected, actual, tolerance, testName, valueName) {
      if (Math.abs(expected - actual) > tolerance) {
          logTestResult(testName, false, `${valueName} expected near ${expected}, got ${actual}`);
          return false;
      }
      return true;
  }

  function assertTrue(condition, testName, message) {
      if (!condition) {
          logTestResult(testName, false, message);
          return false;
      }
      return true;
  }

  function assertFalse(condition, testName, message) {
      if (condition) {
          logTestResult(testName, false, message);
          return false;
      }
      return true;
  }

  // --- Test Cases ---
  const testCases = {
    testSimpleMerge: {
      viewport: { scale: 1.3, offsetX: 1.0, offsetY: 0.0 }, // Default viewport
      run: function() {
        const testName = "Simple Merge";
        const world = new World();
        window.testWorld = world; // Set global world for this test
        world.setResource('dt', 0.01);
        world.setResource('debugRenderPoints', {});
        world.setResource('simWidth', simWidth);
        world.setResource('simHeight', simHeight);

        // Setup entities
        const linkA = world.createEntity(); // Attachment point
        world.addComponent(linkA, new PositionComponent(0, 0));
        world.addComponent(linkA, new CableLinkComponent(0, 0));
        world.addComponent(linkA, new MassComponent(-1));
        world.addComponent(linkA, new RenderableComponent('circle', '#AAAAAA')); // Render fixed points

        const linkB = world.createEntity(); // Rolling link
        world.addComponent(linkB, new PositionComponent(1, -0.100001));
        world.addComponent(linkB, new CableLinkComponent(1, -0.100001));
        world.addComponent(linkB, new MassComponent(1));
        world.addComponent(linkB, new RadiusComponent(0.1));
        world.addComponent(linkB, new RenderableComponent('circle', '#CCCCCC'));

        const linkC = world.createEntity(); // Attachment point
        world.addComponent(linkC, new PositionComponent(2, 0));
        world.addComponent(linkC, new CableLinkComponent(2, 0));
        world.addComponent(linkC, new MassComponent(-1));
        world.addComponent(linkC, new RenderableComponent('circle', '#AAAAAA'));

        // Initial tangent points
        const attachA = new Vector2(0, 0);
        const attachB1 = new Vector2(1.0000001, 0);
        const attachB2 = new Vector2(0.9999999, 0);
        const attachC = new Vector2(2, 0);

        // Create joints
        const joint1Id = world.createEntity();
        world.addComponent(joint1Id, new CableJointComponent(linkA, linkB, 1.0, attachA.clone(), attachB1.clone()));
        world.addComponent(joint1Id, new RenderableComponent('line', '#FF8888'));
        const joint2Id = world.createEntity();
        world.addComponent(joint2Id, new CableJointComponent(linkB, linkC, 1.0, attachB2.clone(), attachC.clone()));
        world.addComponent(joint2Id, new RenderableComponent('line', '#88FF88'));

        // Create path
        const pathId = world.createEntity();
        const pathComp = new CablePathComponent(world, [joint1Id, joint2Id], ['attachment', 'rolling', 'attachment'], [true, true, true]);
        pathComp.stored[1] = -0.0000001;
        pathComp.totalRestLength = 2.0;
        world.addComponent(pathId, pathComp);

        // --- Run the system ---
        const system = new CableAttachmentUpdateSystem();
        system.update(world, world.getResource('dt'));

        // --- Assertions ---
        const updatedPath = world.getComponent(pathId, CablePathComponent);
        if (!assertTrue(updatedPath !== undefined, testName, "Path component exists")) return world;

        if (!assertEquals(1, updatedPath.jointEntities.length, testName, "Number of joints after merge")) return world;
        const mergedJointId = updatedPath.jointEntities[0];
        const mergedJoint = world.getComponent(mergedJointId, CableJointComponent);
        if (!assertTrue(mergedJoint !== undefined, testName, "Merged joint exists")) return world;

        assertEquals(linkA, mergedJoint.entityA, testName, "Merged joint entity A");
        assertEquals(linkC, mergedJoint.entityB, testName, "Merged joint entity B");
        assertNear(2.0, mergedJoint.restLength, 1e-6, testName, "Merged joint rest length");
        assertEquals(2, updatedPath.linkTypes.length, testName, "Number of link types after merge");
        assertEquals('attachment', updatedPath.linkTypes[0], testName, "Link type 0 after merge");
        assertEquals('attachment', updatedPath.linkTypes[1], testName, "Link type 1 after merge");

        const joint2Comp = world.getComponent(joint2Id, CableJointComponent);
        assertFalse(joint2Comp && joint2Comp.isActive, testName, "Original joint 2 is inactive/destroyed");

        logTestResult(testName, true);
        return world; // Return world for rendering
      }
    },

    testSimpleSplit: {
      viewport: { scale: 1.3, offsetX: 1.0, offsetY: 0.0 }, // Default viewport
      run: function() {
        const testName = "Simple Split";
        const world = new World();
        window.testWorld = world; // Set global world
        world.setResource('dt', 0.01);
        world.setResource('debugRenderPoints', {});
        world.setResource('simWidth', simWidth);
        world.setResource('simHeight', simHeight);

        // Setup entities
        const linkA = world.createEntity(); // Attachment point
        world.addComponent(linkA, new PositionComponent(0, 0));
        world.addComponent(linkA, new CableLinkComponent(0, 0));
        world.addComponent(linkA, new MassComponent(-1));
        world.addComponent(linkA, new RenderableComponent('circle', '#AAAAAA'));

        const linkB = world.createEntity(); // Attachment point
        world.addComponent(linkB, new PositionComponent(2, 0));
        world.addComponent(linkB, new CableLinkComponent(2, 0));
        world.addComponent(linkB, new MassComponent(-1));
        world.addComponent(linkB, new RenderableComponent('circle', '#AAAAAA'));

        const splitterLink = world.createEntity(); // Rolling link that will cause the split
        const splitterRadius = 0.1;
        const splitterY = splitterRadius * -0.999999; // Slightly less than radius
        world.addComponent(splitterLink, new PositionComponent(1, splitterY));
        world.addComponent(splitterLink, new CableLinkComponent(1, splitterY));
        world.addComponent(splitterLink, new MassComponent(1));
        world.addComponent(splitterLink, new RadiusComponent(splitterRadius));
        world.addComponent(splitterLink, new RenderableComponent('circle', '#CCCCCC'));

        // Initial joint (A -> B)
        const initialRestLength = 2.0;
        const jointOrigId = world.createEntity();
        world.addComponent(jointOrigId, new CableJointComponent(linkA, linkB, initialRestLength, new Vector2(0,0), new Vector2(2,0)));
        world.addComponent(jointOrigId, new RenderableComponent('line', '#FFFFFF'));

        // Create path
        const pathId = world.createEntity();
        const pathComp = new CablePathComponent(world, [jointOrigId], ['attachment', 'attachment'], [true, true]);
        pathComp.totalRestLength = initialRestLength;
        world.addComponent(pathId, pathComp);

        // --- Run the system ---
        const system = new CableAttachmentUpdateSystem();
        system.update(world, world.getResource('dt'));

        // --- Assertions ---
        const updatedPath = world.getComponent(pathId, CablePathComponent);
        if (!assertTrue(updatedPath !== undefined, testName, "Path component exists")) return world;

        if (!assertEquals(2, updatedPath.jointEntities.length, testName, "Number of joints after split")) return world;

        assertEquals(3, updatedPath.linkTypes.length, testName, "Number of link types after split");
        assertEquals('attachment', updatedPath.linkTypes[0], testName, "Link type 0 after split");
        assertEquals('rolling', updatedPath.linkTypes[1], testName, "Link type 1 after split (splitter)");
        assertEquals('attachment', updatedPath.linkTypes[2], testName, "Link type 2 after split");
        assertEquals(3, updatedPath.cw.length, testName, "Number of cw flags after split");
        assertEquals(3, updatedPath.stored.length, testName, "Number of stored lengths after split");
        assertNear(0.0, updatedPath.stored[1], 1e-4, testName, "Stored length on splitter link");

        const joint1Id = updatedPath.jointEntities[0];
        const joint2Id = updatedPath.jointEntities[1];
        const joint1 = world.getComponent(joint1Id, CableJointComponent);
        const joint2 = world.getComponent(joint2Id, CableJointComponent);

        if (!assertTrue(joint1 !== undefined, testName, "Joint 1 (A->Splitter) exists")) return world;
        if (!assertTrue(joint2 !== undefined, testName, "Joint 2 (Splitter->B) exists")) return world;

        assertEquals(linkA, joint1.entityA, testName, "Joint 1 entity A");
        assertEquals(splitterLink, joint1.entityB, testName, "Joint 1 entity B (splitter)");
        assertEquals(splitterLink, joint2.entityA, testName, "Joint 2 entity A (splitter)");
        assertEquals(linkB, joint2.entityB, testName, "Joint 2 entity B");

        const expectedRestLength = (initialRestLength - updatedPath.stored[1]) / 2.0;
        assertNear(expectedRestLength, joint1.restLength, 1e-6, testName, "Joint 1 rest length");
        assertNear(expectedRestLength, joint2.restLength, 1e-6, testName, "Joint 2 rest length");

        assertNear(pathComp.totalRestLength, joint1.restLength + joint2.restLength + updatedPath.stored[1], 1e-6, testName, "Total rest length conserved");

        assertNear(0.0, joint1.attachmentPointA_world.x, 1e-6, testName, "Joint 1 attach A.x");
        assertNear(0.0, joint1.attachmentPointA_world.y, 1e-6, testName, "Joint 1 attach A.y");
        assertNear(1.0, joint1.attachmentPointB_world.x, 1e-4, testName, "Joint 1 attach B.x (on splitter)");
        assertNear(1.0, joint2.attachmentPointA_world.x, 1e-4, testName, "Joint 2 attach A.x (on splitter)");
        assertNear(2.0, joint2.attachmentPointB_world.x, 1e-6, testName, "Joint 2 attach B.x");
        assertNear(0.0, joint2.attachmentPointB_world.y, 1e-6, testName, "Joint 2 attach B.y");

        assertEquals(jointOrigId, joint1Id, testName, "Original joint ID reused for first segment");

        logTestResult(testName, true);
        return world; // Return world for rendering
      }
    },

    testAttachmentUpdate: {
      viewport: { scale: 1.3, offsetX: 1.0, offsetY: 0.0 }, // Default viewport
      run: function() {
        const testName = "Attachment Update (Placeholder)";
        const world = new World();
        window.testWorld = world; // Set global world
        world.setResource('dt', 0.01);
        world.setResource('debugRenderPoints', {});
        world.setResource('simWidth', simWidth);
        world.setResource('simHeight', simHeight);


        // TODO: Set up a world state with rolling links
        // TODO: Move the links slightly (or set prevPos differently)
        // TODO: Run the system
        // TODO: Assert that attachment points, rest lengths, and stored lengths are updated correctly

        // Example Setup (Needs refinement)
        const linkA = world.createEntity(); // Rolling
        world.addComponent(linkA, new PositionComponent(0, 0));
        world.addComponent(linkA, new CableLinkComponent(0, 0.01)); // Moved slightly
        world.addComponent(linkA, new MassComponent(1));
        world.addComponent(linkA, new RadiusComponent(0.1));
        world.addComponent(linkA, new RenderableComponent('circle', '#AAAAAA'));

        const linkB = world.createEntity(); // Attachment
        world.addComponent(linkB, new PositionComponent(1, 0));
        world.addComponent(linkB, new CableLinkComponent(1, 0));
        world.addComponent(linkB, new MassComponent(-1));
        world.addComponent(linkB, new RenderableComponent('circle', '#CCCCCC'));

        // Initial points (approximate)
        const attachA = new Vector2(0, 0.1); // Tangent on A
        const attachB = new Vector2(1, 0);   // Point B

        const jointId = world.createEntity();
        world.addComponent(jointId, new CableJointComponent(linkA, linkB, 0.9, attachA.clone(), attachB.clone()));
        world.addComponent(jointId, new RenderableComponent('line', '#FFFFFF'));

        const pathId = world.createEntity();
        const pathComp = new CablePathComponent(world, [jointId], ['rolling', 'attachment'], [true, true]);
        pathComp.stored[0] = 0.0; // Initial stored on A
        pathComp.totalRestLength = 0.9;
        world.addComponent(pathId, pathComp);

        // --- Run the system ---
        const system = new CableAttachmentUpdateSystem();
        system.update(world, world.getResource('dt'));

        // --- Assertions (Placeholder) ---
        const updatedPath = world.getComponent(pathId, CablePathComponent);
        const updatedJoint = world.getComponent(jointId, CableJointComponent);
        // Assert changes in joint.restLength, path.stored[0], joint.attachmentPointA_world

        logTestResult(testName, true, "Not fully implemented yet");
        return world; // Return world for rendering
      }
    },

    testLargeInitialWrap: {
      viewport: { scale: 1.3, offsetX: 1.0, offsetY: 0.0 }, // Default viewport
      run: function() {
        const testName = "Large initial wrap around obstacle";
        const world = new World();
        window.testWorld = world; // Set global world
        world.setResource('dt', 0.01); // Use a typical dt
        world.setResource('debugRenderPoints', {});
        world.setResource('simWidth', simWidth);
        world.setResource('simHeight', simHeight);

        const viewOffset = new Vector2(0.0, 0.0);

        // --- Entities and Components (Copied from cable_joints.html setupScene) ---
        // Ball Entities
        const ballRadius = 0.03;

        const ball1 = world.createEntity();
        world.addComponent(ball1, new PositionComponent(1.025 + viewOffset.x, -0.5 + viewOffset.y)); // Use original positions
        world.addComponent(ball1, new RadiusComponent(ballRadius));
        world.addComponent(ball1, new MassComponent(1));
        world.addComponent(ball1, new RenderableComponent('circle', '#FF0000'));

        const ball2 = world.createEntity();
        world.addComponent(ball2, new PositionComponent(1.2 + viewOffset.x, -0.7 + viewOffset.y)); // Use original positions
        world.addComponent(ball2, new RadiusComponent(ballRadius));
        world.addComponent(ball2, new MassComponent(1));
        world.addComponent(ball2, new RenderableComponent('circle', '#00FF00'));

        // Obstacle Entity
        const obsColor = "#FF8000";
        const obs1 = world.createEntity();
        world.addComponent(obs1, new PositionComponent(1.0 + viewOffset.x, 0.3 + viewOffset.y)); // Use original positions
        world.addComponent(obs1, new MassComponent(-1.0)); // Fixed obstacle
        const obsRadius = 0.1;
        world.addComponent(obs1, new RadiusComponent(obsRadius));
        world.addComponent(obs1, new RenderableComponent('circle', obsColor));

        // --- Cable Setup (Copied from cable_joints.html setupScene) ---
        world.addComponent(obs1, new CableLinkComponent());
        world.addComponent(ball1, new CableLinkComponent());
        world.addComponent(ball2, new CableLinkComponent());

        // --- Calculate Initial Cable State ---
        const pos_ball1 = world.getComponent(ball1, PositionComponent).pos;
        const link_ball1 = world.getComponent(ball1, CableLinkComponent);
        const pos_obs1 = world.getComponent(obs1, PositionComponent).pos;
        const radius_obs1 = world.getComponent(obs1, RadiusComponent).radius;
        const cw_obs1 = true;
        const link_obs1 = world.getComponent(obs1, CableLinkComponent);
        const pos_ball2 = world.getComponent(ball2, PositionComponent).pos;
        const link_ball2 = world.getComponent(ball2, CableLinkComponent);

        const initialPoints1 = tangentFromPointToCircle(pos_ball1, pos_obs1, radius_obs1, cw_obs1);
        const initialPoints2 = tangentFromCircleToPoint(pos_ball2, pos_obs1, radius_obs1, cw_obs1);

        const joint1 = world.createEntity();
        const initialDist1 = initialPoints1.a_attach.clone().subtract(initialPoints1.a_circle).length();
        world.addComponent(joint1, new CableJointComponent(
          ball1, obs1, initialDist1, initialPoints1.a_attach, initialPoints1.a_circle));
        world.addComponent(joint1, new RenderableComponent('line', '#FF0000'));

        const joint2 = world.createEntity();
        const initialDist2 = initialPoints2.a_attach.clone().subtract(initialPoints2.a_circle).length();
        world.addComponent(joint2, new CableJointComponent(
          obs1, ball2, initialDist2, initialPoints2.a_circle, initialPoints2.a_attach));
        world.addComponent(joint2, new RenderableComponent('line', '#FFFF00'));

        const cablePath = world.createEntity();
        // The CablePathComponent constructor calculates the initial stored length
        const pathComp = new CablePathComponent(world, [joint1, joint2], ['attachment', 'rolling', 'attachment'], [true, true, true]);
        world.addComponent(cablePath, pathComp);

        // --- Assertions ---
        if (!assertTrue(pathComp !== undefined, testName, "Path component exists")) return world;

        const storedLengthObs = pathComp.stored[1]; // Stored length on the rolling obstacle (index 1)

        // Check if stored length is positive
        assertTrue(storedLengthObs > 0, testName, `Stored length on obstacle (${storedLengthObs.toFixed(4)}) should be positive`);

        // Check if stored length is above PI * radius (indicating >180 degree wrap)
        const piR = Math.PI * obsRadius;
        assertTrue(storedLengthObs > piR, testName, `Stored length (${storedLengthObs.toFixed(4)}) should be slightly greater than PI*r (${piR.toFixed(4)})`);

        logTestResult(testName, true);
        return world; // Return world for rendering
      }
    },

    // --- Generated Error Test Case ---
    testGeneratedError1: {
      // Viewport settings from the time of the error
      viewport: { scale: 1, offsetX: 1.5, offsetY: 0.7 },
      run: function() {
        const testName = "Generated Error Case";
        const world = new World();
        window.testWorld = world; // Set global world
        world.setResource('dt', 0.01);
        world.setResource('debugRenderPoints', {});
        world.setResource('simWidth', 2.6831683168316833);
        world.setResource('simHeight', 2);

        // --- Resources ---
        world.setResource('gravity', new Vector2(0, -10));

        // --- Entities and Components ---
        const entity0 = world.createEntity(); // Original ID: 0
        const entity1 = world.createEntity(); // Original ID: 1
        const entity2 = world.createEntity(); // Original ID: 2
        const entity3 = world.createEntity(); // Original ID: 3
        const entity4 = world.createEntity(); // Original ID: 4
        const entity5 = world.createEntity(); // Original ID: 5
        const entity6 = world.createEntity(); // Original ID: 6
        const entity7 = world.createEntity(); // Original ID: 7
        const entity8 = world.createEntity(); // Original ID: 8
        const entity9 = world.createEntity(); // Original ID: 9
        const entity10 = world.createEntity(); // Original ID: 10
        const entity11 = world.createEntity(); // Original ID: 11
        const entity18 = world.createEntity(); // Original ID: 18

        world.addComponent(entity0, new BallTagComponent());
        world.addComponent(entity0, new PositionComponent(1.3850779315305588, -0.2511048757852874));
        world.addComponent(entity0, new VelocityComponent(0.8281714619644637, 0.28111919458297885));
        world.addComponent(entity0, new RadiusComponent(0.03));
        world.addComponent(entity0, new MassComponent(0.1001));
        world.addComponent(entity0, new RestitutionComponent(0.4));
        world.addComponent(entity0, new GravityAffectedComponent());
        world.addComponent(entity0, new RenderableComponent('circle', '#FF0000'));
        world.addComponent(entity0, new CableLinkComponent(1.3767747769859724, -0.25553726910704416));

        world.addComponent(entity1, new BallTagComponent());
        world.addComponent(entity1, new PositionComponent(1.6949039044287488, 1.423483265257341));
        world.addComponent(entity1, new VelocityComponent(-1.3004676168268352, -1.6117510956187493));
        world.addComponent(entity1, new RadiusComponent(0.03));
        world.addComponent(entity1, new MassComponent(0.1));
        world.addComponent(entity1, new RestitutionComponent(0.4));
        world.addComponent(entity1, new GravityAffectedComponent());
        world.addComponent(entity1, new RenderableComponent('circle', '#00FF00'));
        world.addComponent(entity1, new CableLinkComponent(1.682170255155346, 1.418854076314796));

        world.addComponent(entity2, new ObstacleTagComponent());
        world.addComponent(entity2, new PositionComponent(1.5, 1.5));
        world.addComponent(entity2, new MassComponent(-1));
        world.addComponent(entity2, new RadiusComponent(0.1));
        world.addComponent(entity2, new RenderableComponent('circle', '#FF8000'));
        world.addComponent(entity2, new CableLinkComponent(1.5, 1.5));

        world.addComponent(entity3, new CableJointComponent(entity0, entity2, 0.9131923308749382, new Vector2(1.3850779315305588, -0.2511048757852874), new Vector2(1.4000036288485527, 1.5008519134592058)));
        world.addComponent(entity3, new RenderableComponent('line', '#FF0000'));

        world.addComponent(entity4, new CableJointComponent(entity2, entity1, 1.0198789798585626, new Vector2(1.5765621260161375, 1.5643291602610283), new Vector2(1.6949039044287488, 1.423483265257341)));
        world.addComponent(entity4, new RenderableComponent('line', '#FFFF00'));

        // Skipped unknown component CablePathComponent for entity5

        world.addComponent(entity6, new BallTagComponent());
        world.addComponent(entity6, new PositionComponent(2.0226661911107535, -0.298305031843515));
        world.addComponent(entity6, new VelocityComponent(-0.530422491091552, 0.7622093453276682));
        world.addComponent(entity6, new RadiusComponent(0.03));
        world.addComponent(entity6, new MassComponent(0.1001));
        world.addComponent(entity6, new RestitutionComponent(0.4));
        world.addComponent(entity6, new GravityAffectedComponent());
        world.addComponent(entity6, new RenderableComponent('circle', '#FF0000'));
        world.addComponent(entity6, new CableLinkComponent(2.0281416796256835, -0.3068654398648548));

        world.addComponent(entity7, new BallTagComponent());
        world.addComponent(entity7, new PositionComponent(2.0585555387359573, 1.1577745522431606));
        world.addComponent(entity7, new VelocityComponent(0.42039450065147665, -0.9463297282840478));
        world.addComponent(entity7, new RadiusComponent(0.03));
        world.addComponent(entity7, new MassComponent(0.1));
        world.addComponent(entity7, new RestitutionComponent(0.4));
        world.addComponent(entity7, new GravityAffectedComponent());
        world.addComponent(entity7, new RenderableComponent('circle', '#00FF00'));
        world.addComponent(entity7, new CableLinkComponent(2.0547335280625636, 1.1663627997808153));

        world.addComponent(entity8, new ObstacleTagComponent());
        world.addComponent(entity8, new PositionComponent(1.8, 1.5));
        world.addComponent(entity8, new MassComponent(-1));
        world.addComponent(entity8, new RadiusComponent(0.1));
        world.addComponent(entity8, new RenderableComponent('circle', '#FF8000'));
        world.addComponent(entity8, new CableLinkComponent(1.8, 1.5));

        world.addComponent(entity9, new CableJointComponent(entity6, entity8, 1.0832934652807662, new Vector2(2.0226661911107535, -0.298305031843515), new Vector2(1.701587245907534, 1.4822537375220637)));
        world.addComponent(entity9, new RenderableComponent('line', '#FF0000'));

        world.addComponent(entity10, new CableJointComponent(entity8, entity7, 1.1411708380436034, new Vector2(1.891643850843284, 1.5400175536810274), new Vector2(2.0585555387359573, 1.1577745522431606)));
        world.addComponent(entity10, new RenderableComponent('line', '#FFFF00'));

        // Skipped unknown component CablePathComponent for entity11







        world.addComponent(entity5, new CablePathComponent(world, [entity3, entity4], ['attachment', 'rolling', 'attachment'], [true, true, true]));
        const pathComp_entity5 = world.getComponent(entity5, CablePathComponent);
        pathComp_entity5.stored = [0, 0.24342836173617954, 0];
        pathComp_entity5.totalRestLength = 2.176499672469678;






        world.addComponent(entity11, new CablePathComponent(world, [entity9, entity10], ['attachment', 'rolling', 'attachment'], [true, true, true]));
        const pathComp_entity11 = world.getComponent(entity11, CablePathComponent);
        pathComp_entity11.stored = [0, 0.29082918227271376, 0];
        pathComp_entity11.totalRestLength = 2.515293485597086;



        // --- Systems Registration (Copy from a working test or main file if needed) ---
        // world.registerSystem(new CableAttachmentUpdateSystem());
        // world.registerSystem(new PBDCableConstraintSolver());
        // ... etc ...

        // --- Run the system that caused the error (or the full update) ---
        // const system = new SpecificSystem();
        // system.update(world, world.getResource('dt'));
        // OR
        // world.update(world.getResource('dt')); // If the error happens during the full update cycle

        // --- Assertions (Add assertions here to verify the error or expected state) ---
        // assertTrue(..., testName, "Some condition");

        logTestResult(testName, false, "Generated test case - needs verification and assertions");
        return world; // Return world for rendering
      }
    },

    // --- Tangent Calculation Tests ---
    testTangentCircleCircle_TT: {
      viewport: { scale: 0.5, offsetX: 1.5, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Circle-Circle (cwA=T, cwB=T)";
        const world = new World(); // Minimal world for visualization
        window.testWorld = world;
        world.setResource('debugRenderPoints', {});

        const posA = new Vector2(0, 0); const rA = 1.0; const cwA = true;
        const posB = new Vector2(3, 0); const rB = 0.5; const cwB = true;

        // Visualize circles
        const entityA = world.createEntity();
        world.addComponent(entityA, new PositionComponent(posA.x, posA.y));
        world.addComponent(entityA, new RadiusComponent(rA));
        world.addComponent(entityA, new RenderableComponent('circle', '#AAAAAA'));
        const entityB = world.createEntity();
        world.addComponent(entityB, new PositionComponent(posB.x, posB.y));
        world.addComponent(entityB, new RadiusComponent(rB));
        world.addComponent(entityB, new RenderableComponent('circle', '#CCCCCC'));

        const tangents = tangentFromCircleToCircle(posA, rA, cwA, posB, rB, cwB);
        const debugPoints = world.getResource('debugRenderPoints');
        debugPoints['tangentA'] = { pos: tangents.a_circle, color: 'red' };
        debugPoints['tangentB'] = { pos: tangents.b_circle, color: 'lime' };

        // Visualize the tangent line
        const tangentLineEntity = world.createEntity();
        world.addComponent(tangentLineEntity, new CableJointComponent(entityA, entityB, 0, tangents.a_circle, tangents.b_circle)); // restLength doesn't matter for rendering
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF')); // White line
        // We need the cablepath for rendering
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cwA, cwB]));

        // Expected: Top outer tangent

        const expectedA = new Vector2(1/6, Math.sqrt(35)/6);
        const expectedB = new Vector2(37/12, Math.sqrt(35)/12);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(expectedA.x, tangents.a_circle.x, tol, testName, "Tangent A.x");
        passed &= assertNear(expectedA.y, tangents.a_circle.y, tol, testName, "Tangent A.y");
        passed &= assertNear(expectedB.x, tangents.b_circle.x, tol, testName, "Tangent B.x");
        passed &= assertNear(expectedB.y, tangents.b_circle.y, tol, testName, "Tangent B.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentCircleCircle_TF: {
      viewport: { scale: 0.5, offsetX: 1.5, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Circle-Circle (cwA=T, cwB=F)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const posA = new Vector2(0, 0); const rA = 1.0; const cwA = true;
        const posB = new Vector2(3, 0); const rB = 1.0; const cwB = false;

        const entityA = world.createEntity(); world.addComponent(entityA, new PositionComponent(posA.x, posA.y)); world.addComponent(entityA, new RadiusComponent(rA)); world.addComponent(entityA, new RenderableComponent('circle', '#AAAAAA'));
        const entityB = world.createEntity(); world.addComponent(entityB, new PositionComponent(posB.x, posB.y)); world.addComponent(entityB, new RadiusComponent(rB)); world.addComponent(entityB, new RenderableComponent('circle', '#CCCCCC'));

        const tangents = tangentFromCircleToCircle(posA, rA, cwA, posB, rB, cwB);
        const debugPoints = world.getResource('debugRenderPoints');
        debugPoints['tangentA'] = { pos: tangents.a_circle, color: 'red' };
        debugPoints['tangentB'] = { pos: tangents.b_circle, color: 'lime' };

        // Visualize the tangent line
        const tangentLineEntity = world.createEntity();
        world.addComponent(tangentLineEntity, new CableJointComponent(entityA, entityB, 0, tangents.a_circle, tangents.b_circle));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        // We need the cablepath for rendering
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cwA, cwB]));

        // Expected: Internal tangent (top-left to bottom-right)
        const phi = Math.asin(2/3);
        const expectedA = new Vector2(Math.sin(phi), Math.cos(phi)); // (2/3, sqrt(5)/3)
        const expectedB = new Vector2(3 - Math.sin(phi), -Math.cos(phi)); // (3 - 2/3, -sqrt(5)/3) = (7/3, -sqrt(5)/3)
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(expectedA.x, tangents.a_circle.x, tol, testName, "Tangent A.x");
        passed &= assertNear(expectedA.y, tangents.a_circle.y, tol, testName, "Tangent A.y");
        passed &= assertNear(expectedB.x, tangents.b_circle.x, tol, testName, "Tangent B.x");
        passed &= assertNear(expectedB.y, tangents.b_circle.y, tol, testName, "Tangent B.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentCircleCircle_FT: {
      viewport: { scale: 0.5, offsetX: 1.5, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Circle-Circle (cwA=F, cwB=T)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const posA = new Vector2(0, 0); const rA = 1.0; const cwA = false;
        const posB = new Vector2(3, 0); const rB = 1.0; const cwB = true;

        const entityA = world.createEntity(); world.addComponent(entityA, new PositionComponent(posA.x, posA.y)); world.addComponent(entityA, new RadiusComponent(rA)); world.addComponent(entityA, new RenderableComponent('circle', '#AAAAAA'));
        const entityB = world.createEntity(); world.addComponent(entityB, new PositionComponent(posB.x, posB.y)); world.addComponent(entityB, new RadiusComponent(rB)); world.addComponent(entityB, new RenderableComponent('circle', '#CCCCCC'));

        const tangents = tangentFromCircleToCircle(posA, rA, cwA, posB, rB, cwB);
        const debugPoints = world.getResource('debugRenderPoints');
        debugPoints['tangentA'] = { pos: tangents.a_circle, color: 'red' };
        debugPoints['tangentB'] = { pos: tangents.b_circle, color: 'lime' };

        // Visualize the tangent line
        const tangentLineEntity = world.createEntity();
        world.addComponent(tangentLineEntity, new CableJointComponent(entityA, entityB, 0, tangents.a_circle, tangents.b_circle));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        // We need the cablepath for rendering
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cwA, cwB]));

        // Expected: Internal tangent (bottom-left to top-right)
        const phi = Math.asin(2/3);
        const expectedA = new Vector2(Math.sin(phi), -Math.cos(phi)); // (2/3, -sqrt(5)/3)
        const expectedB = new Vector2(3 - Math.sin(phi), Math.cos(phi)); // (3 - 2/3, sqrt(5)/3) = (7/3, sqrt(5)/3)
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(expectedA.x, tangents.a_circle.x, tol, testName, "Tangent A.x");
        passed &= assertNear(expectedA.y, tangents.a_circle.y, tol, testName, "Tangent A.y");
        passed &= assertNear(expectedB.x, tangents.b_circle.x, tol, testName, "Tangent B.x");
        passed &= assertNear(expectedB.y, tangents.b_circle.y, tol, testName, "Tangent B.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentCircleCircle_FF: {
      viewport: { scale: 0.5, offsetX: 1.5, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Circle-Circle (cwA=F, cwB=F)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const posA = new Vector2(0, 0); const rA = 1.0; const cwA = false;
        const posB = new Vector2(3, 0); const rB = 0.5; const cwB = false;

        const entityA = world.createEntity(); world.addComponent(entityA, new PositionComponent(posA.x, posA.y)); world.addComponent(entityA, new RadiusComponent(rA)); world.addComponent(entityA, new RenderableComponent('circle', '#AAAAAA'));
        const entityB = world.createEntity(); world.addComponent(entityB, new PositionComponent(posB.x, posB.y)); world.addComponent(entityB, new RadiusComponent(rB)); world.addComponent(entityB, new RenderableComponent('circle', '#CCCCCC'));

        const tangents = tangentFromCircleToCircle(posA, rA, cwA, posB, rB, cwB);
        const debugPoints = world.getResource('debugRenderPoints');
        debugPoints['tangentA'] = { pos: tangents.a_circle, color: 'red' };
        debugPoints['tangentB'] = { pos: tangents.b_circle, color: 'lime' };

        // Visualize the tangent line
        const tangentLineEntity = world.createEntity();
        world.addComponent(tangentLineEntity, new CableJointComponent(entityA, entityB, 0, tangents.a_circle, tangents.b_circle));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        // We need the cablepath for rendering
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cwA, cwB]));

        // Expected: Bottom outer tangent
        const expectedA = new Vector2(1/6, -Math.sqrt(35)/6);
        const expectedB = new Vector2(37/12, -Math.sqrt(35)/12);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(expectedA.x, tangents.a_circle.x, tol, testName, "Tangent A.x");
        passed &= assertNear(expectedA.y, tangents.a_circle.y, tol, testName, "Tangent A.y");
        passed &= assertNear(expectedB.x, tangents.b_circle.x, tol, testName, "Tangent B.x");
        passed &= assertNear(expectedB.y, tangents.b_circle.y, tol, testName, "Tangent B.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_leftCw: {
      viewport: { scale: 0.45, offsetX: 1.0, offsetY: 1.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (left, cw=T)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = true;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(1.0, 3.0);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = 2.0*Math.atan(1/3);
        const expect_x = 2.0 + Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_leftCCw: {
      viewport: { scale: 0.45, offsetX: 1.0, offsetY: 1.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (left, cw=F)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = false;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(1.0, 3.0);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = Math.PI - 2.0*Math.atan(1/3);
        const expect_x = Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_rightCw: {
      viewport: { scale: 0.45, offsetX: 1.0, offsetY: -1.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (right, cw=T)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = true;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(1.0, -3.0);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = Math.PI + 2.0*Math.atan(1/3);
        const expect_x = Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_rightCCw: {
      viewport: { scale: 0.45, offsetX: 1.0, offsetY: -1.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (right, cw=F)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = false;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(1.0, -3.0);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = - 2.0*Math.atan(1/3);
        const expect_x = 2.0 + Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_inlineRightCw: {
      viewport: { scale: 0.30, offsetX: 1.0, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (inline right, cw=T)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = true;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(4.0, -0.1);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = - Math.atan(0.1/2.0) - Math.acos(1.0/Math.sqrt(4.01));
        const expect_x = 2.0 + Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_inlineRightCCw: {
      viewport: { scale: 0.30, offsetX: 1.0, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (inline right, cw=F)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = false;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(4.0, -0.1);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = - Math.atan(0.1/2.0) + Math.acos(1.0/Math.sqrt(4.01));
        const expect_x = 2.0 + Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_inlineRightCw2: {
      viewport: { scale: 0.30, offsetX: 1.0, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (inline right, cw=T)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = true;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(4.0, 0.1);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = Math.atan(0.1/2.0) - Math.acos(1.0/Math.sqrt(4.01));
        const expect_x = 2.0 + Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_inlineRightCCw2: {
      viewport: { scale: 0.30, offsetX: 1.0, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (inline right, cw=F)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = false;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(4.0, 0.1);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = Math.atan(0.1/2.0) + Math.acos(1.0/Math.sqrt(4.01));
        const expect_x = 2.0 + Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_inlineLeftCw: {
      viewport: { scale: 0.30, offsetX: 1.0, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (inline left, cw=T)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = true;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(-2.0, -0.1);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = Math.PI + Math.atan(0.1/2.0) - Math.acos(1.0/Math.sqrt(4.01));
        const expect_x = Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_inlineLeftCCw: {
      viewport: { scale: 0.30, offsetX: 1.0, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (inline left, cw=F)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = false;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(-2.0, -0.1);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = Math.PI + Math.atan(0.1/2.0) + Math.acos(1.0/Math.sqrt(4.01));
        const expect_x = Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_inlineLeftCw2: {
      viewport: { scale: 0.30, offsetX: 1.0, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (inline left, cw=T)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = true;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(-2.0, 0.1);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = Math.PI - Math.atan(0.1/2.0) - Math.acos(1.0/Math.sqrt(4.01));
        const expect_x = Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

    testTangentPointCapsule_inlineLeftCCw2: {
      viewport: { scale: 0.30, offsetX: 1.0, offsetY: 0.0 },
      run: function() {
        const testName = "Tangent Point-Capsule (inline left, cw=F)";
        const world = new World(); window.testWorld = world; world.setResource('debugRenderPoints', {});
        const r = 1.0;
        const cw = false;
        const pos_cap1 = new Vector2(0.0, 0.0);
        const capsule = world.createEntity();
        world.addComponent(capsule, new PositionComponent(pos_cap1.x, pos_cap1.y));
        world.addComponent(capsule, new RadiusComponent(r));
        world.addComponent(capsule, new FlipperStateComponent(
           /* length= */ 2.0,
           /* restAngle= */ 0.0,
           /* maxRotation= */ 0.0,
           /* angularVelocity= */ 0.0
        ));
        world.addComponent(capsule, new FlipperTagComponent());
        world.addComponent(capsule, new RenderableComponent('capsule', '#AAAAAA'));
        const fs1    = world.getComponent(capsule, FlipperStateComponent);
        const angle1 = fs1.restAngle + fs1.sign * fs1.rotation;;
        const tip1   = pos_cap1.clone().add(
                          new Vector2(Math.cos(angle1), Math.sin(angle1)),
                          fs1.length
                       );
        const pointId = world.createEntity();
        const point = new Vector2(-2.0, 0.1);
        const tangents = tangentFromPointToCapsule(point, pos_cap1, tip1, r, cw);
        const tangentLineEntity = world.createEntity();

        world.addComponent(tangentLineEntity, new CableJointComponent(
          pointId, capsule, 0,
          tangents.a_attach,
          tangents.a_capsule
        ));
        world.addComponent(tangentLineEntity, new RenderableComponent('line', '#FFFFFF'));
        world.addComponent(world.createEntity(), new CablePathComponent(world, [tangentLineEntity], ['attachment', 'attachment'], [cw, cw]));

        const ang = Math.PI - Math.atan(0.1/2.0) + Math.acos(1.0/Math.sqrt(4.01));
        const expect_x = Math.cos(ang);
        const expect_y = Math.sin(ang);
        const tol = 1e-6;

        let passed = true;
        passed &= assertNear(point.x, tangents.a_attach.x, tol, testName, "Tangent point.x");
        passed &= assertNear(point.y, tangents.a_attach.y, tol, testName, "Tangent point.y");
        passed &= assertNear(expect_x, tangents.a_capsule.x, tol, testName, "Tangent capsule.x");
        passed &= assertNear(expect_y, tangents.a_capsule.y, tol, testName, "Tangent capsule.y");

        logTestResult(testName, passed);
        return world;
      }
    },

  };

  function runAndVisualizeTest(testName) {
      console.log(`--- Running & Visualizing Test: ${testName} ---`);
      testResultsList.innerHTML = ''; // Clear previous results
      testsPassed = 0;
      testsFailed = 0;

      const testCase = testCases[testName]; // Get the test case object

      if (testCase) {
          const world = testCase.run(); // Run the test function

          // Render the final state
          if (world && canvas) {
              // Get viewport settings from the test case object
              const vp = testCase.viewport;
              // Create a new RenderSystem instance with test-specific viewport settings
              const renderSystem = new RenderSystem(canvas, cScale, simHeight, vp.scale, vp.offsetX, vp.offsetY);
              renderSystem.update(world, 0); // Render the state using the instance's viewport settings
              console.log("--- Render Complete ---");
          } else {
              console.warn("Test function did not return a world or canvas not found.");
          }

          // --- Final Report ---
          const summary = document.createElement('li');
          summary.style.fontWeight = 'bold';
          summary.style.marginTop = '10px';
          summary.textContent = `Finished ${testName}: ${testsPassed} passed, ${testsFailed} failed.`;
          testResultsList.appendChild(summary);
          console.log(`--- Test Run Complete: ${testsPassed} passed, ${testsFailed} failed ---`);

      } else {
          console.error(`Test case "${testName}" not found.`);
          testResultsList.innerHTML = `<li>ERROR: Test case "${testName}" not found.</li>`;
      }
  }

  // --- Event Listeners ---
  const testSelector = document.getElementById('testSelector');
  const runBtn = document.getElementById('runBtn');

  runBtn.addEventListener('click', () => {
      const selectedTest = testSelector.value;
      runAndVisualizeTest(selectedTest);
  });

  // --- Initial Run ---
  // Run the default selected test on load
  runAndVisualizeTest(testSelector.value);

</script>

</body>
</html>
