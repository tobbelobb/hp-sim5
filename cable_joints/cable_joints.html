<!DOCTYPE html>
<html>
<head>
    <title>Cable Joints</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202020; font-family: sans-serif; }
        canvas { border: 1px solid black; display: block; margin: 10px auto; }
        #controls { text-align: center; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div id="controls">
        Score: <span id="score">0</span> |
        <button id="pauseBtn" tabindex="-1">Pause</button>
        <button id="resetBtn" tabindex="-1">Reset</button>
        <button id="stepBtn">Step</button>
    </div>
    <canvas id="myCanvas"></canvas>

<script src="cable_joints_core.js"></script>
<script>
  const canvas = document.getElementById("myCanvas");

  canvas.width = window.innerWidth - 20;
  canvas.height = window.innerHeight - 100;

  const cScale = canvas.height/2;
  const simWidth = canvas.width / cScale;
  const simHeight = canvas.height / cScale;

  let world = new World();

  function setupScene() {
    world.clear(); // Clear entities and components

    // --- Resources ---
    world.setResource('gravity', new Vector2(0.0, -10.0));
    world.setResource('dt', 1.0 / 100.0);
    world.setResource('simWidth', simWidth);
    world.setResource('simHeight', simHeight);
    // Create a component for pause state and store it as a resource for easy access
    world.setResource('pauseState', new PauseStateComponent(true));
    world.setResource('debugRenderPoints', {}); // Initialize empty object for debug points


    // --- Entities and Components ---
    // Ball Entities
    const ballRadius = 0.03;
    const ballRestitution = 0.4; // Slightly higher for more bounce

    const ball1 = world.createEntity();
    world.addComponent(ball1, new BallTagComponent());
    world.addComponent(ball1, new PositionComponent(1.25, 0.6));
    world.addComponent(ball1, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball1, new RadiusComponent(ballRadius));
    world.addComponent(ball1, new MassComponent(0.1001));
    world.addComponent(ball1, new RestitutionComponent(ballRestitution));
    world.addComponent(ball1, new GravityAffectedComponent());
    world.addComponent(ball1, new RenderableComponent('circle', '#FF0000'));

    const ball2 = world.createEntity();
    world.addComponent(ball2, new BallTagComponent());
    world.addComponent(ball2, new PositionComponent(1.6, 0.55));
    world.addComponent(ball2, new VelocityComponent(1.0, 0.0));
    world.addComponent(ball2, new RadiusComponent(ballRadius));
    world.addComponent(ball2, new MassComponent(0.1));
    world.addComponent(ball2, new RestitutionComponent(ballRestitution));
    world.addComponent(ball2, new GravityAffectedComponent());
    world.addComponent(ball2, new RenderableComponent('circle', '#00FF00'));

    // Obstacle Entities
    const obsColor = "#FF8000";
    const obs1 = world.createEntity();
    world.addComponent(obs1, new ObstacleTagComponent());
    world.addComponent(obs1, new PositionComponent(1.5, 1.5));
    world.addComponent(obs1, new MassComponent(-1.0));
    world.addComponent(obs1, new RadiusComponent(0.1));
    world.addComponent(obs1, new RenderableComponent('circle', obsColor));


    // --- Cable Setup ---
    // Path: ball1 -> obs1 -> ball2
    world.addComponent(obs1, new CableLinkComponent());
    world.addComponent(ball1, new CableLinkComponent());
    world.addComponent(ball2, new CableLinkComponent());

    // --- Calculate Initial Cable State ---
    // Need to compute initial attachment points and rest lengths
    // Get relevant components
    const pos_ball1 = world.getComponent(ball1, PositionComponent).pos;
    const link_ball1 = world.getComponent(ball1, CableLinkComponent);
    link_ball1.prevPos = pos_ball1.clone();
    const pos_obs1 = world.getComponent(obs1, PositionComponent).pos;
    const radius_obs1 = world.getComponent(obs1, RadiusComponent).radius;
    const cw_obs1 = true;
    const link_obs1 = world.getComponent(obs1, CableLinkComponent);
    link_obs1.prevPos = pos_obs1.clone();
    const pos_ball2 = world.getComponent(ball2, PositionComponent).pos;
    const link_ball2 = world.getComponent(ball2, CableLinkComponent);
    link_ball2.prevPos = pos_ball2.clone();

    // Calculate initial points for joint1 (ball1 attachment <-> obs1 rolling)
    const initialPoints1 = tangentFromPointToCircle(pos_ball1, pos_obs1, radius_obs1, cw_obs1);
    const initialPoints2 = tangentFromCircleToPoint(pos_ball2, pos_obs1, radius_obs1, cw_obs1);

    // Create Cable Joint Entities with correct initial rest lengths
    const joint1 = world.createEntity(); // ball1 <-> obs1
    const initialDist1 = initialPoints1.a_attach.clone().subtract(initialPoints1.a_circle).length();
    world.addComponent(joint1, new CableJointComponent(
      ball1, obs1, initialDist1, initialPoints1.a_attach, initialPoints1.a_circle)); // Order matters
    world.addComponent(joint1, new RenderableComponent('line', '#FF0000')); // Red line

    const joint2 = world.createEntity(); // obs1 <-> ball2
    const initialDist2 = initialPoints2.a_attach.clone().subtract(initialPoints2.a_circle).length();
    world.addComponent(joint2, new CableJointComponent(
      obs1, ball2, initialDist2, initialPoints2.a_circle, initialPoints2.a_attach)); // Order matters
    world.addComponent(joint2, new RenderableComponent('line', '#FFFF00')); // Yellow line

    const cablePath = world.createEntity();
    world.addComponent(cablePath, new CablePathComponent(world, [joint1, joint2], ['attachment', 'rolling', 'attachment'], [true, true, true])); // Order matters


    const offset_x = 0.3;

    const ball3 = world.createEntity();
    world.addComponent(ball3, new BallTagComponent());
    world.addComponent(ball3, new PositionComponent(1.35 + offset_x, 0.4));
    world.addComponent(ball3, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball3, new RadiusComponent(ballRadius));
    world.addComponent(ball3, new MassComponent(0.1001));
    world.addComponent(ball3, new RestitutionComponent(ballRestitution));
    world.addComponent(ball3, new GravityAffectedComponent());
    world.addComponent(ball3, new RenderableComponent('circle', '#FF0000'));

    const ball4 = world.createEntity();
    world.addComponent(ball4, new BallTagComponent());
    world.addComponent(ball4, new PositionComponent(1.6 + offset_x, 0.4));
    world.addComponent(ball4, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball4, new RadiusComponent(ballRadius));
    world.addComponent(ball4, new MassComponent(0.1));
    world.addComponent(ball4, new RestitutionComponent(ballRestitution));
    world.addComponent(ball4, new GravityAffectedComponent());
    world.addComponent(ball4, new RenderableComponent('circle', '#00FF00'));

    // Obstacle Entities
    const obs2 = world.createEntity();
    world.addComponent(obs2, new ObstacleTagComponent());
    world.addComponent(obs2, new PositionComponent(1.5 + offset_x, 1.5));
    world.addComponent(obs2, new MassComponent(-1.0));
    world.addComponent(obs2, new RadiusComponent(0.1));
    world.addComponent(obs2, new RenderableComponent('circle', obsColor));


    // --- Cable Setup ---
    // Path: ball3 -> obs2 -> ball4
    world.addComponent(obs2, new CableLinkComponent());
    world.addComponent(ball3, new CableLinkComponent());
    world.addComponent(ball4, new CableLinkComponent());

    // --- Calculate Initial Cable State ---
    // Need to compute initial attachment points and rest lengths
    // Get relevant components
    const pos_ball3 = world.getComponent(ball3, PositionComponent).pos;
    const link_ball3 = world.getComponent(ball3, CableLinkComponent);
    link_ball3.prevPos = pos_ball3.clone();
    const pos_obs2 = world.getComponent(obs2, PositionComponent).pos;
    const radius_obs2 = world.getComponent(obs2, RadiusComponent).radius;
    const cw_obs2 = true;
    const link_obs2 = world.getComponent(obs2, CableLinkComponent);
    link_obs2.prevPos = pos_obs2.clone();
    const pos_ball4 = world.getComponent(ball4, PositionComponent).pos;
    const link_ball4 = world.getComponent(ball4, CableLinkComponent);
    link_ball4.prevPos = pos_ball4.clone();

    // Calculate initial points for joint1 (ball3 attachment <-> obs2 rolling)
    const initialPoints3 = tangentFromPointToCircle(pos_ball3, pos_obs2, radius_obs2, cw_obs2);
    const initialPoints4 = tangentFromCircleToPoint(pos_ball4, pos_obs2, radius_obs2, cw_obs2);

    // Create Cable Joint Entities with correct initial rest lengths
    const joint3 = world.createEntity(); // ball3 <-> obs2
    const initialDist3 = initialPoints3.a_attach.clone().subtract(initialPoints3.a_circle).length();
    world.addComponent(joint3, new CableJointComponent(
      ball3, obs2, initialDist3, initialPoints3.a_attach, initialPoints3.a_circle)); // Order matters
    world.addComponent(joint3, new RenderableComponent('line', '#FF0000')); // Red line

    const joint4 = world.createEntity(); // obs2 <-> ball4
    const initialDist4 = initialPoints4.a_attach.clone().subtract(initialPoints4.a_circle).length();
    world.addComponent(joint4, new CableJointComponent(
      obs2, ball4, initialDist4, initialPoints4.a_circle, initialPoints4.a_attach)); // Order matters
    world.addComponent(joint4, new RenderableComponent('line', '#FFFF00')); // Yellow line

    const cablePath2 = world.createEntity();
    world.addComponent(cablePath2, new CablePathComponent(world, [joint3, joint4], ['attachment', 'rolling', 'attachment'], [true, true, true])); // Order matters



    // --- Systems Registration (Order Matters!) ---
    if (world.systems.length === 0) { // Only register systems once
      world.registerSystem(new GravitySystem());      // Applies gravity acceleration
      world.registerSystem(new MovementSystem());     // Updates position based on velocity

      // --- Cable Systems (Run BEFORE constraint solving) ---

      world.registerSystem(new PBDBallBallCollisions());
      world.registerSystem(new PBDBallObstacleCollisions());
      world.registerSystem(new CableAttachmentUpdateSystem()); // Updates attachment points and rest lengths
      world.registerSystem(new PBDCableConstraintSolver());

      // Pass viewport settings to RenderSystem constructor
      const renderSystem = new RenderSystem(canvas, cScale, simHeight, 1.0, 1.5, 0.7); // Create instance
      world.registerSystem(renderSystem); // Register it
      world.setResource('renderSystem', renderSystem); // Store it as a resource
    }

    // Update button text based on initial pause state
    const pauseState = world.getResource('pauseState');
    pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
  }


  // --- Main Loop ---
  let lastTime = 0;
  let doStep = false;

  function loop(currentTime) {
    const dt = world.getResource('dt');
    const pauseState = world.getResource('pauseState');

    if (!pauseState.paused || doStep) {
      if (doStep) pauseState.paused = false;
      console.log("----------------------------------------------");
      world.update(dt);
      if (doStep) pauseState.paused = true;
      doStep = false;
    }

    requestAnimationFrame(loop);
  }

  // --- Event Listeners ---
  pauseBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const pauseState = world.getResource('pauseState');
    if (pauseState) {
      pauseState.paused = !pauseState.paused;
      pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
    }
  });

  resetBtn.addEventListener('click', (e) => {
    e.preventDefault();
    setupScene();
    const pauseState = world.getResource('pauseState');
    if (pauseState) pauseState.paused = true;
    pauseBtn.textContent = "Resume";

    // --- Initial render ---
    const initialRenderSystem = world.getResource('renderSystem');
    if (initialRenderSystem) {
        // Call update directly. dt value doesn't matter much here as RenderSystem
        // ignores it and runs even if paused. Pass 0 for clarity.
        initialRenderSystem.update(world, 0);
    }
    doStep = false;
  });

  stepBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const pauseState = world.getResource('pauseState');
    if (pauseState && pauseState.paused) {
      doStep = true;
    }
  });

  // --- Start ---
  setupScene();

  // --- Initial render ---
  const initialRenderSystem = world.getResource('renderSystem');
  if (initialRenderSystem) {
      // Call update directly. dt value doesn't matter much here as RenderSystem
      // ignores it and runs even if paused. Pass 0 for clarity.
      initialRenderSystem.update(world, 0);
  }

  requestAnimationFrame(loop);

</script>

</body>
</html>
