<!DOCTYPE html>
<html>
<head>
    <title>Cable Joints</title>
    <style>
        body { margin: 0; overflow-y: auto; background-color: #202020; font-family: sans-serif; }
        canvas { border: 1px solid black; display: block; margin: 10px auto; }
        #controls { text-align: center; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div id="controls">
        Score: <span id="score">0</span> |
        <button id="pauseBtn" tabindex="-1">Pause</button>
        <button id="resetBtn" tabindex="-1">Reset</button>
        <button id="stepBtn">Step</button>
    </div>
    <canvas id="myCanvas"></canvas>
    <div id="errorInfo" style="text-align: center; color: red; font-weight: bold; margin-top: 10px; display: none;">
        An error occurred! Copy the state below to create a test case:
    </div>
    <textarea id="errorDumpOutput" readonly style="width: 90%; height: 100vh; display: none; margin: 10px auto; font-family: monospace; background-color: #333; color: #eee; border: 1px solid #888;"></textarea>

<script src="cable_joints_core.js"></script>
<script>
  const canvas = document.getElementById("myCanvas");
  const errorInfoDiv = document.getElementById("errorInfo"); // Get error elements
  const errorDumpOutput = document.getElementById("errorDumpOutput");

  canvas.width = window.innerWidth - 20;
  canvas.height = window.innerHeight - 120; // Adjust height slightly for error output

  const cScale = canvas.height/2;
  const simWidth = canvas.width / cScale;
  const simHeight = canvas.height / cScale;

  let world = new World();

  function setupScene() {
    errorInfoDiv.style.display = 'none'; // Hide error area
    errorDumpOutput.style.display = 'none';
    errorDumpOutput.value = ''; // Clear previous dump

    world.clear(); // Clear entities and components

    // --- Resources ---
    world.setResource('gravity', new Vector2(0.0, -10.0));
    world.setResource('dt', 1.0 / 200.0);
    world.setResource('simWidth', simWidth);
    world.setResource('simHeight', simHeight);
    world.setResource('pauseState', new PauseStateComponent(true));
    world.setResource('errorState', new SimulationErrorStateComponent(false));
    world.setResource('debugRenderPoints', {});


    // --- Entities and Components ---
    // Ball Entities
    const ballRadius = 0.03;
    const ballRestitution = 0.4;

    const ball1 = world.createEntity();
    world.addComponent(ball1, new BallTagComponent());
    world.addComponent(ball1, new PositionComponent(1.25, 0.6));
    world.addComponent(ball1, new VelocityComponent(2.40, 10.0));
    world.addComponent(ball1, new RadiusComponent(ballRadius));
    world.addComponent(ball1, new MassComponent(0.1001));
    world.addComponent(ball1, new RestitutionComponent(ballRestitution));
    world.addComponent(ball1, new GravityAffectedComponent());
    world.addComponent(ball1, new RenderableComponent('circle', '#FF0000'));

    const ball2 = world.createEntity();
    world.addComponent(ball2, new BallTagComponent());
    world.addComponent(ball2, new PositionComponent(1.6, 0.55));
    world.addComponent(ball2, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball2, new RadiusComponent(ballRadius));
    world.addComponent(ball2, new MassComponent(0.1));
    world.addComponent(ball2, new RestitutionComponent(ballRestitution));
    world.addComponent(ball2, new GravityAffectedComponent());
    world.addComponent(ball2, new RenderableComponent('circle', '#00FF00'));

    // Obstacle Entities
    const obsColor = "#FF8000";
    const obs1 = world.createEntity();
    world.addComponent(obs1, new ObstacleTagComponent());
    world.addComponent(obs1, new PositionComponent(0.3, 1.5));
    world.addComponent(obs1, new MassComponent(-1.0));
    world.addComponent(obs1, new RadiusComponent(0.1));
    world.addComponent(obs1, new RenderableComponent('circle', obsColor));

    // â† add these two lines:
    world.addComponent(obs1, new FlipperStateComponent(
       /* length= */ 0.5,
       /* restAngle= */ 0.0,
       /* maxRotation= */ 0.0,
       /* angularVelocity= */ 0.0
    ));
    world.addComponent(obs1, new FlipperTagComponent());


    // --- Cable Setup ---
    // Path: ball1 -> obs1 -> ball2
    world.addComponent(obs1, new CableLinkComponent());
    world.addComponent(ball1, new CableLinkComponent());
    world.addComponent(ball2, new CableLinkComponent());

    // --- Calculate Initial Cable State ---
    // Need to compute initial attachment points and rest lengths
    // Get relevant components
    const pos_ball1 = world.getComponent(ball1, PositionComponent).pos;
    const pos_obs1 = world.getComponent(obs1, PositionComponent).pos;
    const radius_obs1 = world.getComponent(obs1, RadiusComponent).radius;
    const cw_obs1 = true;
    const pos_ball2 = world.getComponent(ball2, PositionComponent).pos;

    // Calculate initial points for joint1 (ball1 attachment <-> obs1 rolling)
    const initialPoints1 = tangentFromPointToCircle(pos_ball1, pos_obs1, radius_obs1, cw_obs1);
    const initialPoints2 = tangentFromCircleToPoint(pos_ball2, pos_obs1, radius_obs1, cw_obs1);

    // Create Cable Joint Entities with correct initial rest lengths
    const joint1 = world.createEntity(); // ball1 <-> obs1
    const initialDist1 = initialPoints1.a_attach.clone().subtract(initialPoints1.a_circle).length();
    world.addComponent(joint1, new CableJointComponent(
      ball1, obs1, initialDist1, initialPoints1.a_attach, initialPoints1.a_circle)); // Order matters
    world.addComponent(joint1, new RenderableComponent('line', '#FF0000')); // Red line

    const joint2 = world.createEntity(); // obs1 <-> ball2
    const initialDist2 = initialPoints2.a_attach.clone().subtract(initialPoints2.a_circle).length();
    world.addComponent(joint2, new CableJointComponent(
      obs1, ball2, initialDist2, initialPoints2.a_circle, initialPoints2.a_attach)); // Order matters
    world.addComponent(joint2, new RenderableComponent('line', '#FFFF00')); // Yellow line

    const cablePath = world.createEntity();
    // CablePathComponent constructor now calculates initial stored length and totalRestLength
    const pathComp1 = new CablePathComponent(world, [joint1, joint2], ['attachment', 'rolling', 'attachment'], [true, true, true]); // Order matters
    world.addComponent(cablePath, pathComp1);


    const offset_x = 0.3;

    const ball3 = world.createEntity();
    world.addComponent(ball3, new BallTagComponent());
    world.addComponent(ball3, new PositionComponent(1.35 + offset_x, 0.4));
    world.addComponent(ball3, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball3, new RadiusComponent(ballRadius));
    world.addComponent(ball3, new MassComponent(0.1001));
    world.addComponent(ball3, new RestitutionComponent(ballRestitution));
    world.addComponent(ball3, new GravityAffectedComponent());
    world.addComponent(ball3, new RenderableComponent('circle', '#FF0000'));

    const ball4 = world.createEntity();
    world.addComponent(ball4, new BallTagComponent());
    world.addComponent(ball4, new PositionComponent(1.6 + offset_x, 0.4));
    world.addComponent(ball4, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball4, new RadiusComponent(ballRadius));
    world.addComponent(ball4, new MassComponent(0.1));
    world.addComponent(ball4, new RestitutionComponent(ballRestitution));
    world.addComponent(ball4, new GravityAffectedComponent());
    world.addComponent(ball4, new RenderableComponent('circle', '#00FF00'));

    // Obstacle Entities
    const obs2 = world.createEntity();
    world.addComponent(obs2, new ObstacleTagComponent());
    world.addComponent(obs2, new PositionComponent(1.5 + offset_x, 1.5));
    world.addComponent(obs2, new MassComponent(-1.0));
    world.addComponent(obs2, new RadiusComponent(0.1));
    world.addComponent(obs2, new RenderableComponent('circle', obsColor));


    // --- Cable Setup ---
    // Path: ball3 -> obs2 -> ball4
    world.addComponent(obs2, new CableLinkComponent());
    world.addComponent(ball3, new CableLinkComponent());
    world.addComponent(ball4, new CableLinkComponent());

    // --- Calculate Initial Cable State ---
    // Need to compute initial attachment points and rest lengths
    // Get relevant components
    const pos_ball3 = world.getComponent(ball3, PositionComponent).pos;
    const pos_obs2 = world.getComponent(obs2, PositionComponent).pos;
    const radius_obs2 = world.getComponent(obs2, RadiusComponent).radius;
    const cw_obs2 = true;
    const pos_ball4 = world.getComponent(ball4, PositionComponent).pos;

    // Calculate initial points for joint1 (ball3 attachment <-> obs2 rolling)
    const initialPoints3 = tangentFromPointToCircle(pos_ball3, pos_obs2, radius_obs2, cw_obs2);
    const initialPoints4 = tangentFromCircleToPoint(pos_ball4, pos_obs2, radius_obs2, cw_obs2);

    // Create Cable Joint Entities with correct initial rest lengths
    const joint3 = world.createEntity(); // ball3 <-> obs2
    const initialDist3 = initialPoints3.a_attach.clone().subtract(initialPoints3.a_circle).length();
    world.addComponent(joint3, new CableJointComponent(
      ball3, obs2, initialDist3, initialPoints3.a_attach, initialPoints3.a_circle)); // Order matters
    world.addComponent(joint3, new RenderableComponent('line', '#FF0000')); // Red line

    const joint4 = world.createEntity(); // obs2 <-> ball4
    const initialDist4 = initialPoints4.a_attach.clone().subtract(initialPoints4.a_circle).length();
    world.addComponent(joint4, new CableJointComponent(
      obs2, ball4, initialDist4, initialPoints4.a_circle, initialPoints4.a_attach)); // Order matters
    world.addComponent(joint4, new RenderableComponent('line', '#FFFF00')); // Yellow line

    const cablePath2 = world.createEntity();
    // CablePathComponent constructor now calculates initial stored length and totalRestLength
    const pathComp2 = new CablePathComponent(world, [joint3, joint4], ['attachment', 'rolling', 'attachment'], [true, true, true]); // Order matters
    world.addComponent(cablePath2, pathComp2);



    // --- Systems Registration (Order Matters!) ---
    if (world.systems.length === 0) { // Only register systems once
      world.registerSystem(new GravitySystem());
      world.registerSystem(new MovementSystem());
      world.registerSystem(new PBDBallBallCollisions());
      world.registerSystem(new PBDBallObstacleCollisions());
      world.registerSystem(new CableAttachmentUpdateSystem());
      world.registerSystem(new PBDCableConstraintSolver());
      const renderSystem = new RenderSystem(canvas, cScale, simHeight, 0.8, 1.5, 0.4);
      world.registerSystem(renderSystem);
      world.setResource('renderSystem', renderSystem);
    }

    // Update button text based on initial pause state
    const pauseState = world.getResource('pauseState');
    pauseBtn.textContent = pauseState.paused ? "Start" : "Pause";
  }


  // --- Main Loop ---
  let lastTime = 0;
  let doStep = false;

  function loop(currentTime) {
    const dt = world.getResource('dt');
    const pauseState = world.getResource('pauseState');
    const errorState = world.getResource('errorState');

    // Check error state from the resource
    if (!errorState.hasError && (!pauseState.paused || doStep)) {
      if (doStep) pauseState.paused = false; // Temporarily unpause for step
      try {
          console.log("----------------------------------------------");
          world.update(dt);
      } catch (error) {
          console.error("!!! Simulation Error Caught !!!", error);
          if (errorState) errorState.hasError = true;
          if (pauseState) pauseState.paused = true;
          pauseBtn.textContent = "Resume (Error)";
          pauseBtn.disabled = true;
          stepBtn.disabled = true;

          // Dump the world state
          try {
              const stateDump = dumpWorldState(world);
              errorDumpOutput.value = stateDump;
              errorInfoDiv.style.display = 'block';
              errorDumpOutput.style.display = 'block';
              console.log("--- World State Dumped (Copy from text area below canvas) ---");
          } catch (dumpError) {
              console.error("!!! Error during state dumping !!!", dumpError);
              errorDumpOutput.value = `Error during state dumping: ${dumpError}\n\nOriginal error: ${error}`;
              errorInfoDiv.style.display = 'block';
              errorDumpOutput.style.display = 'block';
          }
      } finally {
          if (doStep) {
              if (pauseState) pauseState.paused = true; // Re-pause after step if it was a step
              if (errorState && !errorState.hasError) pauseBtn.textContent = "Resume";
          }
          doStep = false;
      }
    }

    requestAnimationFrame(loop);
  }

  // --- Event Listeners ---
  pauseBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const errorState = world.getResource('errorState');
    if (errorState && errorState.hasError) return;
    const pauseState = world.getResource('pauseState');
    if (pauseState) {
      pauseState.paused = !pauseState.paused;
      pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
    }
  });

  resetBtn.addEventListener('click', (e) => {
    e.preventDefault();
    setupScene();
    const pauseState = world.getResource('pauseState');
    if (pauseState) pauseState.paused = true;
    pauseBtn.textContent = "Start";
    pauseBtn.disabled = false;
    stepBtn.disabled = false;

    const initialRenderSystem = world.getResource('renderSystem');
    if (initialRenderSystem) {
        initialRenderSystem.update(world, 0);
    }
    doStep = false;
  });

  stepBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const errorState = world.getResource('errorState');
    if (errorState && errorState.hasError) return;
    const pauseState = world.getResource('pauseState');
    if (pauseState && pauseState.paused) {
      doStep = true;
    }
  });

  // --- Start ---
  setupScene();
  world.getResource('renderSystem').update(world, 0);
  requestAnimationFrame(loop);

</script>

</body>
</html>
