<!DOCTYPE html>
<html>
<head>
    <title>Cable Joints</title>
    <style>
        body { margin: 0; overflow-y: auto; background-color: #202020; font-family: sans-serif; }
        canvas { border: 1px solid black; display: block; margin: 10px auto; }
        #controls { text-align: center; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div id="controls">
        Score: <span id="score">0</span> |
        <button id="pauseBtn" tabindex="-1">Pause</button>
        <button id="resetBtn" tabindex="-1">Reset</button>
        <button id="stepBtn">Step</button>
    </div>
    <canvas id="myCanvas"></canvas>
    <div id="errorInfo" style="text-align: center; color: red; font-weight: bold; margin-top: 10px; display: none;">
        An error occurred! Copy the state below to create a test case:
    </div>
    <textarea id="errorDumpOutput" readonly style="width: 90%; height: 100vh; display: none; margin: 10px auto; font-family: monospace; background-color: #333; color: #eee; border: 1px solid #888;"></textarea>

<script src="cable_joints_core.js"></script>
<script>
  const canvas = document.getElementById("myCanvas");
  const errorInfoDiv = document.getElementById("errorInfo"); // Get error elements
  const errorDumpOutput = document.getElementById("errorDumpOutput");

  canvas.width = window.innerWidth - 20;
  canvas.height = window.innerHeight - 120; // Adjust height slightly for error output

  const cScale = canvas.height/2;
  const simWidth = canvas.width / cScale;
  const simHeight = canvas.height / cScale;

  let world = new World();
  // let simulationStopped = false; // Flag removed, now managed by SimulationErrorStateComponent resource

  // --- State Dumping Function ---
  function dumpWorldState(world) {
    const renderSystem = world.getResource('renderSystem');
    const viewportScale = renderSystem ? renderSystem.viewScaleMultiplier : 1.0;
    const viewportOffsetX = renderSystem ? renderSystem.viewOffsetX_sim : 0.0;
    const viewportOffsetY = renderSystem ? renderSystem.viewOffsetY_sim : 0.0;

    let dump = `
// --- Generated Error Test Case ---
testGeneratedError: {
  // Viewport settings from the time of the error
  viewport: { scale: ${viewportScale}, offsetX: ${viewportOffsetX}, offsetY: ${viewportOffsetY} },
  run: function() {
    const testName = "Generated Error Case";
    const world = new World();
    window.testWorld = world; // Set global world
    world.setResource('dt', ${world.getResource('dt')});
    world.setResource('debugRenderPoints', {});
    world.setResource('simWidth', ${world.getResource('simWidth')});
    world.setResource('simHeight', ${world.getResource('simHeight')});

    // --- Resources ---
`;
    // Dump simple resources (add more as needed)
    const gravity = world.getResource('gravity');
    if (gravity) {
        dump += `    world.setResource('gravity', new Vector2(${gravity.x}, ${gravity.y}));\n`;
    }
    const errorState = world.getResource('errorState');
    if (errorState) {
        dump += `    world.setResource('errorState', new SimulationErrorStateComponent(${errorState.hasError}));\n`;
    }
    // Note: pauseState is usually set by the test runner or UI
    // Note: renderSystem is created by the test runner

    dump += `
    // --- Entities and Components ---
`;
    const entityVarMap = new Map(); // Map original entityId to generated variable name

    // First pass: Create entities and map IDs
    for (const entityId of world.entities.keys()) {
        const varName = `entity${entityId}`;
        entityVarMap.set(entityId, varName);
        dump += `    const ${varName} = world.createEntity(); // Original ID: ${entityId}\n`;
    }
    dump += "\n"; // Add a newline for separation

    // Second pass: Add components
    for (const entityId of world.entities.keys()) {
        const varName = entityVarMap.get(entityId);
        const componentClasses = world.entities.get(entityId);
        if (!componentClasses) continue;

        for (const componentClass of componentClasses) {
            const component = world.getComponent(entityId, componentClass);
            if (!component) continue;

            let addCompStr = `    world.addComponent(${varName}, new ${componentClass.name}(`;

            // Serialize component data based on type
            switch (componentClass.name) {
                case 'PositionComponent':
                    addCompStr += `${component.pos.x}, ${component.pos.y}`;
                    break;
                case 'VelocityComponent':
                    addCompStr += `${component.vel.x}, ${component.vel.y}`;
                    break;
                case 'RadiusComponent':
                    addCompStr += `${component.radius}`;
                    break;
                case 'MassComponent':
                    addCompStr += `${component.mass}`;
                    break;
                case 'RestitutionComponent':
                    addCompStr += `${component.restitution}`;
                    break;
                case 'RenderableComponent':
                    addCompStr += `'${component.shape}', '${component.color}'`;
                    break;
                case 'CableLinkComponent':
                    addCompStr += `${component.prevPos.x}, ${component.prevPos.y}`;
                    break;
                case 'CableJointComponent':
                    const entityAVar = entityVarMap.get(component.entityA);
                    const entityBVar = entityVarMap.get(component.entityB);
                    if (!entityAVar || !entityBVar) {
                        console.warn(`Could not find variable names for entities ${component.entityA} or ${component.entityB} in joint ${entityId}`);
                        addCompStr = `    // Skipped CableJointComponent for ${varName} due to missing entity mapping\n`;
                    } else {
                        addCompStr += `${entityAVar}, ${entityBVar}, ${component.restLength}, `;
                        addCompStr += `new Vector2(${component.attachmentPointA_world.x}, ${component.attachmentPointA_world.y}), `;
                        addCompStr += `new Vector2(${component.attachmentPointB_world.x}, ${component.attachmentPointB_world.y})`;
                    }
                    break;
                // Add cases for other components if needed
                // Tag components have no constructor arguments
                case 'GravityAffectedComponent':
                case 'BallTagComponent':
                case 'ObstacleTagComponent':
                case 'PauseStateComponent': // Usually a resource, but handle if added to entity
                case 'SimulationErrorStateComponent': // Usually a resource, but handle if added to entity
                     if (componentClass.name === 'PauseStateComponent') {
                         addCompStr += component.paused;
                     } else if (componentClass.name === 'SimulationErrorStateComponent') {
                         addCompStr += component.hasError;
                     }
                    break;
                case 'CablePathComponent':
                    // Handled separately
                    break;
                default:
                    console.warn(`Unhandled component type for serialization: ${componentClass.name}`);
                    addCompStr = `    // Skipped unknown component ${componentClass.name} for ${varName}\n`;

            }
             if (!addCompStr.endsWith('\n')) { // Avoid adding extra parenthesis if skipped or handled above
                addCompStr += '));\n';
            }
            dump += addCompStr;
        }
         dump += "\n"; // Add a newline between entities
    }
    for (const entityId of world.entities.keys()) {
        const varName = entityVarMap.get(entityId);
        const componentClasses = world.entities.get(entityId);
        if (!componentClasses) continue;

        for (const componentClass of componentClasses) {
            const component = world.getComponent(entityId, componentClass);
            if (!component) continue;
            let addCompStr = "";
            // Register paths last. They depend on everything else being defined first
            if (componentClass.name === 'CablePathComponent') {
                addCompStr += `    world.addComponent(${varName}, new ${componentClass.name}(`;
                const jointVars = component.jointEntities.map(id => entityVarMap.get(id)).filter(Boolean);
                if (jointVars.length !== component.jointEntities.length) {
                     console.warn(`Could not find variable names for all joints in path ${entityId}`);
                     addCompStr = `    // Skipped CablePathComponent for ${varName} due to missing joint mapping\n`;
                } else {
                    addCompStr += `world, [${jointVars.join(', ')}], `;
                    addCompStr += `[${component.linkTypes.map(t => `'${t}'`).join(', ')}], `;
                    addCompStr += `[${component.cw.join(', ')}]`;
                    // Need to manually set stored and totalRestLength after creation in the test
                    addCompStr += `));\n`;
                    addCompStr += `    const pathComp_${varName} = world.getComponent(${varName}, CablePathComponent);\n`;
                    addCompStr += `    pathComp_${varName}.stored = [${component.stored.join(', ')}];\n`;
                    addCompStr += `    pathComp_${varName}.totalRestLength = ${component.totalRestLength};\n`;
                    dump += addCompStr;
                    continue; // Skip the default closing parenthesis below
                }
            }
            if (!addCompStr.endsWith('\n') && addCompStr !== "") { // Avoid adding extra parenthesis if skipped or handled above
                addCompStr += '));\n';
            }
            dump += addCompStr;
        }
        dump += "\n"; // Add a newline between entities
    }

    dump += `
    // --- Systems Registration (Copy from a working test or main file if needed) ---
    // world.registerSystem(new CableAttachmentUpdateSystem());
    // world.registerSystem(new PBDCableConstraintSolver());
    // ... etc ...

    // --- Run the system that caused the error (or the full update) ---
    // const system = new SpecificSystem();
    // system.update(world, world.getResource('dt'));
    // OR
    // world.update(world.getResource('dt')); // If the error happens during the full update cycle

    // --- Assertions (Add assertions here to verify the error or expected state) ---
    // assertTrue(..., testName, "Some condition");

    logTestResult(testName, false, "Generated test case - needs verification and assertions");
    return world; // Return world for rendering
  }
},
`;
    return dump;
  }


  function setupScene() {
    // simulationStopped = false; // Reset error flag - Handled by setting resource below
    errorInfoDiv.style.display = 'none'; // Hide error area
    errorDumpOutput.style.display = 'none';
    errorDumpOutput.value = ''; // Clear previous dump

    world.clear(); // Clear entities and components

    // --- Resources ---
    world.setResource('gravity', new Vector2(0.0, -10.0));
    world.setResource('dt', 1.0 / 100.0);
    world.setResource('simWidth', simWidth);
    world.setResource('simHeight', simHeight);
    // Create components for pause and error state and store them as resources
    world.setResource('pauseState', new PauseStateComponent(true));
    world.setResource('errorState', new SimulationErrorStateComponent(false)); // Initialize error state to false
    world.setResource('debugRenderPoints', {}); // Initialize empty object for debug points


    // --- Entities and Components ---
    // Ball Entities
    const ballRadius = 0.03;
    const ballRestitution = 0.4; // Slightly higher for more bounce

    const ball1 = world.createEntity();
    world.addComponent(ball1, new BallTagComponent());
    world.addComponent(ball1, new PositionComponent(1.25, 0.6));
    world.addComponent(ball1, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball1, new RadiusComponent(ballRadius));
    world.addComponent(ball1, new MassComponent(0.1001));
    world.addComponent(ball1, new RestitutionComponent(ballRestitution));
    world.addComponent(ball1, new GravityAffectedComponent());
    world.addComponent(ball1, new RenderableComponent('circle', '#FF0000'));

    const ball2 = world.createEntity();
    world.addComponent(ball2, new BallTagComponent());
    world.addComponent(ball2, new PositionComponent(1.6, 0.55));
    world.addComponent(ball2, new VelocityComponent(-1.0, 5.0));
    world.addComponent(ball2, new RadiusComponent(ballRadius));
    world.addComponent(ball2, new MassComponent(0.1));
    world.addComponent(ball2, new RestitutionComponent(ballRestitution));
    world.addComponent(ball2, new GravityAffectedComponent());
    world.addComponent(ball2, new RenderableComponent('circle', '#00FF00'));

    // Obstacle Entities
    const obsColor = "#FF8000";
    const obs1 = world.createEntity();
    world.addComponent(obs1, new ObstacleTagComponent());
    world.addComponent(obs1, new PositionComponent(1.5, 1.5));
    world.addComponent(obs1, new MassComponent(-1.0));
    world.addComponent(obs1, new RadiusComponent(0.1));
    world.addComponent(obs1, new RenderableComponent('circle', obsColor));


    // --- Cable Setup ---
    // --- Cable Setup ---
    // Path: ball1 -> obs1 -> ball2
    world.addComponent(obs1, new CableLinkComponent());
    world.addComponent(ball1, new CableLinkComponent());
    world.addComponent(ball2, new CableLinkComponent());

    // --- Calculate Initial Cable State ---
    // Need to compute initial attachment points and rest lengths
    // Get relevant components
    const pos_ball1 = world.getComponent(ball1, PositionComponent).pos;
    const link_ball1 = world.getComponent(ball1, CableLinkComponent);
    link_ball1.prevPos = pos_ball1.clone();
    const pos_obs1 = world.getComponent(obs1, PositionComponent).pos;
    const radius_obs1 = world.getComponent(obs1, RadiusComponent).radius;
    const cw_obs1 = true;
    const link_obs1 = world.getComponent(obs1, CableLinkComponent);
    link_obs1.prevPos = pos_obs1.clone();
    const pos_ball2 = world.getComponent(ball2, PositionComponent).pos;
    const link_ball2 = world.getComponent(ball2, CableLinkComponent);
    link_ball2.prevPos = pos_ball2.clone();

    // Calculate initial points for joint1 (ball1 attachment <-> obs1 rolling)
    const initialPoints1 = tangentFromPointToCircle(pos_ball1, pos_obs1, radius_obs1, cw_obs1);
    const initialPoints2 = tangentFromCircleToPoint(pos_ball2, pos_obs1, radius_obs1, cw_obs1);

    // Create Cable Joint Entities with correct initial rest lengths
    const joint1 = world.createEntity(); // ball1 <-> obs1
    const initialDist1 = initialPoints1.a_attach.clone().subtract(initialPoints1.a_circle).length();
    world.addComponent(joint1, new CableJointComponent(
      ball1, obs1, initialDist1, initialPoints1.a_attach, initialPoints1.a_circle)); // Order matters
    world.addComponent(joint1, new RenderableComponent('line', '#FF0000')); // Red line

    const joint2 = world.createEntity(); // obs1 <-> ball2
    const initialDist2 = initialPoints2.a_attach.clone().subtract(initialPoints2.a_circle).length();
    world.addComponent(joint2, new CableJointComponent(
      obs1, ball2, initialDist2, initialPoints2.a_circle, initialPoints2.a_attach)); // Order matters
    world.addComponent(joint2, new RenderableComponent('line', '#FFFF00')); // Yellow line

    const cablePath = world.createEntity();
    // CablePathComponent constructor now calculates initial stored length and totalRestLength
    const pathComp1 = new CablePathComponent(world, [joint1, joint2], ['attachment', 'rolling', 'attachment'], [true, true, true]); // Order matters
    world.addComponent(cablePath, pathComp1);


    const offset_x = 0.3;

    const ball3 = world.createEntity();
    world.addComponent(ball3, new BallTagComponent());
    world.addComponent(ball3, new PositionComponent(1.35 + offset_x, 0.4));
    world.addComponent(ball3, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball3, new RadiusComponent(ballRadius));
    world.addComponent(ball3, new MassComponent(0.1001));
    world.addComponent(ball3, new RestitutionComponent(ballRestitution));
    world.addComponent(ball3, new GravityAffectedComponent());
    world.addComponent(ball3, new RenderableComponent('circle', '#FF0000'));

    const ball4 = world.createEntity();
    world.addComponent(ball4, new BallTagComponent());
    world.addComponent(ball4, new PositionComponent(1.6 + offset_x, 0.4));
    world.addComponent(ball4, new VelocityComponent(0.0, 0.0));
    world.addComponent(ball4, new RadiusComponent(ballRadius));
    world.addComponent(ball4, new MassComponent(0.1));
    world.addComponent(ball4, new RestitutionComponent(ballRestitution));
    world.addComponent(ball4, new GravityAffectedComponent());
    world.addComponent(ball4, new RenderableComponent('circle', '#00FF00'));

    // Obstacle Entities
    const obs2 = world.createEntity();
    world.addComponent(obs2, new ObstacleTagComponent());
    world.addComponent(obs2, new PositionComponent(1.5 + offset_x, 1.5));
    world.addComponent(obs2, new MassComponent(-1.0));
    world.addComponent(obs2, new RadiusComponent(0.1));
    world.addComponent(obs2, new RenderableComponent('circle', obsColor));


    // --- Cable Setup ---
    // Path: ball3 -> obs2 -> ball4
    world.addComponent(obs2, new CableLinkComponent());
    world.addComponent(ball3, new CableLinkComponent());
    world.addComponent(ball4, new CableLinkComponent());

    // --- Calculate Initial Cable State ---
    // Need to compute initial attachment points and rest lengths
    // Get relevant components
    const pos_ball3 = world.getComponent(ball3, PositionComponent).pos;
    const link_ball3 = world.getComponent(ball3, CableLinkComponent);
    link_ball3.prevPos = pos_ball3.clone();
    const pos_obs2 = world.getComponent(obs2, PositionComponent).pos;
    const radius_obs2 = world.getComponent(obs2, RadiusComponent).radius;
    const cw_obs2 = true;
    const link_obs2 = world.getComponent(obs2, CableLinkComponent);
    link_obs2.prevPos = pos_obs2.clone();
    const pos_ball4 = world.getComponent(ball4, PositionComponent).pos;
    const link_ball4 = world.getComponent(ball4, CableLinkComponent);
    link_ball4.prevPos = pos_ball4.clone();

    // Calculate initial points for joint1 (ball3 attachment <-> obs2 rolling)
    const initialPoints3 = tangentFromPointToCircle(pos_ball3, pos_obs2, radius_obs2, cw_obs2);
    const initialPoints4 = tangentFromCircleToPoint(pos_ball4, pos_obs2, radius_obs2, cw_obs2);

    // Create Cable Joint Entities with correct initial rest lengths
    const joint3 = world.createEntity(); // ball3 <-> obs2
    const initialDist3 = initialPoints3.a_attach.clone().subtract(initialPoints3.a_circle).length();
    world.addComponent(joint3, new CableJointComponent(
      ball3, obs2, initialDist3, initialPoints3.a_attach, initialPoints3.a_circle)); // Order matters
    world.addComponent(joint3, new RenderableComponent('line', '#FF0000')); // Red line

    const joint4 = world.createEntity(); // obs2 <-> ball4
    const initialDist4 = initialPoints4.a_attach.clone().subtract(initialPoints4.a_circle).length();
    world.addComponent(joint4, new CableJointComponent(
      obs2, ball4, initialDist4, initialPoints4.a_circle, initialPoints4.a_attach)); // Order matters
    world.addComponent(joint4, new RenderableComponent('line', '#FFFF00')); // Yellow line

    const cablePath2 = world.createEntity();
    // CablePathComponent constructor now calculates initial stored length and totalRestLength
    const pathComp2 = new CablePathComponent(world, [joint3, joint4], ['attachment', 'rolling', 'attachment'], [true, true, true]); // Order matters
    world.addComponent(cablePath2, pathComp2);



    // --- Systems Registration (Order Matters!) ---
    if (world.systems.length === 0) { // Only register systems once
      world.registerSystem(new GravitySystem());      // Applies gravity acceleration
      world.registerSystem(new MovementSystem());     // Updates position based on velocity

      // --- Cable Systems (Run BEFORE constraint solving) ---

      world.registerSystem(new PBDBallBallCollisions());
      world.registerSystem(new PBDBallObstacleCollisions());
      world.registerSystem(new CableAttachmentUpdateSystem()); // Updates attachment points and rest lengths
      world.registerSystem(new PBDCableConstraintSolver());

      // Pass viewport settings to RenderSystem constructor
      const renderSystem = new RenderSystem(canvas, cScale, simHeight, 0.8, 1.5, 0.4); // Create instance
      world.registerSystem(renderSystem); // Register it
      world.setResource('renderSystem', renderSystem); // Store it as a resource
    }

    // Update button text based on initial pause state
    const pauseState = world.getResource('pauseState');
    pauseBtn.textContent = pauseState.paused ? "Start" : "Pause";
  }


  // --- Main Loop ---
  let lastTime = 0;
  let doStep = false;

  function loop(currentTime) {
    const dt = world.getResource('dt');
    const pauseState = world.getResource('pauseState');
    const errorState = world.getResource('errorState'); // Get error state resource

    // Check error state from the resource
    if (!errorState.hasError && (!pauseState.paused || doStep)) {
      if (doStep) pauseState.paused = false; // Temporarily unpause for step
      try {
          console.log("----------------------------------------------");
          world.update(dt); // <<<--- Wrap update in try...catch
      } catch (error) {
          console.error("!!! Simulation Error Caught !!!", error);
          // simulationStopped = true; // Stop further updates - Handled by setting resource below
          if (errorState) errorState.hasError = true; // Set error state in the resource
          if (pauseState) pauseState.paused = true; // Ensure paused state
          pauseBtn.textContent = "Resume (Error)";
          pauseBtn.disabled = true; // Disable pause/resume after error
          stepBtn.disabled = true; // Disable step after error

          // Dump the world state
          try {
              const stateDump = dumpWorldState(world);
              errorDumpOutput.value = stateDump;
              errorInfoDiv.style.display = 'block';
              errorDumpOutput.style.display = 'block';
              console.log("--- World State Dumped (Copy from text area below canvas) ---");
          } catch (dumpError) {
              console.error("!!! Error during state dumping !!!", dumpError);
              errorDumpOutput.value = `Error during state dumping: ${dumpError}\n\nOriginal error: ${error}`;
              errorInfoDiv.style.display = 'block';
              errorDumpOutput.style.display = 'block';
          }
      } finally {
          if (doStep) {
              if (pauseState) pauseState.paused = true; // Re-pause after step if it was a step
              // Reset button text only if no error occurred
              if (errorState && !errorState.hasError) pauseBtn.textContent = "Resume";
          }
          doStep = false;
      }
    }

    requestAnimationFrame(loop);
  }

  // --- Event Listeners ---
  pauseBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const errorState = world.getResource('errorState');
    if (errorState && errorState.hasError) return; // Don't allow changes if stopped by error
    const pauseState = world.getResource('pauseState');
    if (pauseState) {
      pauseState.paused = !pauseState.paused;
      pauseBtn.textContent = pauseState.paused ? "Resume" : "Pause";
    }
  });

  resetBtn.addEventListener('click', (e) => {
    e.preventDefault();
    setupScene(); // This now resets the errorState resource
    const pauseState = world.getResource('pauseState');
    if (pauseState) pauseState.paused = true;
    pauseBtn.textContent = "Start";
    pauseBtn.disabled = false; // Re-enable buttons
    stepBtn.disabled = false;

    const initialRenderSystem = world.getResource('renderSystem');
    if (initialRenderSystem) {
        initialRenderSystem.update(world, 0);
    }
    doStep = false;
  });

  stepBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const errorState = world.getResource('errorState');
    if (errorState && errorState.hasError) return; // Don't allow changes if stopped by error
    const pauseState = world.getResource('pauseState');
    if (pauseState && pauseState.paused) {
      doStep = true;
    }
  });

  // --- Start ---
  setupScene();
  world.getResource('renderSystem').update(world, 0);
  requestAnimationFrame(loop);

</script>

</body>
</html>
